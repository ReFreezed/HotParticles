--[[============================================================
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

export MAX_BUFFER_SIZE      :: 16000 -- Default buffer size for ParticleSystem is 1000.  @Incomplete: Make this configurable.
export MAIN_PANEL_WIDTH     :: 450
export DIALOG_WIDTH         :: 400
export WORKSPACE_SAVE_DELAY :: 1.00
export MAX_RECENT_FILES     :: 15
export MAX_RECENT_FOLDERS   :: 4

export WINDOW_TITLE :: !run (DEV ? "Hot Particles [DEBUG]" : "Hot Particles")



local isDev :: () -> bool {
	!import "utils"
	return (indexOf(getProgramArguments(), "--dev"))
}
export DEV :: !run isDev()



export !import "basic"
export !import "color"
export !import "string"
export !import "io/path"
export io     :: !import "io"
export math   :: !import "math"
export utf8   :: !import "utf8"
export physfs :: !import "love/physfs"

export love :: !import "love"
export LD :: love.data
export LF :: love.filesystem
export LG :: love.graphics
export LI :: love.image
export LK :: love.keyboard
export LM :: love.mouse
export LT :: love.timer
local  LE :: love.event

export !self
export !load "src/misc"
export !load "src/workspace"
export gui :: !load "src/gui"
!load "src/guiSetup"

!run {
	!import "compiler"
	compile("src/conf.gloa")
}



export fontSmall:  LG.Font = NULL
export fontNormal: LG.Font = NULL
export fontLarge:  LG.Font = NULL

export imageBoxGradient: LG.Image = NULL
export imageChecker:     LG.Image = NULL
export imageGradient:    LG.Image = NULL
export imagePixel:       LG.Image = NULL
export imageRainbow:     LG.Image = NULL

export particleImageNames: []string
export particleImageDatas: struct { !key:string, !value:LF.FileData } -- FileData, not ImageData! The latter is problematic when we export textures.
export particleImages:     struct { !key:string, !value:LG.Image    }
export guiImages:          struct { !key:string, !value:LG.Image    }

local canvasGui:   LG.Canvas = NULL
local canvasWorld: LG.Canvas = NULL

local actionText          = ""
local actionTextTime      = -9999.00
local actionTextDuration :: 0.60
local messageText         = ""
local messageTextTime     = -9999.00
local messageTextDuration = 1.00

export isPositioningParticles = false

export workspaceSaveScheduled = false
export workspaceSaveDelay     = 0.00
export workspaceSaveTime      = -9999.00

export scheduleRecreateCanvases = false

local particleUpdateTime = 0.00
local particleDrawTime   = 0.00
local presentTime        = 0.00

local defaultSearchPaths: []string = NULL

export app: App
export guiState: gui.State

local freezeDtThisFrame      = false
local forcePixelatedTextures = false

local zoomTime = -9999.00



export App :: struct {
	-- Saved workspace data:

	projects: []Project,
	currentProjectIndex = 1,

	showProjectSettings = false,
	showStats           = false,
	showPanelNumbers    = true,

	recentFiles:   []string,
	recentFolders: []string,

	bookmarkedFolders: []string,
}



export Movement :: enum  { NONE::0, CIRCLE, EIGHT, IRREGULAR }

export Project :: struct {
	-- Saved:
	systems: []System,

	bgColorH  = .0,
	bgColorS  = .0,
	bgColorV  = .15,
	bgChecker = 0.0,

	pixelateWorld    = false,
	pixelateTextures = false,

	zoomLevel = 0,

	movementPreset = Movement.NONE,
	movementScaleX = 1.0,
	movementScaleY = 1.0,
	movementSpeed  = 1.0,

	exportBaseDirectory      = "",
	exportParticles          = true,
	exportParticlesOverwrite = false,
	exportParticlesPath      = "",
	exportParticlesTemplate  = "defaultLuaModule",
	exportTextures           = false,
	exportTexturesOverwrite  = false,
	exportTexturesDirectory  = "",
	exportClipboardTemplate  = "defaultLuaClipboard",

	guiLimits: struct { !key:string, !value:float },

	edited = false,
	path   = "", -- Only save in workspace.

	-- Runtime-only:
	systemIndex = 1,

	zoom       = 1.0,
	zoomSource = 1.0,
	zoomTarget = 1.0,

	displayedName = "",
	fileIsSaved   = false, -- Saved at least once (or loaded from a saved file). It's possible that the file physically don't exist (maybe deleted or moved).
	preview       = false,

	movementPhase    = 0.0,
	-- For irregular movement:
	movementPhaseAbs = 0.0,
	movementPoint1X  = 0.0,
	movementPoint1Y  = 0.0,
	movementPoint2X  = 0.0,
	movementPoint2Y  = 0.0,
	movementPoint3X  = 0.0,
	movementPoint3Y  = 0.0,
	movementPoint4X  = 0.0,
	movementPoint4Y  = 0.0,

	_init :: (project:Project) {
		static n = 0 ; n += 1
		project.displayedName = format("(untitled %d)", n)
	},

	!call :: () -> Project {
		local project: Project
		_init(project)
		return project
	},

	clone :: (source:Project) -> Project {
		local project: Project = {
			bgColorH                 = source.bgColorH,
			bgColorS                 = source.bgColorS,
			bgColorV                 = source.bgColorV,
			bgChecker                = source.bgChecker,
			pixelateWorld            = source.pixelateWorld,
			pixelateTextures         = source.pixelateTextures,
			zoomLevel                = source.zoomLevel,
			movementPreset           = source.movementPreset,
			movementScaleX           = source.movementScaleX,
			movementScaleY           = source.movementScaleY,
			movementSpeed            = source.movementSpeed,
			exportBaseDirectory      = source.exportBaseDirectory,
			exportParticles          = source.exportParticles,
			exportParticlesOverwrite = source.exportParticlesOverwrite,
			exportParticlesPath      = source.exportParticlesPath,
			exportParticlesTemplate  = source.exportParticlesTemplate,
			exportTextures           = source.exportTextures,
			exportTexturesOverwrite  = source.exportTexturesOverwrite,
			exportTexturesDirectory  = source.exportTexturesDirectory,
			exportClipboardTemplate  = source.exportClipboardTemplate,
			guiLimits                = copyTable(source.guiLimits),
			edited                   = true,

			zoom       = source.zoom,
			zoomTarget = source.zoomTarget,
		}
		_init(project)

		for source.systems  project.systems[itIndex] = it.clone!()

		updateParticles(project)
		return project
	},
}

export System :: struct {
	-- Saved:
	psDirection                 = 0.0,
	psEmissionAreaDistribution  = LG.AreaSpreadDistribution.NONE,
	psEmissionAreaDx            = 100.0,
	psEmissionAreaDy            = 100.0,
	psEmissionAreaAngle         = 0.0,
	psEmissionAreaRelative      = false,
	psEmissionRate              = 1.0,
	psEmitterContinuous         = true,
	psEmitterLifetime           = 0.0,
	psInsertMode                = LG.ParticleInsertMode.TOP,
	psLinearAccelerationXmin    = 0.0,
	psLinearAccelerationYmin    = 0.0,
	psLinearAccelerationXmax    = 0.0,
	psLinearAccelerationYmax    = 0.0,
	psLinearDampingMin          = 0.0,
	psLinearDampingMax          = 0.0,
	psParticleLifetimeMin       = 1.0,
	psParticleLifetimeMax       = 1.0,
	psRadialAccelerationMin     = 0.0,
	psRadialAccelerationMax     = 0.0,
	psRelativeRotation          = false,
	psRotationMin               = 0.0,
	psRotationMax               = 0.0,
	psSizes: []float            = {1},
	psSizeVariation             = 0.0,
	psSpeedMin                  = 0.0,
	psSpeedMax                  = 0.0,
	psSpinMin                   = 0.0,
	psSpinMax                   = 0.0,
	psSpinVariation             = 0.0,
	psSpread                    = 0.0,
	psTangentialAccelerationMin = 0.0,
	psTangentialAccelerationMax = 0.0,

	colors: []float = {0,0,1,1}, -- {h1,s1,v1,a1,...}
	blendMode = LG.BlendMode.ADD,

	texturePath = "",
	textureName = "light", -- Preset fallback to texturePath.
	offsetX     = .5,
	offsetY     = .5,

	scaleTime  = 1.0,
	scaleSpace = 1.0,
	scaleSize  = 1.0,

	kickStartEmit  = 0,
	kickStartSteps = 0,

	frames: []AnimationFrame,

	gui: struct { !key:string, !value:string },

	-- Runtime-only:
	visible = true,

	particles: LG.ParticleSystem = NULL,

	currentImageData: LF.FileData = NULL,
	currentImage:     LG.Image    = NULL,

	!call :: () -> System {
		local system: System

		system.currentImageData = particleImageDatas.light
		system.currentImage     = particleImages    .light

		system.particles = LG.newParticleSystem(system.currentImage)
		system.particles.stop!() -- Needed for initial kick-start to work.

		return system
	},

	clone :: (source:System) -> System {
		local system: System = {
			psDirection                 = source.psDirection,
			psEmissionAreaDistribution  = source.psEmissionAreaDistribution,
			psEmissionAreaDx            = source.psEmissionAreaDx,
			psEmissionAreaDy            = source.psEmissionAreaDy,
			psEmissionAreaAngle         = source.psEmissionAreaAngle,
			psEmissionAreaRelative      = source.psEmissionAreaRelative,
			psEmissionRate              = source.psEmissionRate,
			psEmitterContinuous         = source.psEmitterContinuous,
			psEmitterLifetime           = source.psEmitterLifetime,
			psInsertMode                = source.psInsertMode,
			psLinearAccelerationXmin    = source.psLinearAccelerationXmin,
			psLinearAccelerationYmin    = source.psLinearAccelerationYmin,
			psLinearAccelerationXmax    = source.psLinearAccelerationXmax,
			psLinearAccelerationYmax    = source.psLinearAccelerationYmax,
			psLinearDampingMin          = source.psLinearDampingMin,
			psLinearDampingMax          = source.psLinearDampingMax,
			psParticleLifetimeMin       = source.psParticleLifetimeMin,
			psParticleLifetimeMax       = source.psParticleLifetimeMax,
			psRadialAccelerationMin     = source.psRadialAccelerationMin,
			psRadialAccelerationMax     = source.psRadialAccelerationMax,
			psRelativeRotation          = source.psRelativeRotation,
			psRotationMin               = source.psRotationMin,
			psRotationMax               = source.psRotationMax,
			psSizes                     = {unpack(source.psSizes)},
			psSizeVariation             = source.psSizeVariation,
			psSpeedMin                  = source.psSpeedMin,
			psSpeedMax                  = source.psSpeedMax,
			psSpinMin                   = source.psSpinMin,
			psSpinMax                   = source.psSpinMax,
			psSpinVariation             = source.psSpinVariation,
			psSpread                    = source.psSpread,
			psTangentialAccelerationMin = source.psTangentialAccelerationMin,
			psTangentialAccelerationMax = source.psTangentialAccelerationMax,
			colors                      = {unpack(source.colors)},
			blendMode                   = source.blendMode,
			texturePath                 = source.texturePath,
			textureName                 = source.textureName,
			offsetX                     = source.offsetX,
			offsetY                     = source.offsetY,
			scaleTime                   = source.scaleTime,
			scaleSpace                  = source.scaleSpace,
			scaleSize                   = source.scaleSize,
			kickStartEmit               = source.kickStartEmit,
			kickStartSteps              = source.kickStartSteps,
			gui                         = copyTable(source.gui),

			particles = source.particles.clone!(),
		}

		for source.frames {
			system.frames[itIndex] = {x=it.x, y=it.y, w=it.w, h=it.h}
		}

		system.particles.stop!()
		return system
	},
}

export AnimationFrame :: struct { x=0.0, y=0.0, w=0.0, h=0.0 }



export updateParticles :: (project:Project) {
	for project.systems {
		updateParticleParams(it)
		updateParticleColors(it)
		updateParticleTexture(project, it)
	}
}

export updateParticleParams :: (s:System) {
	local ps = s.particles

	local time  = s.scaleTime
	local space = s.scaleSpace
	local size  = s.scaleSize

	local sizes: []float
	for s.psSizes  insert(sizes, it*size)

	ps.setDirection!(s.psDirection)
	ps.setEmissionArea!(s.psEmissionAreaDistribution, s.psEmissionAreaDx*space, s.psEmissionAreaDy*space, s.psEmissionAreaAngle, s.psEmissionAreaRelative)
	ps.setEmissionRate!(s.psEmissionRate*time)
	ps.setEmitterLifetime!(s.psEmitterContinuous ? -1 : s.psEmitterLifetime/time)
	ps.setInsertMode!(s.psInsertMode)
	ps.setLinearAcceleration!(s.psLinearAccelerationXmin*space*time^2, s.psLinearAccelerationYmin*space*time^2, s.psLinearAccelerationXmax*space*time^2, s.psLinearAccelerationYmax*space*time^2)
	ps.setLinearDamping!(s.psLinearDampingMin*time, s.psLinearDampingMax*time)
	ps.setParticleLifetime!(s.psParticleLifetimeMin/time, s.psParticleLifetimeMax/time)
	ps.setRadialAcceleration!(s.psRadialAccelerationMin*space*time^2, s.psRadialAccelerationMax*space*time^2)
	ps.setRelativeRotation!(s.psRelativeRotation)
	ps.setRotation!(s.psRotationMin, s.psRotationMax)
	ps.setSizes!(sizes)
	ps.setSizeVariation!(s.psSizeVariation)
	ps.setSpeed!(s.psSpeedMin*space*time, s.psSpeedMax*space*time)
	ps.setSpin!(s.psSpinMin*time, s.psSpinMax*time)
	ps.setSpinVariation!(s.psSpinVariation)
	ps.setSpread!(s.psSpread)
	ps.setTangentialAcceleration!(s.psTangentialAccelerationMin*space*time^2, s.psTangentialAccelerationMax*space*time^2)
}

export updateParticleColors :: (system:System) {
	local colors = system.colors
	local colorsRgba: []float

	for i = 1, #colors, 4 {
		local r, g, b = hsvToRgb(colors[i], colors[i+1], colors[i+2])
		insert(colorsRgba, r)
		insert(colorsRgba, g)
		insert(colorsRgba, b)
		insert(colorsRgba, colors[i+3])
	}

	system.particles.setColors!(colorsRgba)
}

export updateParticleTextures :: (project:Project) {
	for project.systems  updateParticleTexture(project, it)
}

export updateParticleTexture :: (project:Project, system:System) {
	local loadParticleTexture :: (project:Project, system:System) -> LF.FileData, LG.Image {
		local ok, path, isDangling = getTextureFullPath(project, system)
		if not ok {
			if isDangling
				setErrorText("Relative paths require the project to be saved: %s", path)
			else
				setErrorText("Bad texture path '%s'", path)
			return NULL, NULL
		}

		local ^ok, dir, filename = Path(path).getDirectoryAndFilename!()
		assert(ok)

		if not connectToRemoteDirectory(dir) {
			setErrorText("Could not access folder '%s'", dir)
			return NULL, NULL
		}
		defer disconnectFromRemoteDirectory()

		local imageData, err = LF.newFileData(filename)

		if imageData == NULL {
			setErrorText(err)
			return NULL, NULL
		}

		local image = LG.newImage(filename)

		return cast(LF.FileData)imageData, image
	}

	local imageData: LF.FileData = NULL
	local image:     LG.Image    = NULL

	if system.texturePath  imageData, image = loadParticleTexture(project, system) -- @Speed: Don't reload the texture if there's no change.

	if imageData == NULL {
		imageData = particleImageDatas[system.textureName]
		image     = particleImages    [system.textureName]
	}

	system.currentImageData = imageData
	system.currentImage     = image

	system.particles.setTexture!(image)
	updateParticleAnimation(system)

	local filter = project.pixelateTextures ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR
	image.setFilter!(filter, filter)
}

export updateParticleAnimation :: (system:System) {
	if system.frames {
		local iw, ih = system.currentImage.getDimensions!()
		local quads: []LG.Quad

		for system.frames {
			insert(quads, LG.newQuad(it.x, it.y, it.w, it.h, iw, ih))
		}

		system.particles.setQuads!(quads)

	} else {
		system.particles.setQuads!()
	}
	updateParticleTextureOffset(system)
}

export updateParticleTextureOffset :: (system:System) {
	if system.frames {
		local animFrame1 = system.frames[1]
		system.particles.setOffset!(animFrame1.w*system.offsetX, animFrame1.h*system.offsetY)
	} else {
		local iw, ih = system.currentImage.getDimensions!()
		system.particles.setOffset!(iw*system.offsetX, ih*system.offsetY)
	}
}



export updateParticleImageFilters :: () {
	local project = app.projects[app.currentProjectIndex]
	local filter  = (project.pixelateTextures or forcePixelatedTextures) ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR

	for particleImageNames {
		particleImages[it].setFilter!(filter, filter)
	}

	local system = project.systems[project.systemIndex]
	system.currentImage.setFilter!(filter, filter) -- In case this is a custom texture.
}



export addNewSystem :: (project:Project, showcase=false) {
	local system = System()
	insert(project.systems, system)

	if showcase {
		system.psDirection           = -math.TAU/4
		system.psEmissionRate        = 20
		system.psParticleLifetimeMin = 1.8
		system.psParticleLifetimeMax = 2.2
		system.psSpeedMin            = 90
		system.psSpeedMax            = 100
		system.psSpread              = .05*math.TAU
		system.colors                = {0,0,1,0, 0,0,1,1, 0,0,1,.5, 0,0,1,0}
	}
	updateParticleParams(system)
	updateParticleColors(system)

	if project.systems[2] ~= NULL {
		local x, y = project.systems[1].particles.getPosition!()
		system.particles.setPosition!(x, y)
	}
}

export addNewProject :: () -> Project {
	local project = Project()
	insert(app.projects, project)

	addNewSystem(project, showcase=true)

	return project
}



export createCanvases :: () {
	local ww, wh = LG.getDimensions()

	if canvasGui ~= NULL {
		canvasGui  .release!()
		canvasWorld.release!()
	}

	local SETTINGS: LG.CanvasSettings : {msaa=2^2}
	canvasGui   = LG.newCanvas(ww, wh, SETTINGS)
	canvasWorld = LG.newCanvas(math.max(ww-MAIN_PANEL_WIDTH, 1), wh)

	if app.projects[app.currentProjectIndex].pixelateWorld {
		canvasWorld.setFilter!(LG.FilterMode.NEAREST, LG.FilterMode.NEAREST)
	}

	scheduleRecreateCanvases = false
}



export moveEmittersTo :: (x,y:float) {
	for app.projects[app.currentProjectIndex].systems  it.particles.moveTo!(x, y)
}



export pushQuitEvent :: () {
	saveWorkspace()
	LE.quit(0)
}



export connectToRemoteDirectory :: (dir:string) -> (success:bool) {
	if not physfs.setWriteDirectory(dir)  return false

	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it))

	assert(physfs.mountReadDirectory(dir)) -- If we can write then we should be able to read too.
	return true
}

export disconnectFromRemoteDirectory :: () {
	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it),     it)
	for defaultSearchPaths       assert(physfs.mountReadDirectory(it, true), it)

	assert(physfs.setWriteDirectory(LF.getSaveDirectory()))
}



export setActionText :: (s:string) {
	actionText     = s
	actionTextTime = LT.getTime()
	messageText    = "" -- Good?
}
export setActionText :: (s:string, v,...:int|float|string) {
	setActionText(format(s, v, ...))
}

export setMessageText :: (s:string) {
	if messageText ~= s  print(s)

	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 3.00
}
export setMessageText :: (s:string, v,...:int|float|string) {
	setMessageText(format(s, v, ...))
}

export setErrorText :: (s:string) {
	s = "Error: "..s
	if messageText ~= s  print(s)

	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 8.00
}
export setErrorText :: (s:string, v,...:int|float|string) {
	setErrorText(format(s, v, ...))
}



local onRun :: () -> (mainLoop:()->int|none) {
	local LOVE: struct { !key:string, !value:(...:love.Variant) } : !foreign lua "love"

	local argsRaw = !import"utils".getCommandLineArguments()
	LOVE.load(love.arg.parseGameArguments(argsRaw), argsRaw)

	LT.step()
	local dt = .0

	return [dt] () -> int|none {
		LE.pump()
		for name, a,b,c,d,e,f in LE.poll() {
			if name == LE.Event.QUIT {
				-- if not (cast(()->bool)cast(any)LOVE.quit)() {
					return a == NULL ? 0 : cast(int)a
				-- }
			}
			local HANDLERS: struct { !key:LE.Event, !value:(...:love.Variant) } : !foreign lua "love.handlers"
			HANDLERS[name](a,b,c,d,e,f)
		}

		dt = LT.step()
		LOVE.update(dt)

		if LG.isActive()  LOVE.draw()

		LT.sleep(0.001)
		return nil
	}
}



local onLoad :: (args:[]string, argsRaw:[]string) {
	io.disableBuffering(io.STDOUT)
	io.disableBuffering(io.STDERR)

	print("Running Hot Particles")
	love.window.setTitle(WINDOW_TITLE)

	local projectsToOpen: []string

	for args {
		if not findPattern(it, "^%-") {
			insert(projectsToOpen, it)

		} elseif it == "--help" or it == "-help" or it == "-?" or it == "/help" or it == "/?" {
			print("Argument synopsis:  HotParticles.exe [fileToOpen1 fileToOpen2 ...]")

		} else {
			printf("Unknown option '%s'.", it)
		}
	}

	LK.setKeyRepeat(true)

	defaultSearchPaths = physfs.getSearchPaths()

	LF.createDirectory("projects")

	fontSmall  = LG.newFont(10)
	fontNormal = LG.newFont(12)
	fontLarge  = LG.newFont(16)

	imageBoxGradient = LG.newImage("gfx/boxGradient.png")
	imageChecker     = LG.newImage("gfx/checker.png") ; imageChecker.setWrap!(LG.WrapMode.REPEAT, LG.WrapMode.REPEAT) ; imageChecker.setFilter!(LG.FilterMode.NEAREST, LG.FilterMode.NEAREST)
	imageGradient    = LG.newImage("gfx/gradient.png")
	imagePixel       = LG.newImage("gfx/pixel.png")
	imageRainbow     = LG.newImage("gfx/rainbow.png")

	!load "src/icons"
	generateIcons()

	for LF.getDirectoryItems"gfx/particles" {
		local found, name = matchPattern(it, "^(.+)%.png$")

		if found {
			local path      = "gfx/particles/"..it
			local imageData = LF.newFileData(path)
			local image     = LG.newImage(path)

			particleImageDatas[cast(string)name] = imageData
			particleImages    [cast(string)name] = image
			guiImages         [cast(string)name] = image

			insert(particleImageNames, cast(string)name)
		}
	}

	do {
		local ok, gotError, _app = loadWorkspace("workspace")
		if ok {
			app = _app
			assert(app.projects[1] ~= NULL)
		} else {
			if gotError  setErrorText("Could not load previous workspace")
			addNewProject()
		}

		for app.projects  updateParticles(it)
	}

	love.window.setVSync(app.showStats ? 0 : 1)

	setupGuiFrames()
	setupGuiCallbacks()
	gui.refreshAll(guiState)

	setCurrentProject(app.currentProjectIndex, force=true)

	for projectsToOpen {
		local ok, project, isNew = openProject(it)
		if ok and not isNew  updateParticles(project)
	}
}



local onFileDropped :: (file:LF.DroppedFile) {
	openProject(file.getFilename!())
}



local onKeyPressed :: (key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) {
	local mod       = getModifierKey()
	local modAndKey = combineKeyAndModifier(mod, key)
	local project   = app.projects[app.currentProjectIndex]

	-- Global keys.
	if not LM.isGrabbed()  if modAndKey == {
		case "c-q":
			pushQuitEvent()
			return

		case "c-f10":
			saveWorkspace()
			LE.restart()
			return

		case "f1":
			app.showStats = not app.showStats
			love.window.setVSync(app.showStats ? 0 : 1)
			scheduleSaveWorkspace()
			return

		case "f2":
			app.showPanelNumbers = not app.showPanelNumbers
			scheduleSaveWorkspace()
			return
	}

	if gui.onKeyPressed(guiState, key, scancode, isRepeat)  return
	if LM.isGrabbed()  return

	-- Context-sensitive global keys.
	if key == "escape" {
		if popPanel()  return

		local BUTTONS: []gui.Button : {{label="Exit"},{label="Cancel"}}

		pushTempChoiceDialog("", "", BUTTONS, submitIndex=1, (i:int) {
			if i == 1  pushQuitEvent()
		})

		return
	}

	if modAndKey == {
		case "r":
			for project.systems {
				it.particles.stop!()
				it.particles.reset!()
			}
			return

		case "c-s-o":
			local ok, dir = Path(app.projects[app.currentProjectIndex].path).getDirectory!()
			if ok  love.system.openURL("file://"..dir)
			return
	}

	if panelStack  return

	-- Keys in normal view.
	if modAndKey == {
		case "c-s":   if project.fileIsSaved  saveProject(project, overwrite=true)  else  pushPanel("saveProjectAs")
		case "c-s-s": pushPanel("saveProjectAs")
		case "c-e":   pushPanel("exportProject")
		case "c-o":   pushPanel("openProject")
		case "c-n":   addNewProject() ; gui.refreshRecursively(guiState, "projects") ; setCurrentProject(#app.projects) ; scheduleSaveWorkspace()
		case "c-w":   if not (#app.projects == 1 and not (app.projects[1].path or app.projects[1].edited))  confirmCloseProject(app.currentProjectIndex)

		case "c-s-t":
			for app.recentFiles  if not indexWith(app.projects, "path", it) {
				openProject(it)
				break
			}

		case "tab":     setCurrentSystem ((project.systemIndex     - 0) % #project.systems + 1)
		case "s-tab":   setCurrentSystem ((project.systemIndex     - 2) % #project.systems + 1)
		case "c-tab":   setCurrentProject((app.currentProjectIndex - 0) % #app.projects    + 1)
		case "c-s-tab": setCurrentProject((app.currentProjectIndex - 2) % #app.projects    + 1)

		case "h": local system = project.systems[project.systemIndex] ; system.visible = not system.visible

		case "p": gui.setActive(guiState, "main", not gui.getElement(guiState, "main").active)
	}
}

local onKeyReleased :: (key:LK.KeyConstant, scancode:LK.Scancode) {
	gui.onKeyReleased(guiState, key, scancode)
}

local onTextInput :: (text:string) {
	if gui.onTextInput(guiState, text)  return
}

local onMousePressed :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch         return
	if LM.isGrabbed()  return

	if gui.onMousePressed(guiState, mx, my, mbutton, presses)  return

	local showTextureOffset, showAnimationFrames, showWorld = getVisibilityFlags()
	if not showWorld  return

	if mbutton == 1 {
		isPositioningParticles = true
		LM.setGrabbed(true)
		LK.setKeyRepeat(false)
		onMouseMoved(mx,my, 0,0, false)
	}
}

local onMouseMoved :: (mx,my:int, dx,dy:int, isTouch:bool) {
	if isTouch  return

	if isPositioningParticles {
		local project = app.projects[app.currentProjectIndex]

		local x = (mx - (LG.getWidth()+MAIN_PANEL_WIDTH)/2) / project.zoom
		local y = (my - (LG.getHeight()                )/2) / project.zoom

		moveEmittersTo(x, y)
		return
	}

	gui.onMouseMoved(guiState, mx, my, dx, dy)
}

local onMouseReleased :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch  return

	if isPositioningParticles and mbutton == 1 {
		isPositioningParticles = false
		LM.setGrabbed(false)
		LK.setKeyRepeat(true)
		gui.onMouseMoved(guiState, mx, my, 0, 0)
		return
	}

	gui.onMouseReleased(guiState, mx, my, mbutton, presses)
}

local onMouseWheel :: (dx,dy:int) {
	if LM.isGrabbed()                      return
	if gui.onMouseWheel(guiState, dx, dy)  return
	if not dy                              return

	local showTextureOffset, showAnimationFrames, showWorld = getVisibilityFlags()
	if not showWorld  return

	local mx, my = LM.getPosition()
	if gui.isOverGui(guiState, mx, my)  return

	local mod = getModifierKey()
	if mod ~= ModifierKey.NONE  return

	local project   = app.projects[app.currentProjectIndex]
	local zoomLevel = project.zoomLevel
	local now       = LT.getTime()

	for 1, math.abs(dy) {
		-- Stick slightly to 100% zoom.
		if zoomLevel == 0 and now-zoomTime < 0.15  break

		zoomLevel = math.clamp(zoomLevel + math.getSign(dy), (project.pixelateWorld ? -1 : -4), 6)
	}

	zoomTime = now

	if zoomLevel == project.zoomLevel  return

	project.zoomLevel  = zoomLevel
	project.zoomSource = project.zoom
	project.zoomTarget = 2 ^ project.zoomLevel

	setActionText("Zoom: %d%%", project.zoomTarget * 100)
}



local onUpdate :: (dt:float) {
	if freezeDtThisFrame {
		dt                = 0
		freezeDtThisFrame = false
	}

	local project = app.projects[app.currentProjectIndex]

	if gui.getTopmostActiveModal(guiState) == NULL {
		local systemsActive = false

		local time = LT.getTime()
		for project.systems  it.particles.update!(dt)
		particleUpdateTime = LT.getTime()-time

		-- F for fast-forward!
		if not guiState.focusId and LK.isDown"f" and getModifierKey() == ModifierKey.NONE {
			for 2, 10 {
				for project.systems  it.particles.update!(dt)
			}
		}

		for system: project.systems {
			local ps      = system.particles
			systemsActive = systemsActive or ps.isActive!() or ps.getCount!() > 0

			if ps.getCount!() > 0.95 * ps.getBufferSize!() {
				if updateBufferSize(system)  setActionText("Increased buffer size")
			}
		}

		if not systemsActive  for system: project.systems {
			system.particles.start!()

			-- Note: Kick-starting may make things look a bit weird if the
			-- emitter has a too short lifetime compared to the particles.
			if system.kickStartSteps {
				local kickStartDt = getKickStartDt(system)
				for i = 1, system.kickStartSteps  system.particles.update!(kickStartDt)
			}

			system.particles.emit!(system.kickStartEmit)
		}
	}

	if workspaceSaveScheduled {
		workspaceSaveDelay -= dt
		if workspaceSaveDelay <= 0  saveWorkspace()
	}

	if scheduleRecreateCanvases  createCanvases()

	if not isPositioningParticles {
		local MOVEMENT_BASE :: 250

		-- project.movementSpeed = LK.isDown"." ? .04 : 1 -- DEBUG

		local lastMovementPhaseAbs  = project.movementPhaseAbs
		project.movementPhase      +=         (project.movementSpeed) * dt
		project.movementPhaseAbs   += math.abs(project.movementSpeed) * dt

		using project.movementPreset
		if !complete project.movementPreset == {
			case NONE:
				-- void

			case CIRCLE:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE * project.movementScaleY * math.sin(angle)
				)

			case EIGHT:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE   * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE/2 * project.movementScaleY * math.sin(angle*2)
				)

			case IRREGULAR:
				if math.floor(project.movementPhaseAbs) ~= math.floor(lastMovementPhaseAbs) or lastMovementPhaseAbs == 0 {
					local dx       = project.movementPoint3X - project.movementPoint4X
					local dy       = project.movementPoint3Y - project.movementPoint4Y
					local angleOld = math.atan(-dy, -dx)

					project.movementPoint1X = project.movementPoint4X
					project.movementPoint1Y = project.movementPoint4Y
					project.movementPoint2X = project.movementPoint4X - dx
					project.movementPoint2Y = project.movementPoint4Y - dy
					project.movementPoint4X = .8*MOVEMENT_BASE * (2*love.math.random()-1)
					project.movementPoint4Y = .8*MOVEMENT_BASE * (2*love.math.random()-1)

					dx             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					dy             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					local angleNew = math.atan(dy, dx)

					if math.angleDistance(angleNew, angleOld) > math.TAU/4 {
						dx = -dx
						dy = -dy
					}

					project.movementPoint3X = project.movementPoint4X + dx
					project.movementPoint3Y = project.movementPoint4Y + dy
				}

				local phase    = project.movementPhaseAbs % 1
				local phaseOld =     math.sin  (phase * math.TAU/4)
				local phaseNew = 1 - math.cos  (phase * math.TAU/4)
				local phaseMid = 1 - math.cos01(phase * math.TAU/2)

				moveEmittersTo(
					project.movementScaleX * math.lerp(
						math.lerp(project.movementPoint1X, project.movementPoint2X, phaseOld),
						math.lerp(project.movementPoint3X, project.movementPoint4X, phaseNew),
						phaseMid
					),
					project.movementScaleY * math.lerp(
						math.lerp(project.movementPoint1Y, project.movementPoint2Y, phaseOld),
						math.lerp(project.movementPoint3Y, project.movementPoint4Y, phaseNew),
						phaseMid
					)
				)
		}
	}

	project.zoom = math.moveTowards(
		project.zoom,
		project.zoomTarget,
		math.abs(project.zoomTarget - project.zoomSource) * dt / 0.05
	)

	gui.update(guiState, dt)
}



local getVisibilityFlags :: () -> bool, bool, bool {
	static wasHoveringTextureOffset = false
	static textureOffsetHoverTime   = -9999.00

	local isHoveringTextureOffset
		=  math.max(guiState.activeId, guiState.hoveredId) == gui.getElement(guiState, "textureOffsetX").id
		or math.max(guiState.activeId, guiState.hoveredId) == gui.getElement(guiState, "textureOffsetY").id

	if isHoveringTextureOffset ~= wasHoveringTextureOffset {
		wasHoveringTextureOffset = isHoveringTextureOffset
		textureOffsetHoverTime   = LT.getTime()
	}

	local showTextureOffset   = (isHoveringTextureOffset and LT.getTime() - textureOffsetHoverTime > 4/60)
	local showAnimationFrames = gui.getElement(guiState, "animation").active
	local showWorld           = not (showTextureOffset or showAnimationFrames)

	static didShowWorld = true

	if showWorld ~= didShowWorld {
		didShowWorld           = showWorld
		forcePixelatedTextures = not showWorld -- A bit misplaced... @Cleanup
		updateParticleImageFilters()
	}

	return showTextureOffset, showAnimationFrames, showWorld
}

local onDraw :: () {
	static statsAll:   LG.Stats
	static statsWorld: LG.Stats

	local ww, wh  = LG.getDimensions()
	local project = app.projects[app.currentProjectIndex]

	local showTextureOffset, showAnimationFrames, showWorld = getVisibilityFlags()

	LG.reset()

	-- World.
	do {
		LG.setCanvas(canvasWorld)

		local r, g, b = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
		LG.clear(r, g, b)

		if project.bgChecker {
			if project.bgChecker > 0
				LG.setColor(1, 1, 1, project.bgChecker)
			else
				LG.setColor(0, 0, 0, -project.bgChecker)
			gui.drawChecker(0, 0, ww, wh, 2)
		}

		if showWorld {
			LG.translate((ww-MAIN_PANEL_WIDTH)/2, wh/2)
			if not project.pixelateWorld  LG.scale(project.zoom)

			local time = LT.getTime()

			LG.setColor(1, 1, 1)
			for project.systems {
				if it.visible {
					LG.setBlendMode(it.blendMode)
					LG.draw(it.particles)
				}
			}

			particleDrawTime = LT.getTime()-time -- Not sure how accurate this actually is. This value is still very low even while the actual FPS is tanking a lot.
			-- !if DEV  LG.getStats(statsWorld)

			--[[ DEBUG
			LG.setColor(1, 1, 1, .15)
			LG.line(project.movementPoint1X, project.movementPoint1Y, project.movementPoint2X, project.movementPoint2Y)
			LG.line(project.movementPoint2X, project.movementPoint2Y, project.movementPoint3X, project.movementPoint3Y)
			LG.line(project.movementPoint3X, project.movementPoint3Y, project.movementPoint4X, project.movementPoint4Y)
			LG.setColor(1, 1, 1, .3)
			LG.print("1", project.movementPoint1X, project.movementPoint1Y)
			LG.print("2", project.movementPoint2X, project.movementPoint2Y)
			LG.print("3", project.movementPoint3X, project.movementPoint3Y)
			LG.print("4", project.movementPoint4X, project.movementPoint4Y)
			--]]

			LG.reset()
		}
	}

	-- GUI.
	do {
		LG.setCanvas(canvasGui)
		LG.clear()

		LG.setFont(fontNormal)

		-- Texture offset/animation frames.
		if showTextureOffset or showAnimationFrames {
			local PADDING :: 20

			local system = project.systems[project.systemIndex]
			local image  = system.currentImage
			local iw, ih = image.getDimensions!()

			local scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/iw, (wh-2*PADDING)/ih)

			local x0 = (ww - iw*scale + MAIN_PANEL_WIDTH) // 2
			local y0 = (wh - ih*scale                   ) // 2

			if showTextureOffset {
				local w = iw
				local h = ih

				if system.frames {
					local quads        = system.particles.getQuads!()
					local quad         = getQuadForAnimationPreview(system.particles, quads)
					local _, _, qw, qh = quads[1].getViewport!()

					w = math.round(qw)
					h = math.round(qh)

					scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/w, (wh-2*PADDING)/h)

					x0 = (ww - w*scale + MAIN_PANEL_WIDTH) // 2
					y0 = (wh - h*scale                   ) // 2

					LG.setColor(1, 1, 1)
					LG.draw(image, quad, x0, y0, 0, scale)

				} else {
					LG.setColor(1, 1, 1)
					LG.draw(image, x0, y0, 0, scale)
				}

				local HALF_WIDTH  :: 3
				local HALF_LENGTH :: 20
				local x = math.round(x0 + w*scale*system.offsetX)
				local y = math.round(y0 + h*scale*system.offsetY)
				LG.setColor(0, 0, 0, .9)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH-1, y-HALF_LENGTH-1, 2*HALF_WIDTH+2, 2*HALF_LENGTH+2)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH-1, y-HALF_WIDTH-1, 2*HALF_LENGTH+2, 2*HALF_WIDTH+2)
				LG.setColor(1, 1, 1)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH, y-HALF_LENGTH, 2*HALF_WIDTH, 2*HALF_LENGTH)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH, y-HALF_WIDTH, 2*HALF_LENGTH, 2*HALF_WIDTH)
			}

			if showAnimationFrames {
				LG.setColor(1, 1, 1)
				LG.draw(image, x0, y0, 0, scale)

				LG.setColor(0, 1, 0)

				for system.frames {
					local x1 = math.round(x0 + scale * (it.x       ))
					local y1 = math.round(y0 + scale * (it.y       ))
					local x2 = math.round(x0 + scale * (it.x + it.w))
					local y2 = math.round(y0 + scale * (it.y + it.h))
					LG.rectangle(LG.DrawMode.LINE, x1+.5, y1+.5, x2-x1-1, y2-y1-1)
				}

				local occupiedCoords: Table(int, bool)

				for system.frames {
					local text = format("%d", itIndex)
					local x    = math.round(x0 + scale * it.x) + 2
					local y    = math.round(y0 + scale * it.y)

					while occupiedCoords[y*iw+x]  y += fontNormal.getHeight!()
					occupiedCoords[y*iw+x] = true

					LG.setColor(0, 0, 0)
					LG.print(text, x+1, y+1)
					LG.setColor(0, 1, 0)
					LG.print(text, x, y)
				}

				local mx, my = LM.getPosition()

				if love.window.hasMouseFocus() and not (guiState.activeId or gui.isOverGui(guiState, mx, my)) {
					local text = format(
						"[%d, %d]",
						math.clamp(math.floor((mx-x0)/scale), 0, iw),
						math.clamp(math.floor((my-y0)/scale), 0, ih)
					)
					local x = math.min(mx, ww-fontNormal.getWidth!(text)-2)
					local y = my+20
					if y+fontNormal.getHeight!() > wh-2  y = my-10-fontNormal.getHeight!()
					LG.setColor(0, 0, 0)
					LG.print(text, x+1, y+1)
					LG.setColor(1, 1, 1)
					LG.print(text, x, y)
				}
			}
		}

		-- Stats.
		if app.showStats {
			local particleCountTotal = 0
			for project.systems  particleCountTotal += it.particles.getCount!()

			local fontH = fontNormal.getHeight!()

			local x = MAIN_PANEL_WIDTH+5
			local y = 5

			local r, g, b          = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
			local _, _, brightness = rgbToHsp(r, g, b)
			if brightness < .5
				LG.setColor(1, 1, 1, .7)
			else
				LG.setColor(0, 0, 0, .7)

			local drawStatsLine = [x,y,fontH] (pre:string, s:string, ...:int|float|string) {
				LG.print(pre, x, y)
				if s  LG.print(format(s, ...), x+fontNormal.getWidth!(pre), y)
				y += fontH+1
			}

			local _, _, windowMode = love.window.getMode()
			local ratio            = 1 / presentTime / windowMode.refreshrate

			drawStatsLine("FPS: ", "%d", LT.getFPS())

			!if DEV {
				local stats = statsAll
				if stats ~= NULL {
					drawStatsLine("drawcalls (batched): ",    "%d (%d)",  stats.drawcalls, stats.drawcallsbatched)
					drawStatsLine("switches canvas/shader: ", "%d/%d",    stats.canvasswitches, stats.shaderswitches)
					drawStatsLine("texture memory: ",         "%.2f MiB", stats.texturememory/1024^2)
					drawStatsLine("images/fonts/canvases: ",  "%d/%d/%d", stats.images, stats.fonts, stats.canvases)
				}
			}

			drawStatsLine("ParticleSystemUpdateTime: ", "%.3f ms", 1000*particleUpdateTime)
			drawStatsLine("ParticleSystemDrawTime: ",   "%.3f ms", 1000*particleDrawTime)

			if not windowMode.refreshrate {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms", 1000*presentTime)
			} elseif ratio >= 10 {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.0f.0 x framerate)", 1000*presentTime, ratio)
			} elseif ratio >= 2 {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.1f0 x framerate)",  1000*presentTime, ratio)
			} else {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.2f x framerate)",   1000*presentTime, ratio)
			}

			drawStatsLine("ParticleCountTotal: ", "%d", particleCountTotal)

			for project.systems  drawStatsLine("ParticleCount_", "%d: %d/%d (%d)", itIndex, it.particles.getCount!(), getOptimalBufferSize(it, moreExact=true), it.particles.getBufferSize!())

			!if not DEV  drawStatsLine("(hide this with F1)", "")
		}

		-- Panel(s).
		gui.draw(guiState)

		-- GUI texts.
		local drawGuiText :: (text:string, time:float, duration:float, y:int) {
			local PADDING_X :: 15
			local PADDING_Y :: 3

			local visibility = 1 - (LT.getTime() - time) / duration
			if visibility <= 0  return

			local w = fontLarge.getWidth!(text)
			local x = (LG.getWidth() + (gui.getTopmostActiveModal(guiState) == NULL ? MAIN_PANEL_WIDTH : 0) - w) // 2
			local a = visibility ^ .5

			LG.setColor(0, 0, 0, a)
			LG.print(text, x+1, y+1)

			LG.setColor(1, 1, 1, a)
			LG.print(text, x, y)
		}

		local anyInfiniteEmitter = false
		local anyFiniteEmitter   = false

		for project.systems {
			if it.particles.getEmitterLifetime!() < 0
				anyInfiniteEmitter = true
			else
				anyFiniteEmitter   = true
		}

		LG.origin()
		LG.setFont(fontLarge)

		local dist = fontLarge.getHeight!() + 5

		if project.preview {
			drawGuiText("PREVIEW", 0, math.HUGE, 10)
		}
		if anyFiniteEmitter and anyInfiniteEmitter {
			drawGuiText("Warning: Mixing infinite and finite emitters", 0, math.HUGE, 10+1*dist)
		}
		drawGuiText(messageText, messageTextTime, messageTextDuration, 10+2*dist)
		drawGuiText(actionText,  actionTextTime,  actionTextDuration,  10+3*dist)

		-- Dev/debug stuff.
		!if DEV {
			local visibility = 1 - (LT.getTime() - workspaceSaveTime) / 0.40
			if visibility > 0 {
				LG.setColor(1, 1, 1, .4*visibility^.5)
				LG.circle(LG.DrawMode.FILL, ww-10, 10, 4, 8)
			}

			-- LG.setColor(1, 1, 1)
			-- LG.print(format("%d", LT.getFPS()))
		}

		--[[ Mouse stuff.
		local mx, my = LM.getPosition()
		if isPositioningParticles {
			LG.setColor(1, 0, 0)
			LG.line(mx-50, my, mx+50, my)
			LG.line(mx, my-50, mx, my+50)
		}
		--]]

		LG.reset()
	}

	-- Put stuff on the screen!
	LG.clear(0, 0, 0, 1)
	LG.setBlendMode(LG.BlendMode.ALPHA, LG.BlendAlphaMode.PREMULTIPLIED)

	if project.pixelateWorld {
		LG.draw(canvasWorld, (ww+MAIN_PANEL_WIDTH)/2,wh/2, 0, project.zoom,project.zoom, (ww-MAIN_PANEL_WIDTH)/2, wh/2)
	} else {
		LG.draw(canvasWorld, MAIN_PANEL_WIDTH,0)
	}

	LG.draw(canvasGui)

	!if DEV  LG.getStats(statsAll)

	local time = LT.getTime()
	LG.present()
	presentTime = LT.getTime()-time
}



local onResize :: (w,h:int) {
	createCanvases()
	guiState.layoutNeedsUpdate = true
	freezeDtThisFrame          = true -- Fixes things jumping forward like crazy (in Windows at least).
}



local main :: () {
	!import "utils"
	local LOVE: table : !foreign lua "love"

	LOVE.run           = wrapFunctionInGloaErrorHandler(onRun)
	LOVE.load          = wrapFunctionInGloaErrorHandler(onLoad)
	LOVE.filedropped   = wrapFunctionInGloaErrorHandler(onFileDropped)
	LOVE.keypressed    = wrapFunctionInGloaErrorHandler(onKeyPressed)
	LOVE.keyreleased   = wrapFunctionInGloaErrorHandler(onKeyReleased)
	LOVE.textinput     = wrapFunctionInGloaErrorHandler(onTextInput)
	LOVE.mousepressed  = wrapFunctionInGloaErrorHandler(onMousePressed)
	LOVE.mousemoved    = wrapFunctionInGloaErrorHandler(onMouseMoved)
	LOVE.mousereleased = wrapFunctionInGloaErrorHandler(onMouseReleased)
	LOVE.wheelmoved    = wrapFunctionInGloaErrorHandler(onMouseWheel)
	LOVE.update        = wrapFunctionInGloaErrorHandler(onUpdate)
	LOVE.draw          = wrapFunctionInGloaErrorHandler(onDraw)
	LOVE.resize        = wrapFunctionInGloaErrorHandler(onResize)
	LOVE.errorhandler  = nil
	LOVE.errhand       = nil
}



export setCurrentProject :: (i:int, force=false) {
	if app.currentProjectIndex == i and not force  return

	app.currentProjectIndex = i
	gui.getElement(guiState, "projects", gui.Tabs).index = i

	gui.refreshRecursively(guiState, "projectSettings")
	gui.refreshRecursively(guiState, "systems")

	scheduleRecreateCanvases = true
	updateParticleImageFilters()

	setCurrentSystem(app.projects[i].systemIndex, force=true)

	updateWindowTitle()
}

export setCurrentSystem :: (i:int, force=true) {
	local project = app.projects[app.currentProjectIndex]
	if project.systemIndex == i and not force  return

	project.systemIndex = i
	gui.getElement(guiState, "systems", gui.Tabs).index = i

	gui.refreshRecursively(guiState, "system")
}



export scheduleSaveWorkspace :: () {
	workspaceSaveScheduled = true
	workspaceSaveDelay     = WORKSPACE_SAVE_DELAY
}



export openProject :: (path:string, asPreview=false) -> (success:bool, project:Project, isNew:bool) {
	local pathObj = Path(path)

	local ok, dir, filename = pathObj.getDirectoryAndFilename!()
	if not ok {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Bad project path '%s'", path)
		return false, NULL, NULL
	}

	path = pathObj.toString!()

	for app.projects  if it.path == path {
		setCurrentProject(itIndex)
		return true, it, false
	}

	if not connectToRemoteDirectory(dir) {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Could not access folder '%s'", dir)
		return false, NULL, NULL
	}
	defer disconnectFromRemoteDirectory()

	addRecent(app.recentFolders, dir, MAX_RECENT_FOLDERS)

	local ^ok, gotError, _app = loadWorkspace(filename)
	if not ok {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Could not load '%s'", filename)
		return false, NULL, NULL
	}

	local project = _app.projects[1]
	if project == NULL {
		if not asPreview  setErrorText("File is missing data")
		return false, NULL, NULL
	}

	addRecent(app.recentFiles, path, MAX_RECENT_FILES)

	project.path          = path
	project.displayedName = filename
	project.fileIsSaved   = true
	project.preview       = asPreview
	insert(app.projects, project)

	updateParticles(project)

	local currentProject = app.projects[app.currentProjectIndex]
	if not (currentProject.edited or currentProject.path) {
		remove(app.projects, app.currentProjectIndex)
	}

	gui.refreshRecursively(guiState, "projects")
	setCurrentProject(#app.projects, force=true)
	scheduleSaveWorkspace()

	return true, project, true
}

export confirmCloseProject :: (projectIndex:int) {
	local closeProject :: (projectIndex:int) {
		local isCurrent  = (projectIndex == app.currentProjectIndex)
		local _, project = remove(app.projects, projectIndex)

		if project.path  addRecent(app.recentFiles, project.path, MAX_RECENT_FILES)

		if app.projects[1] == NULL
			addNewProject()
		elseif projectIndex < app.currentProjectIndex
			app.currentProjectIndex -= 1
		else
			app.currentProjectIndex = math.min(app.currentProjectIndex, #app.projects)

		gui.refreshRecursively(guiState, "projects")
		if isCurrent  setCurrentProject(app.currentProjectIndex, force=true)
		scheduleSaveWorkspace()
	}

	if app.projects[projectIndex].edited {
		local BUTTONS: []gui.Button : {{label="Close"},{label="Cancel"}}

		pushTempChoiceDialog("Confirm close", "The project has unsaved changes. Close it anyway?", BUTTONS, submitIndex=1, [projectIndex] (choice:int) {
			if choice == 1  closeProject(projectIndex)
		})

	} else {
		closeProject(projectIndex)
	}
}



export getGuiValue :: (system:System, name:string) -> (success:bool, value:string) {
	local value = system.gui[name]
	if value == NULL  return false, ""
	return true, value
}

export setGuiValue :: (system:System, name:string, value:string) {
	system.gui[name] = value
	scheduleSaveWorkspace()
}



export getQuadForAnimationPreview :: (ps:LG.ParticleSystem, quads:[]LG.Quad) -> (quad:LG.Quad--[[may be NULL]], progress:float) {
	local min, max = ps.getParticleLifetime!()
	local lifetime = math.max((min + max) / 2, .0001)
	local progress = (LT.getTime() / lifetime) % 1
	local i        = math.clamp(math.floor(1 + progress * #quads), 1, #quads)
	return quads[i], progress
}



export getTextureFullPath :: (project:Project, system:System) -> (success:bool, path:string, isDanglingRelativePath:bool) {
	local path = system.texturePath

	if not path {
		return true, format("%s/gfx/particles/%s.png", getAppDirectory(), system.textureName), false

	} elseif Path(path).isAbsolute {
		if not Path(path).getFilename!()  return false, "", false
		return true, path, false

	} elseif project.fileIsSaved {
		local pathObj = Path(project.path)
		pathObj.pop!() -- @Robustness: Should we check if the path empty after this?
		pathObj.append!(path)
		return true, pathObj.toString!(), false

	} else {
		return false, "", true
	}
}



export markEdited :: (project:Project) {
	if project.edited  return

	project.edited = true
	gui.refreshRecursively(guiState, "projects")

	updateWindowTitle()
}



export updateBufferSize :: (system:System) -> (gotUpdated:bool) {
	local ps                = system.particles
	local bufferSizeCurrent = ps.getBufferSize!()
	local bufferSize        = bufferSizeCurrent
	local optimalBufferSize = getOptimalBufferSize(system)

	while bufferSize < optimalBufferSize  bufferSize *= 2

	if bufferSize == bufferSizeCurrent  return false

	ps.setBufferSize!(bufferSize)
	return true
}

export getOptimalBufferSize :: (system:System, moreExact=false) -> int {
	local ps               = system.particles
	local particleLifetime = math.max(ps.getParticleLifetime!()) -- s
	local emitterLifetime  = ps.getEmitterLifetime!()            -- s
	local rate             = ps.getEmissionRate!()               -- n/s
	local relevantTime     = emitterLifetime < 0 ? particleLifetime : math.min(particleLifetime, emitterLifetime)
	local bufferSize       = math.ceil(system.kickStartEmit + rate * relevantTime * (moreExact ? 1 : 1.05)) -- n/s * s  =  n
	return math.min(bufferSize, MAX_BUFFER_SIZE)
}



export updateWindowTitle :: () {
	local project = app.projects[app.currentProjectIndex]
	love.window.setTitle(format("%s%s - %s", (project.path ?: project.displayedName), (project.edited ? " •" : ""), WINDOW_TITLE))
}



export getCurrentProjectAndSystem :: () -> Project, System {
	local project = app.projects[app.currentProjectIndex]
	local system  = project.systems[project.systemIndex]
	return project, system
}



export getKickStartDt :: (system:System) -> float {
	if not system.kickStartSteps  return 0

	local ps = system.particles
	return (
		math.min(
			ps.getEmitterLifetime!() < 0 ? math.HUGE : ps.getEmitterLifetime!(),
			math.max(ps.getParticleLifetime!())
		)
		/ system.kickStartSteps
	)
}


