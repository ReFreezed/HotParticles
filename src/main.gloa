--[[============================================================
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

local GIF_RECORDING_MODE :: DEV and 1==0
local GIF_FRAME_DELAY    :: 2 -- 100th of a second. (Using 1 here seem troublesome and may make the GIF play very slowly for some reason.)

export APP_VERSION_STRING   :: !run (getReleaseVersion())
export WORKSPACE_SAVE_DELAY :: 1.00
export WINDOW_TITLE         :: !run format("Hot Particles %s%s", APP_VERSION_STRING, (DEV ? " [DEBUG]" : ""))



local isDev :: () -> bool {
	!import "utils"
	return (indexOf(getProgramArguments(), "--dev"))
}
export DEV :: !run isDev()



!preload compiletime [[
	-- For testing:
	_G.love = love or {
		filesystem = {
			getSource              = function()  return require"local.forTests".source               end,
			getSourceBaseDirectory = function()  return require"local.forTests".sourceBaseDirectory  end,
			isFused                = function()  return false                                        end,
		},
	}
]]



export !import "basic"
export !import "color"
export !import "io/path"
export !import "string"

export io     :: !import "io"
export math   :: !import "math"
export os     :: !import "os"
export physfs :: !import "love/physfs"
export utf8   :: !import "utf8"

export love :: !import "love"
export LD :: love.data
export LF :: love.filesystem
export LG :: love.graphics
export LI :: love.image
export LK :: love.keyboard
export LM :: love.mouse
export LT :: love.timer
export LW :: love.window
local  LE :: love.event

export !self
export !load "src/guiSetup"
export !load "src/misc"
export !load "src/workspace"

export gui :: !load "src/gui"

!load "src/shared"



export fontSmall:  LG.Font = NULL
export fontNormal: LG.Font = NULL
export fontLarge:  LG.Font = NULL

export imageBoxGradient: LG.Image = NULL
export imageChecker:     LG.Image = NULL
export imageGradient:    LG.Image = NULL
export imageIcons16:     LG.Image = NULL
export imageNormal:      LG.Image = NULL
export imagePixel:       LG.Image = NULL
export imageRainbow:     LG.Image = NULL

export particleImageNames: []string
export particleImages:     struct { !key:string, !value:ImageAndInfo }
export guiImages:          struct { !key:string, !value:LG.Image }
export dummyCursors:       struct { !key:LM.CursorType, !value:DummyCursor }

export textureBrowserPreviewImage: LG.Image = NULL

export icon16Quads: QuadTable = NULL

local canvasGui:   LG.Canvas = NULL
local canvasWorld: LG.Canvas = NULL

local actionText          = ""
local actionTextTime      = -9999.00
local actionTextDuration :: 0.60
local messageText         = ""
local messageTextTime     = -9999.00
local messageTextDuration = 1.00

export isPositioningParticles = false

export workspaceSaveScheduled = false
export workspaceSaveDelay     = 0.00
export workspaceSaveTime      = -9999.00

export scheduleRecreateCanvases = false

local particleUpdateTime = 0.00
local particleDrawTime   = 0.00
local presentTime        = 0.00

local defaultSearchPaths: []string = NULL

export app: App
export guiState: gui.State

local freezeDtThisFrame = false

local forcePixelatedTextures = false
local forceParticleUpdates   = false

local zoomTime = -9999.00

local updateId = 0

local timeForAnimationPreview   = 0.00
local particleEmitDurationTotal = 0.00

local showParticlePath = 0 -- 0=no, 1=average, 2=range

export isMac: bool
export lctrl: LK.KeyConstant
export rctrl: LK.KeyConstant
export ctrlText: string

export currentCursor = LM.CursorType.ARROW

!if GIF_RECORDING_MODE {
	local gifRecordingActive    = false
	local gifRecordingFrame     = 1
	local gifRecordingName      = ""
	local gifRecordingDirectory = ""

	local VisualMousePress :: struct { x:int, y:int, progress=0.0 }
	local visualMousePresses: []VisualMousePress
}



export QuadTable :: struct { !key:string, !value:LG.Quad }

export DummyCursor :: struct {
	hotX: int,
	hotY: int,
	data: LI.ImageData = NULL,
}



export ImageAndInfo :: struct {
	fullPath: string,
	fileData: LF.FileData = NULL, -- We use FileData instead of ImageData as the latter is problematic when exporting the textures.  @Cleanup: Does this need to be loaded all the time (since we have the path here anyway)?
	image:    LG.Image    = NULL,
	bundled = false,
}



export STATS_NONE  :: 0
export STATS_SOME  :: 1
export STATS_ALL   :: 2
export STATS_COUNT :: 3

export App :: struct {
	-- Saved workspace data:

	projects: []Project,
	currentProjectIndex = 1,

	showStats           = STATS_SOME,
	showProjectSettings = false,
	showPanelNumbers    = true,

	recentFiles:    []string, -- Projects, specifically. @Cleanup
	recentFolders:  []string,
	recentTextures: []string,
	recentShaders:  []string,

	bookmarkedFolders: []string,

	hiddenSections: struct { !key:string, !value:bool } = {scaleGlobalSection=true, scaleAllSection=true, customDataProjectSection=true, customDataSystemSection=true},

	gotWindowInfo   = false, -- Load-time only.
	windowX         = 0,
	windowY         = 0,
	windowWidth     = 0,
	windowHeight    = 0,
	windowMaximized = false,

	maxBufferSize    = 16000, -- Default buffer size for ParticleSystem is 1000.
	maxRecentFiles   = 15,
	maxRecentFolders = 4,
	maxChanges       = 200,
}



export Movement :: enum  { NONE::0, CIRCLE, EIGHT, IRREGULAR }

export Project :: struct {
	-- Saved:
	systems: []System,

	bgColor: []float = {0,0,.15}, -- HSV
	bgChecker = 0.0,
	bgSize    = 8,

	pixelateWorld    = false,
	pixelateTextures = false,

	zoomLevel = 0,

	movementPreset = Movement.NONE,
	movementScaleX = 1.0,
	movementScaleY = 1.0,
	movementSpeed  = 1.0,

	exportBaseDirectory      = "",
	exportParticles          = true,
	exportParticlesOverwrite = false,
	exportParticlesPath      = "",
	exportParticlesTemplate  = "defaultLuaModule",
	exportTextures           = false,
	exportTexturesOverwrite  = false,
	exportTexturesDirectory  = "",
	exportClipboardTemplate  = "defaultLuaClipboard",

	scaleGlobalTime  = 1.0,
	scaleGlobalSpace = 1.0,
	scaleGlobalSize  = 1.0,

	customData = "",

	guiLimits: struct { !key:string, !value:float },

	emitterX: int, -- Load-time only.
	emitterY: int, -- Load-time only.

	edited = false, -- Only saved in workspace.
	path   = "",    -- Only saved in workspace.

	-- Runtime-only:
	systemIndex = 1,

	zoom       = 1.0,
	zoomSource = 1.0,
	zoomTarget = 1.0,

	displayedName = "",
	fileIsSaved   = false, -- Saved at least once (or loaded from a saved file). It's possible that the file physically don't exist (maybe deleted or moved).
	preview       = false,

	movementPhase    = 0.0,
	-- For irregular movement:
	movementPhaseAbs = 0.0,
	movementPoint1X  = 0.0,
	movementPoint1Y  = 0.0,
	movementPoint2X  = 0.0,
	movementPoint2Y  = 0.0,
	movementPoint3X  = 0.0,
	movementPoint3Y  = 0.0,
	movementPoint4X  = 0.0,
	movementPoint4Y  = 0.0,

	particleEmitDuration = 0.00,

	changes: []Change,
	changeIndex = 1, -- Should point at the next slot in 'changes'.

	_init :: (project:Project) {
		static n = 0 ; n += 1
		project.displayedName = format("(untitled %d)", n)
	},

	!call :: () -> Project {
		local project: Project
		_init(project)
		return project
	},

	clone :: (source:Project) -> Project {
		local project: Project = {
			bgColor                  = {source.bgColor[1], source.bgColor[2], source.bgColor[3]},
			bgChecker                = source.bgChecker,
			bgSize                   = source.bgSize,
			pixelateWorld            = source.pixelateWorld,
			pixelateTextures         = source.pixelateTextures,
			zoomLevel                = source.zoomLevel,
			movementPreset           = source.movementPreset,
			movementScaleX           = source.movementScaleX,
			movementScaleY           = source.movementScaleY,
			movementSpeed            = source.movementSpeed,
			exportBaseDirectory      = source.exportBaseDirectory,
			exportParticles          = source.exportParticles,
			exportParticlesOverwrite = source.exportParticlesOverwrite,
			exportParticlesPath      = source.exportParticlesPath,
			exportParticlesTemplate  = source.exportParticlesTemplate,
			exportTextures           = source.exportTextures,
			exportTexturesOverwrite  = source.exportTexturesOverwrite,
			exportTexturesDirectory  = source.exportTexturesDirectory,
			exportClipboardTemplate  = source.exportClipboardTemplate,
			scaleGlobalTime          = source.scaleGlobalTime,
			scaleGlobalSpace         = source.scaleGlobalSpace,
			scaleGlobalSize          = source.scaleGlobalSize,
			customData               = source.customData,
			guiLimits                = copyTable(source.guiLimits),
			edited                   = true,

			zoom       = source.zoom,
			zoomTarget = source.zoomTarget,
		}
		_init(project)

		for source.systems  project.systems[itIndex] = it.clone!()

		updateParticles(project)
		return project
	},
}

export System :: struct {
	-- Saved:
	psDirection                 = 0.0,
	psEmissionAreaDistribution  = LG.AreaSpreadDistribution.NONE,
	psEmissionAreaDx            = 100.0,
	psEmissionAreaDy            = 100.0,
	psEmissionAreaAngle         = 0.0,
	psEmissionAreaRelative      = false,
	psEmissionRate              = 1.0,
	psEmitterContinuous         = true,
	psEmitterLifetime           = 0.0,
	psInsertMode                = LG.ParticleInsertMode.TOP,
	psLinearAccelerationXmin    = 0.0,
	psLinearAccelerationYmin    = 0.0,
	psLinearAccelerationXmax    = 0.0,
	psLinearAccelerationYmax    = 0.0,
	psLinearDampingMin          = 0.0,
	psLinearDampingMax          = 0.0,
	psParticleLifetimeMin       = 1.0,
	psParticleLifetimeMax       = 1.0,
	psRadialAccelerationMin     = 0.0,
	psRadialAccelerationMax     = 0.0,
	psRelativeRotation          = false,
	psRotationMin               = 0.0,
	psRotationMax               = 0.0,
	psSizes: []float            = {1},
	psSizeVariation             = 0.0,
	psSpeedMin                  = 0.0,
	psSpeedMax                  = 0.0,
	psSpinMin                   = 0.0, -- Turns, not angle.
	psSpinMax                   = 0.0, -- Turns, not angle.
	psSpinVariation             = 0.0,
	psSpread                    = 0.0,
	psTangentialAccelerationMin = 0.0,
	psTangentialAccelerationMax = 0.0,

	colors: []float = {0,0,1,1}, -- {h1,s1,v1,a1,...}
	blendMode = LG.BlendMode.ADD,

	texturePath = "",
	textureName = "light", -- Preset fallback to texturePath.
	offsetX     = .5,
	offsetY     = .5,

	shaderPath = "",

	scaleTime  = 1.0,
	scaleSpace = 1.0,
	scaleSize  = 1.0,

	kickStartEmit  = 0,
	kickStartSteps = 0,

	title      = "",
	customData = "",

	frames: []AnimationFrame,

	gui: struct { !key:string, !value:string },

	-- Runtime-only:
	visible = true,

	particles: LG.ParticleSystem = NULL,

	currentImage:  ImageAndInfo = NULL,
	currentShader: LG.Shader    = NULL,

	!call :: () -> System {
		local system: System

		system.currentImage = particleImages.light

		system.particles = LG.newParticleSystem(system.currentImage.image)
		system.particles.stop!() -- Needed for initial kick-start to work.

		return system
	},

	clone :: (source:System) -> System {
		local system: System = {
			psDirection                 = source.psDirection,
			psEmissionAreaDistribution  = source.psEmissionAreaDistribution,
			psEmissionAreaDx            = source.psEmissionAreaDx,
			psEmissionAreaDy            = source.psEmissionAreaDy,
			psEmissionAreaAngle         = source.psEmissionAreaAngle,
			psEmissionAreaRelative      = source.psEmissionAreaRelative,
			psEmissionRate              = source.psEmissionRate,
			psEmitterContinuous         = source.psEmitterContinuous,
			psEmitterLifetime           = source.psEmitterLifetime,
			psInsertMode                = source.psInsertMode,
			psLinearAccelerationXmin    = source.psLinearAccelerationXmin,
			psLinearAccelerationYmin    = source.psLinearAccelerationYmin,
			psLinearAccelerationXmax    = source.psLinearAccelerationXmax,
			psLinearAccelerationYmax    = source.psLinearAccelerationYmax,
			psLinearDampingMin          = source.psLinearDampingMin,
			psLinearDampingMax          = source.psLinearDampingMax,
			psParticleLifetimeMin       = source.psParticleLifetimeMin,
			psParticleLifetimeMax       = source.psParticleLifetimeMax,
			psRadialAccelerationMin     = source.psRadialAccelerationMin,
			psRadialAccelerationMax     = source.psRadialAccelerationMax,
			psRelativeRotation          = source.psRelativeRotation,
			psRotationMin               = source.psRotationMin,
			psRotationMax               = source.psRotationMax,
			psSizes                     = {unpack(source.psSizes)},
			psSizeVariation             = source.psSizeVariation,
			psSpeedMin                  = source.psSpeedMin,
			psSpeedMax                  = source.psSpeedMax,
			psSpinMin                   = source.psSpinMin,
			psSpinMax                   = source.psSpinMax,
			psSpinVariation             = source.psSpinVariation,
			psSpread                    = source.psSpread,
			psTangentialAccelerationMin = source.psTangentialAccelerationMin,
			psTangentialAccelerationMax = source.psTangentialAccelerationMax,
			colors                      = {unpack(source.colors)},
			blendMode                   = source.blendMode,
			texturePath                 = source.texturePath,
			textureName                 = source.textureName,
			offsetX                     = source.offsetX,
			offsetY                     = source.offsetY,
			shaderPath                  = source.shaderPath,
			scaleTime                   = source.scaleTime,
			scaleSpace                  = source.scaleSpace,
			scaleSize                   = source.scaleSize,
			kickStartEmit               = source.kickStartEmit,
			kickStartSteps              = source.kickStartSteps,
			title                       = source.title,
			customData                  = source.customData,
			gui                         = copyTable(source.gui),

			particles    = source.particles.clone!(),
			currentImage = source.currentImage,
		}

		for source.frames {
			system.frames[itIndex] = {x=it.x, y=it.y, w=it.w, h=it.h}
		}

		system.particles.stop!()
		return system
	},
}

export AnimationFrame :: struct { x=0.0, y=0.0, w=0.0, h=0.0 }

export Change :: struct {
	bundle:   int,
	label:    string,
	onDo:     (project:Project) = NULL,
	onUndo:   (project:Project) = NULL,
	finalize: (project:Project) = NULL,
}



export updateParticles :: (project:Project) {
	for project.systems  updateParticles(project, it)
}
export updateParticles :: (project:Project, system:System) {
	updateParticleParams(project, system)
	updateParticleColors(system)
	updateParticleTexture(project, system)
	updateParticleShader(project, system)
}

export updateParticleParams :: (project:Project, s:System) {
	local ps = s.particles

	local time  = s.scaleTime  * project.scaleGlobalTime
	local space = s.scaleSpace * project.scaleGlobalSpace
	local size  = s.scaleSize  * project.scaleGlobalSize

	local sizes: []float
	for s.psSizes  insert(sizes, it*size)

	ps.setDirection!(s.psDirection)
	ps.setEmissionArea!(s.psEmissionAreaDistribution, s.psEmissionAreaDx*space, s.psEmissionAreaDy*space, s.psEmissionAreaAngle, s.psEmissionAreaRelative)
	ps.setEmissionRate!(s.psEmissionRate*time)
	ps.setEmitterLifetime!(s.psEmitterContinuous ? -1 : s.psEmitterLifetime/time)
	ps.setInsertMode!(s.psInsertMode)
	ps.setLinearAcceleration!(s.psLinearAccelerationXmin*space*time^2, s.psLinearAccelerationYmin*space*time^2, s.psLinearAccelerationXmax*space*time^2, s.psLinearAccelerationYmax*space*time^2)
	ps.setLinearDamping!(s.psLinearDampingMin*time, s.psLinearDampingMax*time)
	ps.setParticleLifetime!(s.psParticleLifetimeMin/time, s.psParticleLifetimeMax/time)
	ps.setRadialAcceleration!(s.psRadialAccelerationMin*space*time^2, s.psRadialAccelerationMax*space*time^2)
	ps.setRelativeRotation!(s.psRelativeRotation)
	ps.setRotation!(s.psRotationMin, s.psRotationMax)
	ps.setSizes!(sizes)
	ps.setSizeVariation!(s.psSizeVariation)
	ps.setSpeed!(s.psSpeedMin*space*time, s.psSpeedMax*space*time)
	ps.setSpin!(s.psSpinMin*time*math.TAU, s.psSpinMax*time*math.TAU)
	ps.setSpinVariation!(s.psSpinVariation)
	ps.setSpread!(s.psSpread)
	ps.setTangentialAcceleration!(s.psTangentialAccelerationMin*space*time^2, s.psTangentialAccelerationMax*space*time^2)
}

export updateParticleColors :: (system:System) {
	local colors = system.colors
	local colorsRgba: []float

	for i = 1, #colors, 4 {
		local r, g, b = hsvToRgb(colors[i], colors[i+1], colors[i+2])
		insert(colorsRgba, r)
		insert(colorsRgba, g)
		insert(colorsRgba, b)
		insert(colorsRgba, colors[i+3])
	}

	system.particles.setColors!(colorsRgba)
}

export updateParticleTextures :: (project:Project) {
	for project.systems  updateParticleTexture(project, it)
}

export updateParticleTexture :: (project:Project, system:System, saveRecent=false) -> (loadedCustomTexture:bool) {
	local loadParticleTexture :: (project:Project, system:System, saveRecent:bool) -> ImageAndInfo {
		local ok, path, isDangling = getTextureFullPath(project, system)
		if not ok {
			if isDangling
				setErrorText("Relative paths require the project to be saved: %s", path)
			else
				setErrorText("Bad texture path '%s'", path)
			return NULL
		}

		local ^ok, dir, filename = Path(path).getDirectoryAndFilename!()
		assert(ok)

		if not connectToRemoteDirectory(dir) {
			setErrorText("Could not access folder '%s'", dir)
			return NULL
		}
		defer disconnectFromRemoteDirectory()

		local imageData, err = LF.newFileData(filename)

		if imageData == NULL {
			setErrorText(err)
			return NULL
		}

		if saveRecent  addRecent(app.recentTextures, system.texturePath, app.maxRecentFiles)
		-- if saveRecent  addRecent(app.recentTextures, path, app.maxRecentFiles)

		local image, ^err = pcall_newImage(filename)
		if image == NULL {
			log(err)
			setErrorText("Could not load texture '%s'", filename)
			return NULL
		}

		return {fullPath=path, fileData=cast(LF.FileData)imageData, image=image}
	}

	local imageAndInfo: ImageAndInfo = NULL
	local loadedCustomTexture        = true

	if system.texturePath  imageAndInfo = loadParticleTexture(project, system, saveRecent) -- @Speed: Don't reload the texture if there's no change.

	if imageAndInfo == NULL {
		imageAndInfo        = particleImages[system.textureName]
		loadedCustomTexture = false
	}

	system.currentImage = imageAndInfo

	system.particles.setTexture!(imageAndInfo.image)
	updateParticleAnimation(system)

	local filter = project.pixelateTextures ? LG.FilterMode.NEAREST : .LINEAR
	imageAndInfo.image.setFilter!(filter, filter)

	return loadedCustomTexture
}

export updateParticleShader :: (project:Project, system:System, saveRecent=false) {
	local loadParticleShader :: (project:Project, system:System, saveRecent:bool) -> LG.Shader {
		local ok, path, isDangling = getShaderFullPath(project, system)
		if not ok {
			if isDangling
				setErrorText("Relative paths require the project to be saved: %s", path)
			else
				setErrorText("Bad shader path '%s'", path)
			return NULL
		}

		local ^ok, dir, filename = Path(path).getDirectoryAndFilename!()
		assert(ok)

		if not connectToRemoteDirectory(dir) {
			setErrorText("Could not access folder '%s'", dir)
			return NULL
		}
		defer disconnectFromRemoteDirectory()

		if saveRecent  addRecent(app.recentShaders, system.shaderPath, app.maxRecentFiles)
		-- if saveRecent  addRecent(app.recentShaders, path, app.maxRecentFiles)

		local shaderCode: string = NULL
		do {
			local _shaderCode, err = LF.read(filename)
			if _shaderCode == nil {
				setErrorText("Could not read '%s': %s", filename, err)
				return NULL
			}
			shaderCode = cast(string) _shaderCode
		}

		-- Note: wrap_GraphicsShader.lua in LÖVE is used as reference for some things here.

		local versionLine = ""
		if findPattern(shaderCode, "^#pragma language %w") {
			local _, _versionLine, _shaderCode = matchPattern(shaderCode, "^([^\n]+\n?)(.*)")
			versionLine = cast(string) _versionLine
			shaderCode  = cast(string) _shaderCode
		}

		shaderCode =
			versionLine.."\z
			#define HOT_PARTICLES\n\z
			uniform float hotParticlesTime;\n\z
			uniform float hotParticlesEmitterTime;\n\z
			"..shaderCode

		local shader, err = pcall_newShader(shaderCode)
		if shader == NULL {
			log(err) -- @Incomplete: Fix line numbers.
			setErrorText("Could not load shader '%s' (see File > Log)", filename)
			return NULL
		}

		return shader
	}

	local shader: LG.Shader = NULL

	if system.shaderPath  shader = loadParticleShader(project, system, saveRecent) -- @Speed: Don't reload the shader if there's no change.

	system.currentShader = shader
}

export updateParticleAnimation :: (system:System) {
	if system.frames {
		local iw, ih = system.currentImage.image.getDimensions!()
		local quads: []LG.Quad

		for system.frames {
			insert(quads, LG.newQuad(it.x, it.y, it.w, it.h, iw, ih))
		}

		system.particles.setQuads!(quads)

	} else {
		system.particles.setQuads!()
	}

	updateParticleTextureOffset(system)
}

export updateParticleTextureOffset :: (system:System) {
	if system.frames {
		local animFrame1 = system.frames[1]
		system.particles.setOffset!(animFrame1.w*system.offsetX, animFrame1.h*system.offsetY)
	} else {
		local iw, ih = system.currentImage.image.getDimensions!()
		system.particles.setOffset!(iw*system.offsetX, ih*system.offsetY)
	}
}



export updateParticleImageFilters :: () {
	local project = app.projects[app.currentProjectIndex]
	local filter  = (project.pixelateTextures or forcePixelatedTextures) ? LG.FilterMode.NEAREST : .LINEAR

	for particleImageNames {
		particleImages[it].image.setFilter!(filter, filter)
	}

	local system = project.systems[project.systemIndex]
	system.currentImage.image.setFilter!(filter, filter) -- In case this is a custom texture.
}



export newSystem :: (project:Project, showcase=false) -> System {
	local system = System()

	if showcase {
		system.psDirection           = -math.TAU/4
		system.psEmissionRate        = 20
		system.psParticleLifetimeMin = 1.8
		system.psParticleLifetimeMax = 2.2
		system.psSpeedMin            = 90
		system.psSpeedMax            = 100
		system.psSpread              = .05*math.TAU
		system.colors                = {0,0,1,0, 0,0,1,1, 0,0,1,.5, 0,0,1,0}
		system.psSizes               = {.4}
	}
	updateParticleParams(project, system)
	updateParticleColors(system)

	if project.systems[1] ~= NULL {
		local x, y = project.systems[1].particles.getPosition!()
		system.particles.setPosition!(x, y)
	}

	return system
}

export addNewSystem :: (project:Project, showcase=false) {
	insert(project.systems, newSystem(project, showcase))
}

export addNewProject :: () -> Project {
	local project = Project()
	insert(app.projects, project)

	addNewSystem(project, showcase=true)

	return project
}



export createCanvases :: () {
	local ww, wh = LG.getDimensions()

	if canvasGui ~= NULL {
		canvasGui  .release!()
		canvasWorld.release!()
	}

	local SETTINGS: LG.CanvasSettings : {msaa=2^2}
	canvasGui   = LG.newCanvas(ww, wh, SETTINGS)
	canvasWorld = LG.newCanvas(math.max(ww-MAIN_PANEL_WIDTH, 1), wh)

	if app.projects[app.currentProjectIndex].pixelateWorld {
		canvasWorld.setFilter!(.NEAREST, .NEAREST)
	}

	scheduleRecreateCanvases = false
}



export moveEmittersTo :: (x,y:float) {
	for app.projects[app.currentProjectIndex].systems  it.particles.moveTo!(x, y)
}



export pushQuitEvent :: () {
	saveWorkspace()
	LE.quit(0)
}



export connectToRemoteDirectory :: (dir:string) -> (success:bool) {
	if not physfs.setWriteDirectory(dir)  return false

	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it))

	assert(physfs.mountReadDirectory(dir)) -- If we can write then we should be able to read too.
	return true
}

export disconnectFromRemoteDirectory :: () {
	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it),     it)
	for defaultSearchPaths       assert(physfs.mountReadDirectory(it, true), it)

	assert(physfs.setWriteDirectory(getSaveDirectory()))
}



export setActionText :: (s:string, clearMessage=true) {
	actionText     = s
	actionTextTime = LT.getTime()
	if clearMessage  messageText = ""
}
export setActionText :: (s:string, v,...:int|float|string) {
	setActionText(format(s, v, ...))
}

export setMessageText :: (s:string) {
	if messageText ~= s  log(s)

	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 3.00
}
export setMessageText :: (s:string, v,...:int|float|string) {
	setMessageText(format(s, v, ...))
}

export setErrorText :: (s:string) {
	s = "Error: "..s
	if messageText ~= s  log(s)

	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 8.00
}
export setErrorText :: (s:string, v,...:int|float|string) {
	setErrorText(format(s, v, ...))
}



local onRun :: () -> (mainLoop:()->int|none) {
	local LOVE: struct { !key:string, !value:(...:love.Variant) } : !foreign lua "love"

	local argsRaw = !import"utils".getCommandLineArguments()
	LOVE.load(love.arg.parseGameArguments(argsRaw), argsRaw)

	LT.step()
	local dt = .0

	return [dt] () -> int|none {
		LE.pump()
		for name, a,b,c,d,e,f in LE.poll() {
			if name == .QUIT {
				-- if not (cast(()->bool)cast(any)LOVE.quit)() { -- We don't currently have a 'quit' handler.
					return a == NULL ? 0 : cast(int)a
				-- }
			}
			local HANDLERS: struct { !key:LE.Event, !value:(...:love.Variant) } : !foreign lua "love.handlers"
			HANDLERS[name](a,b,c,d,e,f)
		}

		dt = LT.step()
		LOVE.update(dt)

		if LG.isActive()  LOVE.draw()

		LT.sleep(0.001)
		return nil
	}
}



local onLoad :: (args:[]string, argsRaw:[]string) {
	io.disableBuffering(io.STDOUT)
	io.disableBuffering(io.STDERR)

	print("Running Hot Particles")
	LW.setTitle(WINDOW_TITLE)

	fontSmall  = LG.newFont(10)
	fontNormal = LG.newFont(12)
	fontLarge  = LG.newFont(16)

	do {
		local TEXT :: "Loading..."
		LG.clear(1, 1, 1, 1)
		LG.setFont(fontLarge)
		LG.setColor(0, 0, 0)
		LG.print(TEXT, (LG.getWidth()-fontLarge.getWidth!(TEXT))//2, (LG.getHeight()-fontLarge.getHeight!())//2)
		LG.present()
		LG.reset()
		-- LT.sleep(1) -- DEBUG
	}

	isMac    = love.system.getOS() == "OS X"
	lctrl    = isMac ? "lgui" : "lctrl"
	rctrl    = isMac ? "rgui" : "rctrl"
	ctrlText = isMac ? "Cmd"  : "Ctrl"

	local projectsToOpen: []string

	for args {
		if not findPattern(it, "^%-") {
			insert(projectsToOpen, it)

		} elseif it == "--help" or it == "-help" or it == "-?" or it == "/help" or it == "/?" {
			print("Argument synopsis:  HotParticles.exe [fileToOpen1 fileToOpen2 ...]")

		} else {
			printf("Unknown option '%s'.", it)
		}
	}

	LK.setKeyRepeat(true)

	LF.createDirectory("projects") -- Must happen before physfs stuff so the save folder exists.

	defaultSearchPaths = physfs.getSearchPaths()
	!if not DEV  insert(defaultSearchPaths, getAppDirectory())
	disconnectFromRemoteDirectory() -- Resets paths. We didn't actually connect.

	dummyCursors[.ARROW]         = {hotX=2, hotY=2,  data=LI.newImageData("gfx/cursor_arrow.png")}
	dummyCursors[.I_BEAM]        = {hotX=4, hotY=9,  data=LI.newImageData("gfx/cursor_ibeam.png")}
	dummyCursors[.SIZE_VERTICAL] = {hotX=6, hotY=12, data=LI.newImageData("gfx/cursor_sizens.png")}

	imageBoxGradient = LG.newImage("gfx/boxGradient.png")
	imageChecker     = LG.newImage("gfx/checker.png") ; imageChecker.setWrap!(.REPEAT, .REPEAT) ; imageChecker.setFilter!(.NEAREST, .NEAREST)
	imageGradient    = LG.newImage("gfx/gradient.png")
	imageIcons16     = LG.newImage("gfx/icons.png")
	imageNormal      = LG.newImage("gfx/normal.png")
	imagePixel       = LG.newImage("gfx/pixel.png")
	imageRainbow     = LG.newImage("gfx/rainbow.png")

	!load "src/icons"
	generateIcons()

	for LF.getDirectoryItems"gfx/particles" {
		local found, name = matchPattern(it, "^(.+)%.png$")

		if found {
			local path      = "gfx/particles/"..it
			local imageData = LF.newFileData(path)
			local image     = LG.newImage(path)

			particleImages[cast(string)name] = {
				fullPath = format("%s/%s", getAppDirectory(), path),
				fileData = imageData,
				image    = image,
				bundled  = true,
			}

			guiImages[cast(string)name] = image

			insert(particleImageNames, cast(string)name)

			--[[ Black/white to transparent/white.
			local img = LI.newImageData(path)
			img.mapPixel!((x,y:int, r,g,b,a:float) -> (r,g,b,a:float) {
				return 1, 1, 1, r
			})
			img.encode!(LI.ImageFormat.PNG, it)
			--]]
		}
	}

	do {
		local ok, gotError, _app = loadWorkspace("workspace")
		if ok {
			app = _app
			assert(app.projects[1] ~= NULL)
		} else {
			if gotError  setErrorText("Could not load previous workspace")
			addNewProject()
		}

		for app.projects  updateParticles(it)

		local w = app.windowWidth  ?: 1400
		local h = app.windowHeight ?: 800

		local _, _, flags = LW.getMode()
		flags.resizable   = true
		local maximized   = false

		if ok and app.gotWindowInfo {
			flags.x   = app.windowX      ?: cast(int) flags.x
			flags.y   = app.windowY      ?: cast(int) flags.y
			w         = app.windowWidth  ?: w
			h         = app.windowHeight ?: h
			maximized = app.windowMaximized

			flags.centered = not (app.windowX or app.windowY)
			if flags.centered {
				flags.x = nil
				flags.y = nil
			}

		} else {
			flags.x        = nil
			flags.y        = nil
			flags.centered = true
		}

		!if GIF_RECORDING_MODE {
			w              = 1000
			h              = 500
			flags.x        = nil
			flags.y        = nil
			flags.centered = true
			maximized      = false
		}

		app.windowWidth  = w
		app.windowHeight = h

		LW.updateMode(w, h, flags)
		if maximized  LW.maximize()
	}

	LW.setVSync(app.showStats == STATS_ALL ? 0 : 1)

	setupGuiFrames()
	setupGuiCallbacks()
	guiState.refreshAll!()

	setCurrentProject(app.currentProjectIndex, force=true)

	for projectsToOpen {
		local ok, project, isNew = openProject(it)
		if ok and not isNew  updateParticles(project)
	}
}



local onFileDropped :: (file:LF.DroppedFile) {
	local path   = Path(file.getFilename!()).toString!()
	local _, ext = matchPattern(path, "%.(%w+)$")

	if ext == "hotparticles" {
		openProject(path)
		return
	}

	if pcall_newImage(file) == NULL {
		setErrorText("Could not load '%s'", path)
		return
	}

	local project, system = getCurrentProjectAndSystem()
	setTexturePath(project, system, path)
}



local onKeyPressed :: (key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) {
	local mod       = getModifierKey()
	local modAndKey = combineKeyAndModifier(mod, key)
	local project   = app.projects[app.currentProjectIndex]
	local system    = project.systems[project.systemIndex]

	-- Global keys.
	if not LM.isGrabbed()  if modAndKey == {
		case "c-q":
			pushQuitEvent()
			return

		case "c-f10":
			saveWorkspace()
			LE.restart()
			return

		case "f1":
			app.showStats = (app.showStats + 1) % STATS_COUNT
			LW.setVSync(app.showStats == STATS_ALL ? 0 : 1)
			scheduleSaveWorkspace()
			return

		case "f2":
			app.showPanelNumbers = not app.showPanelNumbers
			scheduleSaveWorkspace()
			return

		case "f8":
			!if GIF_RECORDING_MODE {
				gifRecordingActive = not gifRecordingActive
				log("Recording gif: %s", toString(gifRecordingActive))

				if gifRecordingActive {
					gifRecordingFrame     = 1
					gifRecordingName      = os.getDate("%Y%m%d_%H%M%S")
					gifRecordingDirectory = "gif_"..gifRecordingName
					LF.createDirectory(gifRecordingDirectory)

				} else {
					log("Recorded frames: %d", gifRecordingFrame-1)

					local ok, err, code, cmd = os.execute(loadParams().pathMagick, {
						"convert",
						"-delay", format("%d", GIF_FRAME_DELAY), -- 100th of a second.
						format("%s/%s/frame*.png", getSaveDirectory(), gifRecordingDirectory),
						"-coalesce",    -- Fill out frames.
						"-deconstruct", -- Find areas changed between frames.
						"-loop", "0",   -- Loop forever.
						format("%s/screenshots/%s.gif", getSaveDirectory(), gifRecordingName),
					})
					if ok  print(cmd)

					if not ok {
						setErrorText("Failed executing '%s': %s", cmd, err)
					} elseif code ~= 0 {
						setErrorText("Failed making gif (Error %d)", code)
					} else {
						local path = format("%s/%s", getSaveDirectory(), gifRecordingDirectory)
						print("Gif: "..path)
						-- love.system.openURL("file://"..path)
					}
				}
			}
			return

		case "f12": !through
		case "s-f12":
			!if DEV  LG.captureScreenshot([mod] (screenshot:LI.ImageData) {
				if mod == ModifierKey.S  overlayDummyCursor(screenshot)
				LF.createDirectory("screenshots")
				screenshot.encode!(LI.ImageFormat.PNG, os.getDate("screenshots/%Y%m%d_%H%M%S.png"))
			})
			return

		case "c-s-f12":
			!if DEV  love.system.openURL(format("file://%s/screenshots", getSaveDirectory()))
			return
	}

	if guiState.onKeyPressed!(key, scancode, isRepeat)  return
	if LM.isGrabbed()  return

	-- Context-sensitive global keys.
	if key == "escape" {
		if popPanel()  return

		local BUTTONS: []gui.Button : {{label="Exit"},{label="Cancel"}}

		pushTempChoiceDialog("", "", BUTTONS, submitIndex=1, (i:int) {
			if i == 1  pushQuitEvent()
		})

		return
	}

	if modAndKey == {
		case "r":
			for project.systems {
				it.particles.stop!()
				it.particles.reset!()
			}
			return

		case "p":
			showParticlePath = (showParticlePath + 1) % 3
			setMessageText(
				showParticlePath == 0 ? "Hide particle path" :
				showParticlePath == 1 ? "Show particle path (average)" :
				showParticlePath == 2 ? "Show particle path (random)" :
				""
			)
			return

		case "space":
			for project.systems {
				local ps     = it.particles
				local active = ps.isActive!()
				if not active  ps.start!() -- Needed for emit() to work.
				ps.emit!(1)
				if not active  ps.stop!()
			}
			return

		case "c-s-o":
			local ok, dir = Path(app.projects[app.currentProjectIndex].path).getDirectory!()
			if ok  love.system.openURL("file://"..dir)
			return
	}

	if panelStack  return

	-- Keys in normal view.
	if modAndKey == {
		case "c-s":      if project.fileIsSaved  saveProject(project, project.path, overwrite=true)  else  showSaveProjectAsDialog()
		case "c-s-s":    showSaveProjectAsDialog()
		case "c-e":      pushPanel("exportProject")
		case "c-o":      showOpenProjectDialog()
		case "c-s-t":    openRecentProject()
		case "c-n":      addNewProject() ; guiState.refreshRecursively!("projects") ; setCurrentProject(#app.projects) ; scheduleSaveWorkspace()
		case "c-w":      if not (#app.projects == 1 and not (app.projects[1].path or app.projects[1].edited))  confirmCloseProject(app.currentProjectIndex)

		case "tab":      setCurrentSystem ((project.systemIndex     - 0) % #project.systems + 1)
		case "s-tab":    setCurrentSystem ((project.systemIndex     - 2) % #project.systems + 1)
		case "c-tab":    setCurrentProject((app.currentProjectIndex - 0) % #app.projects    + 1)
		case "c-s-tab":  setCurrentProject((app.currentProjectIndex - 2) % #app.projects    + 1)

		case "h":        system.visible = not system.visible

		case "c-p":      !if DEV  guiState.setActive!("main", not guiState.getElement!("main").active)

		case "c-delete": confirmDeleteSystem(project.systemIndex)
		case "c-d":      duplicateSystem(project.systemIndex)

		case "c-z":      undo()
		case "c-s-z":    redo()

		case "c-k":      pushPanel("preferences")

		case "f10":      showMainMenu()
	}
}

local onKeyReleased :: (key:LK.KeyConstant, scancode:LK.Scancode) {
	guiState.onKeyReleased!(key, scancode)
}

local onTextInput :: (text:string) {
	if guiState.onTextInput!(text)  return
}

local macCtrlClick = false

local onMousePressed :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch         return
	if LM.isGrabbed()  return

	!if GIF_RECORDING_MODE  if gifRecordingActive {
		insert(visualMousePresses, cast(VisualMousePress) {x=mx, y=my})
	}

	-- @Cleanup: Make sure this is actually needed:
	if isMac and mbutton == 1 and LK.isDown("lctrl", "rctrl") {
		if LM.isDown(2)  return -- Make sure the user can't control-click while already right-clicking as those methods should result in the same action. :MacRightClick
		mbutton      = 2
		macCtrlClick = true
	} elseif macCtrlClick and mbutton == 2 {
		return -- :MacRightClick
	}

	if guiState.onMousePressed!(mx, my, mbutton, presses)  return

	local showWorld = getVisibilityFlags()
	if not showWorld  return

	if mbutton == 1 {
		isPositioningParticles = true
		LM.setGrabbed(true)
		LK.setKeyRepeat(false)
		onMouseMoved(mx,my, 0,0, false)
	}
}

local onMouseMoved :: (mx,my:int, dx,dy:int, isTouch:bool) {
	if isTouch  return

	if isPositioningParticles {
		local project = app.projects[app.currentProjectIndex]

		local x = (mx - (LG.getWidth()+MAIN_PANEL_WIDTH)/2) / project.zoom
		local y = (my - (LG.getHeight()                )/2) / project.zoom

		moveEmittersTo(x, y)
		return
	}

	guiState.onMouseMoved!(mx, my, dx, dy)
}

local onMouseReleased :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch  return

	if macCtrlClick and mbutton == 1 {
		mbutton      = 2
		macCtrlClick = false
	}

	if isPositioningParticles and mbutton == 1 {
		isPositioningParticles = false
		LM.setGrabbed(false)
		LK.setKeyRepeat(true)
		guiState.onMouseMoved!(mx, my, 0, 0)
		return
	}

	guiState.onMouseReleased!(mx, my, mbutton, presses)
}

local onMouseWheel :: (dx,dy:int) {
	if LM.isGrabbed()                  return
	if guiState.onMouseWheel!(dx, dy)  return
	if not dy                          return

	local showWorld = getVisibilityFlags()
	if not showWorld  return

	local mx, my = LM.getPosition()
	if guiState.getTopmostActiveModal!() ~= NULL or guiState.isOverGui!(mx, my)  return

	local mod = getModifierKey()
	if mod ~= .NONE  return

	local project   = app.projects[app.currentProjectIndex]
	local zoomLevel = project.zoomLevel
	local now       = LT.getTime()

	for 1, math.abs(dy) {
		-- Stick slightly to 100% zoom.
		if zoomLevel == 0 and now-zoomTime < 0.15  break

		zoomLevel = clampZoomLevel(project, zoomLevel+math.getSign(dy))
	}

	zoomTime = now

	if zoomLevel == project.zoomLevel  return

	project.zoomLevel = zoomLevel
	limitZoomLevel(project)

	setActionText("Zoom: %d%%", project.zoomTarget * 100)
}



local onUpdate :: (dt:float) {
	updateId += 1

	!if GIF_RECORDING_MODE  if gifRecordingActive  dt = GIF_FRAME_DELAY / 100

	if freezeDtThisFrame {
		dt                = 0
		freezeDtThisFrame = false
	} else {
		local _, _, flags = LW.getMode()
		-- This will make things go *really* slow if it's the performance that's
		-- making dt high. It's probably not that much of an issue though.
		if flags.refreshrate and dt > 1/10  dt = 1/flags.refreshrate
	}

	local mod  = getModifierKey()
	local slow = not guiState.focusId and mod == .NONE and LK.isDown"g"
	local fast = not guiState.focusId and mod == .NONE and LK.isDown"f"

	local dtForParticles      = dt / (slow ? 20 : 1)
	local particleUpdateCount = fast ? 10 : 1

	timeForAnimationPreview += particleUpdateCount * dtForParticles

	local project           = app.projects[app.currentProjectIndex]
	local showWorld         = getVisibilityFlags()
	local doUpdateParticles = showWorld and (forceParticleUpdates or guiState.getTopmostActiveModal!() == NULL)

	if doUpdateParticles {
		local systemsActive  = false

		local time = LT.getTime()
		for project.systems  it.particles.update!(dtForParticles)
		particleUpdateTime = LT.getTime()-time

		project.particleEmitDuration += dtForParticles
		particleEmitDurationTotal    += dtForParticles

		for 2, particleUpdateCount {
			project.particleEmitDuration += dtForParticles
			for project.systems  it.particles.update!(dtForParticles)
		}

		for system: project.systems {
			local ps      = system.particles
			systemsActive = systemsActive or ps.isActive!() or ps.getCount!() > 0

			if ps.getCount!() > 0.95 * ps.getBufferSize!() {
				if updateBufferSize(system)  setActionText("Increased buffer size")
			}
		}

		if systemsActive {
			-- Make sure continuous emitters are always active.
			for system: project.systems {
				if system.psEmitterContinuous  system.particles.start!()
			}

		} else {
			project.particleEmitDuration = 0

			for system: project.systems {
				system.particles.start!()

				-- Note: Kick-starting may make things look a bit weird if the
				-- emitter has a too short lifetime compared to the particles.
				if system.kickStartSteps {
					local kickStartDt = getKickStartDt(system)
					for i = 1, system.kickStartSteps  system.particles.update!(kickStartDt)
				}

				system.particles.emit!(system.kickStartEmit)
			}
		}
	}

	if workspaceSaveScheduled {
		workspaceSaveDelay -= dt
		if workspaceSaveDelay <= 0  saveWorkspace()
	}

	if scheduleRecreateCanvases  createCanvases()

	if doUpdateParticles and not isPositioningParticles {
		local MOVEMENT_BASE :: 250

		-- project.movementSpeed = LK.isDown"." ? .04 : 1 -- DEBUG

		local lastMovementPhaseAbs  = project.movementPhaseAbs
		project.movementPhase      +=         (project.movementSpeed) * dt
		project.movementPhaseAbs   += math.abs(project.movementSpeed) * dt

		using project.movementPreset
		if !complete project.movementPreset == {
			case NONE:
				-- void

			case CIRCLE:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE * project.movementScaleY * math.sin(angle)
				)

			case EIGHT:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE   * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE/2 * project.movementScaleY * math.sin(angle*2)
				)

			case IRREGULAR:
				if math.floor(project.movementPhaseAbs) ~= math.floor(lastMovementPhaseAbs) or lastMovementPhaseAbs == 0 {
					local dx       = project.movementPoint3X - project.movementPoint4X
					local dy       = project.movementPoint3Y - project.movementPoint4Y
					local angleOld = math.atan(-dy, -dx)

					project.movementPoint1X = project.movementPoint4X
					project.movementPoint1Y = project.movementPoint4Y
					project.movementPoint2X = project.movementPoint4X - dx
					project.movementPoint2Y = project.movementPoint4Y - dy
					project.movementPoint4X = .8*MOVEMENT_BASE * (2*love.math.random()-1)
					project.movementPoint4Y = .8*MOVEMENT_BASE * (2*love.math.random()-1)

					dx             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					dy             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					local angleNew = math.atan(dy, dx)

					if math.angleDistance(angleNew, angleOld) > math.TAU/4 {
						dx = -dx
						dy = -dy
					}

					project.movementPoint3X = project.movementPoint4X + dx
					project.movementPoint3Y = project.movementPoint4Y + dy
				}

				local phase    = project.movementPhaseAbs % 1
				local phaseOld =     math.sin  (phase * math.TAU/4)
				local phaseNew = 1 - math.cos  (phase * math.TAU/4)
				local phaseMid = 1 - math.cos01(phase * math.TAU/2)

				moveEmittersTo(
					project.movementScaleX * math.lerp(
						math.lerp(project.movementPoint1X, project.movementPoint2X, phaseOld),
						math.lerp(project.movementPoint3X, project.movementPoint4X, phaseNew),
						phaseMid
					),
					project.movementScaleY * math.lerp(
						math.lerp(project.movementPoint1Y, project.movementPoint2Y, phaseOld),
						math.lerp(project.movementPoint3Y, project.movementPoint4Y, phaseNew),
						phaseMid
					)
				)
		}
	}

	project.zoom = math.moveTowards(
		project.zoom,
		project.zoomTarget,
		math.abs(project.zoomTarget - project.zoomSource) * dt / 0.05
	)

	guiState.update!(dt)

	!if GIF_RECORDING_MODE  for < visualMousePresses {
		it.progress += dt/.20
		if it.progress >= 1  remove(visualMousePresses, itIndex)
	}
}



local getVisibilityFlags :: () -> bool, bool, bool, bool, bool {
	static wasHoveringTextureOffset    = false
	static wasHoveringAreaDistribution = false
	static hoverTimeTextureOffset      = -9999.00
	static hoverTimeAreaDistribution   = -9999.00

	local isHoveringTextureOffset
		=  math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("textureOffsetX").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("textureOffsetY").id

	local isHoveringAreaDistribution
		=  math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("areaDistribution").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("areaDx").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("areaDy").id

	if isHoveringTextureOffset ~= wasHoveringTextureOffset {
		wasHoveringTextureOffset = isHoveringTextureOffset
		hoverTimeTextureOffset   = LT.getTime()
	}
	if isHoveringAreaDistribution ~= wasHoveringAreaDistribution {
		wasHoveringAreaDistribution = isHoveringAreaDistribution
		hoverTimeAreaDistribution   = LT.getTime()
	}

	local DELAY :: 4/60
	local showTextureOffset    = (isHoveringTextureOffset    and LT.getTime() - hoverTimeTextureOffset    > DELAY)
	local showAreaDistribution = (isHoveringAreaDistribution and LT.getTime() - hoverTimeAreaDistribution > DELAY)
	local showAnimationFrames  = guiState.getElement!("animation").active
	local showTexturePreview   = textureBrowserPreviewImage ~= NULL
	local showWorld            = not (showTextureOffset or showAnimationFrames or showTexturePreview)

	static didShowWorld = true

	if showWorld ~= didShowWorld {
		didShowWorld           = showWorld
		forcePixelatedTextures = not showWorld -- A bit misplaced... @Cleanup
		updateParticleImageFilters()
	}

	return showWorld, showTextureOffset, showAreaDistribution, showAnimationFrames, showTexturePreview
}

local onDraw :: () {
	static statsAll:   LG.Stats
	static statsWorld: LG.Stats

	local ww, wh  = LG.getDimensions()
	local project = app.projects[app.currentProjectIndex]

	local showWorld, showTextureOffset, showAreaDistribution, showAnimationFrames, showTexturePreview = getVisibilityFlags()

	LG.reset()

	-- World.
	do {
		LG.setCanvas(canvasWorld)

		local r, g, b = hsvToRgb(project.bgColor)
		LG.clear(r, g, b)

		if math.abs(project.bgChecker) > .9/255 {
			if project.bgChecker > 0
				LG.setColor(1, 1, 1, project.bgChecker)
			else
				LG.setColor(0, 0, 0, -project.bgChecker)
			gui.drawChecker(0, 0, ww, wh, project.bgSize/4)
		}

		if showWorld {
			LG.translate((ww-MAIN_PANEL_WIDTH)/2, wh/2)
			if not project.pixelateWorld  LG.scale(project.zoom)

			local time = LT.getTime()

			LG.setColor(1, 1, 1)
			for system: project.systems  if system.visible {
				local shader = system.currentShader
				if shader ~= NULL {
					if shader.hasUniform!"hotParticlesTime"         shader.send!("hotParticlesTime",        particleEmitDurationTotal)
					if shader.hasUniform!"hotParticlesEmitterTime"  shader.send!("hotParticlesEmitterTime", project.particleEmitDuration)
				}
				LG.setShader(shader)
				LG.setBlendMode(system.blendMode)
				LG.draw(system.particles)
			}

			particleDrawTime = LT.getTime()-time -- Not sure how accurate this actually is. This value is still very low even while the actual FPS is tanking a lot.
			-- !if DEV  LG.getStats(statsWorld)

			LG.setShader()
			LG.setBlendMode(.ALPHA)

			if showAreaDistribution {
				local system = project.systems[project.systemIndex]
				local x,  y  = system.particles.getPosition!()
				local dx     = system.psEmissionAreaDx * system.scaleSpace
				local dy     = system.psEmissionAreaDy * system.scaleSpace

				using system.psEmissionAreaDistribution

				LG.setColor(1, 0, 0, .6)
				LG.setLineWidth(math.max(8/project.zoom, (project.pixelateWorld ? 1 : 0)))

				if !complete system.psEmissionAreaDistribution == {
					case NONE:
						-- void

					case ELLIPSE:
						LG.ellipse(LG.DrawMode.FILL, x,y, dx,dy, 64)

					case UNIFORM:
						LG.rectangle(LG.DrawMode.FILL, x-dx,y-dy, 2*dx, 2*dy)

					case BORDER_ELLIPSE:
						LG.ellipse(LG.DrawMode.LINE, x,y, dx,dy, 64)

					case BORDER_RECTANGLE:
						LG.rectangle(LG.DrawMode.LINE, x-dx,y-dy, 2*dx,2*dy)

					case NORMAL:
						local STDDEV_IN_IMAGE :: .1411132813
						local iw, ih = imageNormal.getDimensions!()
						local sx     = dx / (iw * STDDEV_IN_IMAGE)
						local sy     = dy / (ih * STDDEV_IN_IMAGE)
						LG.draw(imageNormal, x,y, 0, sx,sy, iw/2,ih/2)
				}

				LG.setLineWidth(1)
			}

			if showParticlePath {
				local MAX_SEGMENTS       :: 1000
				local RANDOM_LINES       :: 8
				local RATE_WHEN_NO_VSYNC :: 250

				local system = project.systems[project.systemIndex]
				local ps     = system.particles

				local direction0 = ps.getDirection!()
				local spread     = ps.getSpread!()

				local accRadialMin,  accRadialMax  = ps.getRadialAcceleration!()
				local accTangentMin, accTangentMax = ps.getTangentialAcceleration!()
				local dampMin,       dampMax       = ps.getLinearDamping!()
				local lifeMin,       lifeMax       = ps.getParticleLifetime!()
				local speedMin,      speedMax      = ps.getSpeed!()

				local accXmin, accYmin, accXmax, accYmax = ps.getLinearAcceleration!()

				-- local distribution, dx, dy, angle, relative = ps.getEmissionArea!() -- @Incomplete: Use distribution for initial coords.

				local _, _, flags = LW.getMode()

				LG.setColor(.3, .3, 1)

				for 1, (showParticlePath == 1 ? 1 : RANDOM_LINES) {
					local accRadial, accTangent, accX, accY, damp, life, speed, direction: float = NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL

					if showParticlePath == 1 {
						accRadial  = (accRadialMin  + accRadialMax ) / 2
						accTangent = (accTangentMin + accTangentMax) / 2
						accX       = (accXmin       + accXmax      ) / 2
						accY       = (accYmin       + accYmax      ) / 2
						damp       = (dampMin       + dampMax      ) / 2
						life       = (lifeMin       + lifeMax      ) / 2
						speed      = (speedMin      + speedMax     ) / 2
						direction  = direction0
					} else {
						accRadial  = math.getRandom(accRadialMin,  accRadialMax)
						accTangent = math.getRandom(accTangentMin, accTangentMax)
						accX       = math.getRandom(accXmin,       accXmax)
						accY       = math.getRandom(accYmin,       accYmax)
						damp       = math.getRandom(dampMin,       dampMax)
						life       = math.getRandom(lifeMin,       lifeMax)
						speed      = math.getRandom(speedMin,      speedMax)
						direction  = direction0 + spread * math.getRandom(-.5, +.5)
					}

					local dt
						= app.showStats == STATS_ALL
						? 1 / RATE_WHEN_NO_VSYNC
						: 1 / (flags.refreshrate ?: 60)

					local segments = math.round(life / dt)

					segments = math.clamp(segments, 2, MAX_SEGMENTS)
					dt       = life / segments

					local x0, y0 = ps.getPosition!()
					local points = {x0, y0}

					local x      = x0
					local y      = y0
					local speedX = speed * math.cos(direction)
					local speedY = speed * math.sin(direction)

					for 1, segments {
						-- @Accuracy: This all seem to break to some extent for extreme values (at least for damping).
						local prevSpeedX = speedX
						local prevSpeedY = speedY

						speedX, speedY = math.damp(speedX,speedY, 0,0, damp, dt)

						x += (prevSpeedX+speedX)/2 * dt
						y += (prevSpeedY+speedY)/2 * dt

						local originAngle = math.atan(y-y0, x-x0)

						speedX += dt * accX
						speedY += dt * accY
						speedX += dt * accRadial  * math.cos(originAngle)
						speedY += dt * accRadial  * math.sin(originAngle)
						speedX += dt * accTangent * math.cos(originAngle + math.TAU/4)
						speedY += dt * accTangent * math.sin(originAngle + math.TAU/4)

						insert(points, x)
						insert(points, y)
					}

					LG.line(points)
					-- LG.points(points) -- DEBUG
				}
			}

			--[[ DEBUG
			LG.setColor(1, 1, 1, .15)
			LG.line(project.movementPoint1X, project.movementPoint1Y, project.movementPoint2X, project.movementPoint2Y)
			LG.line(project.movementPoint2X, project.movementPoint2Y, project.movementPoint3X, project.movementPoint3Y)
			LG.line(project.movementPoint3X, project.movementPoint3Y, project.movementPoint4X, project.movementPoint4Y)
			LG.setColor(1, 1, 1, .3)
			LG.print("1", project.movementPoint1X, project.movementPoint1Y)
			LG.print("2", project.movementPoint2X, project.movementPoint2Y)
			LG.print("3", project.movementPoint3X, project.movementPoint3Y)
			LG.print("4", project.movementPoint4X, project.movementPoint4Y)
			--]]

			LG.reset()
		}
	}

	-- GUI.
	do {
		LG.setCanvas(canvasGui)
		LG.clear()

		LG.setFont(fontNormal)

		-- Texture or animation frames.
		if showTextureOffset or showAnimationFrames or showTexturePreview {
			local PADDING :: 20

			local system = project.systems[project.systemIndex]
			local image  = showTexturePreview ? textureBrowserPreviewImage : system.currentImage.image
			local iw, ih = image.getDimensions!()

			local scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/iw, (wh-2*PADDING)/ih)

			local x0 = (ww - iw*scale + MAIN_PANEL_WIDTH) // 2
			local y0 = (wh - ih*scale                   ) // 2

			if showTextureOffset or showTexturePreview {
				local w = iw
				local h = ih

				if showTextureOffset and system.frames {
					local quads        = system.particles.getQuads!()
					local quad         = getAnimationPreviewQuad(system.particles, quads)
					local _, _, qw, qh = quads[1].getViewport!()

					w = math.round(qw)
					h = math.round(qh)

					scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/w, (wh-2*PADDING)/h)

					x0 = (ww - w*scale + MAIN_PANEL_WIDTH) // 2
					y0 = (wh - h*scale                   ) // 2

					LG.setColor(1, 1, 1)
					LG.draw(image, quad, x0, y0, 0, scale)

				} else {
					LG.setColor(1, 1, 1)
					LG.draw(image, x0, y0, 0, scale)
				}

				if showTextureOffset {
					local HALF_WIDTH  :: 3
					local HALF_LENGTH :: 20
					local x = math.round(x0 + w*scale*system.offsetX)
					local y = math.round(y0 + h*scale*system.offsetY)
					LG.setColor(0, 0, 0, .9)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH-1, y-HALF_LENGTH-1, 2*HALF_WIDTH+2, 2*HALF_LENGTH+2)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH-1, y-HALF_WIDTH-1, 2*HALF_LENGTH+2, 2*HALF_WIDTH+2)
					LG.setColor(1, 1, 1)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH, y-HALF_LENGTH, 2*HALF_WIDTH, 2*HALF_LENGTH)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH, y-HALF_WIDTH, 2*HALF_LENGTH, 2*HALF_WIDTH)
				}
			}

			if showAnimationFrames {
				LG.setColor(1, 1, 1)
				LG.draw(image, x0, y0, 0, scale)

				if system.frames {
					local drawFrame :: (x0,y0:int, scale:float, frame:AnimationFrame) {
						local x1 = math.round(x0 + scale * (frame.x          ))
						local y1 = math.round(y0 + scale * (frame.y          ))
						local x2 = math.round(x0 + scale * (frame.x + frame.w))
						local y2 = math.round(y0 + scale * (frame.y + frame.h))
						LG.rectangle(LG.DrawMode.LINE, x1+.5, y1+.5, x2-x1-1, y2-y1-1)
					}

					LG.setColor(0, 1, 0)
					for system.frames  drawFrame(x0,y0, scale, it)

					local frameIndex = getAnimationPreviewProgress(system.particles, #system.frames)
					LG.setColor(1, 1, 1)
					drawFrame(x0,y0, scale, system.frames[frameIndex])

					local occupiedCoords: Table(int, bool)

					for system.frames {
						local text = format("%d", itIndex)
						local x    = math.round(x0 + scale * it.x) + 2
						local y    = math.round(y0 + scale * it.y)

						while occupiedCoords[y*iw+x]  y += fontNormal.getHeight!()
						occupiedCoords[y*iw+x] = true

						LG.setColor(0, 0, 0)
						LG.print(text, x+1, y+1)

						if itIndex == frameIndex
							LG.setColor(1, 1, 1)
						else
							LG.setColor(0, 1, 0)
						LG.print(text, x, y)
					}
				}

				local mx, my = LM.getPosition()

				if LW.hasMouseFocus() and not (guiState.activeId or guiState.isOverGui!(mx, my)) {
					local text = format(
						"[%d, %d]",
						math.clamp(math.floor((mx-x0)/scale), 0, iw),
						math.clamp(math.floor((my-y0)/scale), 0, ih)
					)
					local x = math.min(mx, ww-fontNormal.getWidth!(text)-2)
					local y = my+20
					if y+fontNormal.getHeight!() > wh-2  y = my-10-fontNormal.getHeight!()
					LG.setColor(0, 0, 0)
					LG.print(text, x+1, y+1)
					LG.setColor(1, 1, 1)
					LG.print(text, x, y)
				}
			}
		}

		-- Stats.
		if app.showStats {
			local particleCountTotal        = 0
			local particleCountTotalOptimal = 0
			for project.systems {
				particleCountTotal        += it.particles.getCount!()
				particleCountTotalOptimal += getOptimalBufferSize(it, moreExact=true)
			}

			local fontH = fontNormal.getHeight!()

			local x = MAIN_PANEL_WIDTH+5
			local y = 5

			local r, g, b          = hsvToRgb(project.bgColor)
			local _, _, brightness = rgbToHsp(r, g, b)
			if brightness < .5
				LG.setColor(1, 1, 1, .7)
			else
				LG.setColor(0, 0, 0, .7)

			local drawStatsLine = [x,y,fontH] (pre:string, s:string, ...:int|float|string) {
				LG.print(pre, x, y)
				if s  LG.print(format(s, ...), x+fontNormal.getWidth!(pre), y)
				y += fontH+1
			}

			drawStatsLine("FPS: ", "%d%s", LT.getFPS(), (app.showStats == STATS_ALL ? "" : " (vsync)"))

			if app.showStats == STATS_ALL {
				local _, _, flags = LW.getMode()
				local ratio       = 1 / presentTime / flags.refreshrate

				if not flags.refreshrate {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms", 1000*presentTime)
				} elseif ratio >= 10 {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.0f.0 x framerate)", 1000*presentTime, ratio)
				} elseif ratio >= 2 {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.1f0 x framerate)",  1000*presentTime, ratio)
				} else {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.2f x framerate)",   1000*presentTime, ratio)
				}

				drawStatsLine("ParticleSystemUpdateTime: ", "%.3f ms",  1000*particleUpdateTime)
				drawStatsLine("ParticleSystemDrawTime: ",   "%.3f ms",  1000*particleDrawTime)
			}

			drawStatsLine("ParticleCountTotal: ", "%d/%d", particleCountTotal, particleCountTotalOptimal)

			if #project.systems > 1  for project.systems {
				local bufferSize = it.particles.getBufferSize!()
				drawStatsLine(
					"ParticleCount_",
					"%d: %d/%d (%d%s)",
					itIndex,
					it.particles.getCount!(),
					getOptimalBufferSize(it, moreExact=true),
					bufferSize,
					(bufferSize >= app.maxBufferSize ? " MAX" : "")
				)
			}

			drawStatsLine("EmitterTime: ", "%.3f sec", project.particleEmitDuration)

			!if DEV {
				local stats = statsAll
				if app.showStats == STATS_ALL and stats ~= NULL {
					y += 5
					drawStatsLine("drawcalls (batched): ",    "%d (%d)",  stats.drawcalls, stats.drawcallsbatched)
					drawStatsLine("switches canvas/shader: ", "%d/%d",    stats.canvasswitches, stats.shaderswitches)
					drawStatsLine("texture memory: ",         "%.2f MiB", stats.texturememory/1024^2)
					drawStatsLine("images/fonts/canvases: ",  "%d/%d/%d", stats.images, stats.fonts, stats.canvases)
				}
				if app.showStats == STATS_SOME {
					y += 5
					drawStatsLine("(hide with F1)", "")
				}
			} else {
				y += 5
				drawStatsLine("(hide with F1)", "")
			}
		}

		-- Panel(s).
		guiState.draw!()

		-- GUI texts.
		local drawGuiText :: (text:string, time:float, duration:float, y:int) {
			local PADDING_X :: 20
			local PADDING_Y :: 8

			local visibility = 1 - (LT.getTime() - time) / duration
			if visibility <= 0  return

			local anyModalVisible = (guiState.getTopmostActiveModal!() ~= NULL)

			local w = fontLarge.getWidth!(text)
			local x = (LG.getWidth() + (anyModalVisible ? 0 : MAIN_PANEL_WIDTH) - w) // 2
			local a = visibility ^ .5

			if anyModalVisible {
				if findPattern(text, "^Error: ")
					LG.setColor(.4, 0, 0, a)
				else
					LG.setColor(0, 0, 0, a)
				LG.rectangle(LG.DrawMode.FILL, x-PADDING_X, y-PADDING_Y, w+2*PADDING_X, fontLarge.getHeight!()+2*PADDING_Y, 3)

			} else {
				LG.setColor(0, 0, 0, a)
				LG.print(text, x+1, y+1)
			}

			LG.setColor(1, 1, 1, a)
			LG.print(text, x, y)
		}

		local anyInfiniteEmitter = false
		local anyFiniteEmitter   = false

		for project.systems {
			if it.particles.getEmitterLifetime!() < 0
				anyInfiniteEmitter = true
			else
				anyFiniteEmitter   = true
		}

		LG.origin()
		LG.setFont(fontLarge)

		local dist = fontLarge.getHeight!() + 5

		if project.preview {
			drawGuiText("PREVIEW", 0, math.HUGE, 10)
		}
		if anyFiniteEmitter and anyInfiniteEmitter {
			drawGuiText("Warning: Mixing infinite and finite emitters", 0, math.HUGE, 10+1*dist)
		}
		drawGuiText(messageText, messageTextTime, messageTextDuration, 10+2*dist)
		drawGuiText(actionText,  actionTextTime,  actionTextDuration,  10+3*dist)

		-- Dev/debug stuff.
		!if DEV {
			local showSaveIndicator = true
			!if GIF_RECORDING_MODE  showSaveIndicator = not gifRecordingActive

			if showSaveIndicator {
				local visibility = 1 - (LT.getTime() - workspaceSaveTime) / 0.40
				if visibility > 0 {
					LG.setColor(1, 1, 1, .4*visibility^.5)
					LG.circle(LG.DrawMode.FILL, ww-10, 10, 4, 8)
				}
			}

			-- LG.setColor(1, 1, 1)
			-- LG.print(format("%d", LT.getFPS()))
		}

		--[[ Mouse stuff.
		local mx, my = LM.getPosition()
		if isPositioningParticles {
			LG.setColor(1, 0, 0)
			LG.line(mx-50, my, mx+50, my)
			LG.line(mx, my-50, mx, my+50)
		}
		--]]

		!if GIF_RECORDING_MODE {
			LG.setLineWidth(2)
			LG.setColor(1, 1, 1)
			for visualMousePresses  LG.circle(LG.DrawMode.LINE, it.x, it.y, math.lerp(2, 22, it.progress), 32)
			LG.setLineWidth(1)
		}

		LG.reset()
	}

	-- Put stuff on the screen!
	LG.clear(0, 0, 0, 1)
	LG.setBlendMode(LG.BlendMode.ALPHA, LG.BlendAlphaMode.PREMULTIPLIED)

	if project.pixelateWorld {
		LG.draw(canvasWorld, (ww+MAIN_PANEL_WIDTH)/2,wh/2, 0, project.zoom,project.zoom, (ww-MAIN_PANEL_WIDTH)/2, wh/2)
	} else {
		LG.draw(canvasWorld, MAIN_PANEL_WIDTH,0)
	}

	LG.draw(canvasGui)

	!if DEV  LG.getStats(statsAll)

	!if GIF_RECORDING_MODE  if gifRecordingActive {
		LG.captureScreenshot((screenshot:LI.ImageData) {
			if gifRecordingFrame % 10 == 0  printf("Frame %d (%.2f sec)", gifRecordingFrame, gifRecordingFrame*GIF_FRAME_DELAY/100)

			overlayDummyCursor(screenshot)

			local path = format("%s/frame%04d.png", gifRecordingDirectory, gifRecordingFrame)
			screenshot.encode!(LI.ImageFormat.PNG, path)

			gifRecordingFrame += 1
		})
	}

	local time = LT.getTime()
	LG.present()
	presentTime = LT.getTime()-time
}

local overlayDummyCursor :: (screenshot:LI.ImageData) {
	if not LW.hasMouseFocus()  return

	local dummyCursor = dummyCursors[currentCursor]
	local cursorData  = dummyCursor.data
	local mx, my      = LM.getPosition()
	local w,  h       = cursorData.getDimensions!()

	local screenshotW, screenshotH = screenshot.getDimensions!()

	local x1 = mx - dummyCursor.hotX
	local y1 = my - dummyCursor.hotY
	local x2 = x1 + w - 1
	local y2 = y1 + h - 1

	local mapX1 = math.max(x1, 0)
	local mapY1 = math.max(y1, 0)
	local mapX2 = math.min(x2, screenshotW-w)
	local mapY2 = math.min(y2, screenshotH-h)

	screenshot.mapPixel!(mapX1, mapY1, mapX2-mapX1+1, mapY2-mapY1+1, [cursorData, x1, y1] (x,y:int, r,g,b,a:float) -> (r,g,b,a:float) {
		local r2, g2, b2, a2 = cursorData.getPixel!(x-x1, y-y1)
		return
			math.lerp(r, r2, a2),
			math.lerp(g, g2, a2),
			math.lerp(b, b2, a2),
			1 - (1-a) * (1-a2)
	})
}



local onResize :: (ww,wh:int) {
	createCanvases()
	guiState.layoutNeedsUpdate = true
	freezeDtThisFrame          = true -- Fixes things jumping forward like crazy (in Windows at least).

	local maximized = LW.isMaximized()

	if not maximized {
		local w, h, flags = LW.getMode()
		app.windowX       = cast(int) flags.x
		app.windowY       = cast(int) flags.y
		app.windowWidth   = w
		app.windowHeight  = h
	}
	app.windowMaximized = maximized

	scheduleSaveWorkspace()
}



local onFocus :: (hasFocus:bool) {
	guiState.onFocus!(hasFocus)
}



local main :: () {
	!import "utils"
	local LOVE: table : !foreign lua "love"

	LOVE.run           = wrapFunctionInGloaErrorHandler(onRun)
	LOVE.load          = wrapFunctionInGloaErrorHandler(onLoad)
	LOVE.filedropped   = wrapFunctionInGloaErrorHandler(onFileDropped)
	LOVE.keypressed    = wrapFunctionInGloaErrorHandler(onKeyPressed)
	LOVE.keyreleased   = wrapFunctionInGloaErrorHandler(onKeyReleased)
	LOVE.textinput     = wrapFunctionInGloaErrorHandler(onTextInput)
	LOVE.mousepressed  = wrapFunctionInGloaErrorHandler(onMousePressed)
	LOVE.mousemoved    = wrapFunctionInGloaErrorHandler(onMouseMoved)
	LOVE.mousereleased = wrapFunctionInGloaErrorHandler(onMouseReleased)
	LOVE.wheelmoved    = wrapFunctionInGloaErrorHandler(onMouseWheel)
	LOVE.update        = wrapFunctionInGloaErrorHandler(onUpdate)
	LOVE.draw          = wrapFunctionInGloaErrorHandler(onDraw)
	LOVE.resize        = wrapFunctionInGloaErrorHandler(onResize)
	LOVE.focus         = wrapFunctionInGloaErrorHandler(onFocus)
	LOVE.errorhandler  = nil
	LOVE.errhand       = nil
}



export setCurrentProject :: (i:int, force=false) {
	if app.currentProjectIndex == i and not force  return

	app.currentProjectIndex = i
	guiState.getElement!("projects", gui.Tabs).index = i

	guiState.refreshRecursively!("projectSettings")
	guiState.refreshRecursively!("systems")
	guiState.refreshRecursively!("undoRedoText")

	scheduleRecreateCanvases = true
	updateParticleImageFilters()

	setCurrentSystem(app.projects[i].systemIndex, force=true)

	updateWindowTitle()
}

export setCurrentSystem :: (i:int, force=true) {
	local project = app.projects[app.currentProjectIndex]
	if project.systemIndex == i and not force  return

	project.systemIndex = i
	guiState.getElement!("systems", gui.Tabs).index = i

	guiState.refreshRecursively!("system")
}

export isSystemCurrent :: (system:System) -> bool {
	local project = app.projects[app.currentProjectIndex]
	return system == project.systems[project.systemIndex]
}



export scheduleSaveWorkspace :: () {
	workspaceSaveScheduled = true
	workspaceSaveDelay     = WORKSPACE_SAVE_DELAY
}



export openProject :: (path:string, asPreview=false) -> (success:bool, project:Project, isNew:bool) {
	local pathObj = Path(path)
	path          = pathObj.toString!()

	local ok, dir, filename = pathObj.getDirectoryAndFilename!()
	if not ok {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Bad project path '%s'", path)
		return false, NULL, NULL
	}

	for app.projects  if it.path == path {
		setCurrentProject(itIndex)
		if not asPreview  addRecent(app.recentFiles, path, app.maxRecentFiles)
		return true, it, false
	}

	if not connectToRemoteDirectory(dir) {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Could not access folder '%s'", dir)
		return false, NULL, NULL
	}
	defer disconnectFromRemoteDirectory()

	if not asPreview  addRecent(app.recentFolders, dir, app.maxRecentFolders)

	local ^ok, gotError, _app = loadWorkspace(filename)
	if not ok {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Could not load '%s'", filename)
		return false, NULL, NULL
	}

	local project = _app.projects[1]
	if project == NULL {
		if not asPreview  setErrorText("File is missing data")
		return false, NULL, NULL
	}

	if not asPreview  addRecent(app.recentFiles, path, app.maxRecentFiles)

	project.path          = path
	project.displayedName = filename
	project.fileIsSaved   = true
	project.preview       = asPreview
	insert(app.projects, project)

	updateParticles(project)

	local currentProject = app.projects[app.currentProjectIndex]
	if not asPreview and isProjectEmpty(currentProject) {
		remove(app.projects, app.currentProjectIndex)
	}

	guiState.refreshRecursively!("projects")
	setCurrentProject(#app.projects, force=true)
	scheduleSaveWorkspace()

	return true, project, true
}

export openRecentProject :: () {
	for app.recentFiles  if not indexWith(app.projects, "path", it) {
		openProject(it)
		break
	}
}

export confirmCloseProject :: (projectIndex:int) {
	local closeProject :: (projectIndex:int) {
		local isCurrent  = (projectIndex == app.currentProjectIndex)
		local _, project = remove(app.projects, projectIndex)

		if project.path  addRecent(app.recentFiles, project.path, app.maxRecentFiles)

		if app.projects[1] == NULL
			addNewProject()
		elseif projectIndex < app.currentProjectIndex
			app.currentProjectIndex -= 1
		else
			app.currentProjectIndex = math.min(app.currentProjectIndex, #app.projects)

		guiState.refreshRecursively!("projects")
		if isCurrent  setCurrentProject(app.currentProjectIndex, force=true)
		scheduleSaveWorkspace()
	}

	if app.projects[projectIndex].edited {
		local BUTTONS: []gui.Button : {{label="Close"},{label="Cancel"}}

		pushTempChoiceDialog("Confirm close", "The project has unsaved changes. Close it anyway?", BUTTONS, submitIndex=1, [projectIndex] (choice:int) {
			if choice == 1  closeProject(projectIndex)
		})

	} else {
		closeProject(projectIndex)
	}
}



export confirmDeleteSystem :: (systemIndexToDelete:int) {
	-- @UX: Don't confirm if the system has no modifications.
	local BUTTONS: []gui.Button : {{label="Delete"},{label="Cancel"}}

	local psCanvas = guiState.canvas!({ name="temp_deleteSystemPreview", width=DIALOG_WIDTH-40, height=200 })

	guiState.onDraw.temp_deleteSystemPreview = [systemIndexToDelete] (canvasEl:gui.Canvas, cw,ch:int) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[systemIndexToDelete]
		local scale   = ch / LG.getHeight() * project.zoom
		local r, g, b = hsvToRgb(project.bgColor)
		local emitterX, emitterY: float

		if project.movementPreset == .NONE {
			emitterX, emitterY = system.particles.getPosition!()
		}

		LG.setColor(1, 1, 1)

		LG.clear(r, g, b)
		LG.setShader(system.currentShader)
		LG.setBlendMode(system.blendMode)

		LG.draw(system.particles,
			cw/2 - emitterX*scale,
			ch/2 - emitterY*scale,
			0, scale
		)

		LG.setShader()
		LG.setBlendMode(.ALPHA)
	}

	forceParticleUpdates = true

	pushTempChoiceDialog("Confirm delete", "Delete this particle system?", BUTTONS, submitIndex=1, extraContent=psCanvas, [systemIndexToDelete] (choice:int) {
		guiState.onDraw.temp_deleteSystemPreview = nil
		forceParticleUpdates                     = false

		if choice ~= 1  return

		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[systemIndexToDelete]

		if #project.systems == 1 {
			local emptySystem = newSystem(project)
			recordChange("Delete particle system",
				[emptySystem] (project:Project) {  project.systems[1] = emptySystem  },
				[system     ] (project:Project) {  project.systems[1] = system       },
				--[[       ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(1, force=true)  }
			)
		} else {
			recordChange("Delete particle system",
				[systemIndexToDelete        ] (project:Project) {  remove(project.systems, systemIndexToDelete) ; project.systemIndex = math.min(project.systemIndex, #project.systems)  },
				[systemIndexToDelete, system] (project:Project) {  insert(project.systems, systemIndexToDelete, system)  },
				--[[                       ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(project.systemIndex, force=true)  }
			)
		}
	})
}

export duplicateSystem :: (systemIndex:int) {
	local project = app.projects[app.currentProjectIndex]
	local system  = project.systems[systemIndex].clone!()

	recordChange("Duplicate particle system",
		[systemIndex, system] (project:Project) {  insert(project.systems, systemIndex+1, system) ; project.systemIndex = systemIndex+1  },
		[systemIndex        ] (project:Project) {  remove(project.systems, systemIndex+1)         ; project.systemIndex = math.min(project.systemIndex, #project.systems)  },
		--[[               ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(project.systemIndex, force=true)  }
	)
}



export getGuiValue :: (system:System, name:string) -> (success:bool, value:string) {
	local value = system.gui[name]
	if value == NULL  return false, ""
	return true, value
}

export setGuiValue :: (system:System, name:string, value:string) {
	system.gui[name] = value
	scheduleSaveWorkspace()
}



export getAnimationPreviewProgress :: (ps:LG.ParticleSystem, frameCount:int) -> (i:int, progress:float, progressInSeconds:float) {
	local min, max = ps.getParticleLifetime!()
	local lifetime = math.max((min + max) / 2, .0001) -- Use average lifetime.
	local progress = (timeForAnimationPreview / lifetime) % 1
	local i        = math.clamp(math.floor(1 + progress * frameCount), 1, frameCount)
	return i, progress, lifetime*progress
}

export getAnimationPreviewQuad :: (ps:LG.ParticleSystem, quads:[]LG.Quad) -> (quad:LG.Quad--[[may be NULL]], progress:float, progressInSeconds:float) {
	local i, progress, progressInSeconds = getAnimationPreviewProgress(ps, #quads)
	return quads[i], progress, progressInSeconds
}



export getTextureFullPath :: (project:Project, system:System) -> (success:bool, path:string, isDanglingRelativePath:bool) {
	local path = system.texturePath

	if not path {
		return true, particleImages[system.textureName].fullPath, false

	} elseif Path(path).isAbsolute {
		if not Path(path).getFilename!()  return false, "", false
		return true, path, false

	} elseif project.fileIsSaved {
		local pathObj = Path(project.path)
		pathObj.pop!() -- @Robustness: Should we check if the path empty after this?
		pathObj.append!(path)
		return true, pathObj.toString!(), false

	} else {
		return false, path, true
	}
}

export setTexturePath :: (project:Project, system:System, pathNew:string) {
	local pathOld = system.texturePath
	if pathNew == pathOld  return

	local saveRecent = true

	recordChange("Texture path",
		[system, pathNew            ] (project:Project) {  system.texturePath = pathNew  },
		[system, pathOld, saveRecent] (project:Project) {  system.texturePath = pathOld ; saveRecent = false  },
		[system,          saveRecent] (project:Project) {  updateParticleTexture(project, system, saveRecent) ; saveRecent = false ; guiState.refreshRecursively!("texturePath")  }
	)
}



export getShaderFullPath :: (project:Project, system:System) -> (success:bool, path:string, isDanglingRelativePath:bool) {
	local path = system.shaderPath

	if not path {
		return false, "", false

	} elseif Path(path).isAbsolute {
		if not Path(path).getFilename!()  return false, "", false
		return true, path, false

	} elseif project.fileIsSaved {
		local pathObj = Path(project.path)
		pathObj.pop!() -- @Robustness: Should we check if the path empty after this?
		pathObj.append!(path)
		return true, pathObj.toString!(), false

	} else {
		return false, path, true
	}
}

export setShaderPath :: (project:Project, system:System, pathNew:string) {
	local pathOld = system.shaderPath
	if pathNew == pathOld  return

	local saveRecent = true

	recordChange("Shader path",
		[system, pathNew            ] (project:Project) {  system.shaderPath = pathNew  },
		[system, pathOld, saveRecent] (project:Project) {  system.shaderPath = pathOld ; saveRecent = false  },
		[system,          saveRecent] (project:Project) {  updateParticleShader(project, system, saveRecent) ; saveRecent = false ; guiState.refreshRecursively!("shaderPath")  }
	)
}



export markEdited :: (project:Project) {
	if project.edited  return

	project.edited = true

	guiState.refreshRecursively!("projects")
	updateWindowTitle()
}



export updateBufferSize :: (system:System) -> (gotUpdated:bool) {
	local ps                = system.particles
	local bufferSizeCurrent = ps.getBufferSize!()
	local bufferSize        = math.min(bufferSizeCurrent, app.maxBufferSize)
	local optimalBufferSize = getOptimalBufferSize(system)

	while bufferSize < optimalBufferSize  bufferSize *= 2

	if bufferSize == bufferSizeCurrent  return false

	ps.setBufferSize!(bufferSize)
	return true
}

export getOptimalBufferSize :: (system:System, moreExact=false) -> int {
	local ps               = system.particles
	local particleLifetime = math.max(ps.getParticleLifetime!()) -- s
	local emitterLifetime  = ps.getEmitterLifetime!()            -- s
	local rate             = ps.getEmissionRate!()               -- n/s
	local relevantTime     = emitterLifetime < 0 ? particleLifetime : math.min(particleLifetime, emitterLifetime)
	local bufferSize       = math.ceil(system.kickStartEmit + rate * relevantTime * (moreExact ? 1 : 1.05)) -- n/s * s  =  n
	return math.min(bufferSize, app.maxBufferSize)
}



export updateWindowTitle :: () {
	local project = app.projects[app.currentProjectIndex]
	LW.setTitle(format("%s%s - %s", (project.path ?: project.displayedName), (project.edited ? " •" : ""), WINDOW_TITLE))
}



export getCurrentProjectAndSystem :: () -> Project, System {
	local project = app.projects[app.currentProjectIndex]
	local system  = project.systems[project.systemIndex]
	return project, system
}



export getKickStartDt :: (system:System) -> float {
	if not system.kickStartSteps  return 0

	local ps = system.particles
	return (
		math.min(
			ps.getEmitterLifetime!() < 0 ? math.HUGE : ps.getEmitterLifetime!(),
			math.max(ps.getParticleLifetime!())
		)
		/ system.kickStartSteps
	)
}



export isProjectEmpty :: (project:Project) -> bool {
	return not (project.edited or project.path)
}



export recordChange :: (label:string, onDo:(project:Project), onUndo:(project:Project), finalize:(project:Project)=NULL--[[, trigger=true]]) -> Change {
	-- @Polish: Reset project.edited if all changes since the last save has been undone/redone.
	local project = app.projects[app.currentProjectIndex]

	-- Discard undone changes.
	for project.changeIndex, #project.changes  project.changes[it] = NULL

	while project.changes[app.maxChanges] ~= NULL  remove(project.changes, 1) -- This may remove more than one if app.maxChanges changed.

	local change: Change = {
		bundle   = updateId,
		label    = label,
		onDo     = onDo,
		onUndo   = onUndo,
		finalize = finalize,
	}
	insert(project.changes, change)
	project.changeIndex = #project.changes + 1

	-- if trigger {
		onDo(project)
		if finalize ~= NULL  finalize(project)
	-- }

	markEdited(project)
	guiState.refreshRecursively!("undoRedoText")
	scheduleSaveWorkspace()

	return change
}

export undo :: () {
	local project = app.projects[app.currentProjectIndex]
	if project.changeIndex == 1  return

	project.changeIndex -= 1

	local change = project.changes[project.changeIndex]
	local bundle = change.bundle
	local labels: []string
	local labelsAdded: struct { !key:string, !value:bool }

	while true {
		if not labelsAdded[change.label] {
			labelsAdded[change.label] = true
			insert(labels, change.label)
		}
		change.onUndo(project)
		if change.finalize ~= NULL  change.finalize(project)

		change = project.changes[project.changeIndex-1]
		if not (change ~= NULL and change.bundle == bundle)  break

		project.changeIndex -= 1
	}

	reverseArray(labels)
	setActionText("Undo: "..concatinate(labels, ", "), clearMessage=false)

	markEdited(project)
	guiState.refreshRecursively!("undoRedoText")
	scheduleSaveWorkspace()
}

export redo :: () {
	local project = app.projects[app.currentProjectIndex]
	if project.changeIndex > #project.changes  return

	local change = project.changes[project.changeIndex]
	local bundle = change.bundle
	local labels: []string
	local labelsAdded: struct { !key:string, !value:bool }

	while true {
		if not labelsAdded[change.label] {
			labelsAdded[change.label] = true
			insert(labels, change.label)
		}
		change.onDo(project)
		if change.finalize ~= NULL  change.finalize(project)

		change = project.changes[project.changeIndex+1]
		if not (change ~= NULL and change.bundle == bundle)  break

		project.changeIndex += 1
	}

	project.changeIndex += 1

	setActionText("Redo: "..concatinate(labels, ", "), clearMessage=false)

	markEdited(project)
	guiState.refreshRecursively!("undoRedoText")
	scheduleSaveWorkspace()
}



export clampZoomLevel :: (project:Project, zoomLevel:int) -> (zoomLevel:int) {
	return math.clamp(zoomLevel, (project.pixelateWorld ? -1 : -4), 6)
}

export limitZoomLevel :: (project:Project) {
	project.zoomLevel  = clampZoomLevel(project, project.zoomLevel)
	project.zoomSource = project.zoom
	project.zoomTarget = 2 ^ project.zoomLevel
}



export showMainMenu :: () {
	local recentItems: []gui.MenuItem
	insert(recentItems, cast(gui.MenuItem) {name="openLast",label="Reopen closed file",shortcut=ctrlText.."+Shift+T"})
	insert(recentItems, cast(gui.MenuItem) {label="-"})

	if app.recentFiles {
		for app.recentFiles  insert(recentItems, cast(gui.MenuItem) {name="openRecent",data=it,label=it})
	} else {
		insert(recentItems, cast(gui.MenuItem) {label="(no recent files)"})
	}

	insert(recentItems, cast(gui.MenuItem) {label="-"})
	insert(recentItems, cast(gui.MenuItem) {name="clearRecent",label="Clear items"})

	local items: []gui.MenuItem = {
		{label="New project",         name="new",         shortcut=ctrlText.."+N"},
		{label="-"},
		{label="Open project...",     name="open",        shortcut=ctrlText.."+O"},
		{label="Open recent",         submenu=recentItems},
		{label="-"},
		{label="Save project",        name="save",        shortcut=ctrlText.."+S"},
		{label="Save new project...", name="saveAs",      shortcut=ctrlText.."+Shift+S"},
		{label="Export...",           name="export",      shortcut=ctrlText.."+E"},
		{label="-"},
		{label="Preferences",         name="preferences", shortcut=ctrlText.."+K"},
		{label="Log",                 name="log"},
		{label="-"},
		{label="Exit",                name="exit",        shortcut=ctrlText.."+Q"},
	}

	local buttons = guiState.getElement!("menuAndSettingsButtons", gui.Buttons)

	guiState.showMenu!(buttons.layoutX, buttons.layoutY+buttons.layoutHeight, items, (choice:string, data:any) {
		local project = app.projects[app.currentProjectIndex]
		if choice == {
			case "new":         addNewProject() ; guiState.refreshRecursively!("projects") ; setCurrentProject(#app.projects) ; scheduleSaveWorkspace()
			case "open":        showOpenProjectDialog()
			case "openLast":    openRecentProject()
			case "openRecent":  openProject(cast(string)data)
			case "clearRecent": app.recentFiles = {}
			case "save":        if project.fileIsSaved  saveProject(project, project.path, overwrite=true)  else  showSaveProjectAsDialog()
			case "saveAs":      showSaveProjectAsDialog()
			case "export":      pushPanel("exportProject")
			case "preferences": pushPanel("preferences")
			case "log":         pushPanel("log")
			case "exit":        pushQuitEvent()
		}
	})
}



local projectBeingSaved:     Project = NULL
local lastProjectBeforeTemp: Project = NULL

local loadPreview :: (path:string) {
	local lastIndex = app.currentProjectIndex

	local ok, project = openProject(path, asPreview=true)
	if not ok  return

	if lastProjectBeforeTemp == NULL {
		lastProjectBeforeTemp = app.projects[lastIndex]
	}
}

local unloadPreview :: () {
	local currentProject = app.projects[app.currentProjectIndex]

	for < app.projects  if it.preview {
		remove(app.projects, itIndex)
	}

	local ok, i = indexOf(app.projects, (currentProject.preview ? lastProjectBeforeTemp : currentProject))
	assert(ok)
	guiState.refreshRecursively!("projects")
	setCurrentProject(i, force=true)

	lastProjectBeforeTemp = NULL
	scheduleSaveWorkspace()
}

export showSaveProjectAsDialog :: () {
	local project = app.projects[app.currentProjectIndex]
	local pathObj = Path(project.path)

	local ok, dir, filename = pathObj.getDirectoryAndFilename!()
	if not ok {
		dir      = getSaveDirectory().."/projects"
		filename = "untitled.hotparticles"
	}

	projectBeingSaved = project -- Needed as we load previews even in the save dialog, which means app.currentProjectIndex may change.

	showFileDialog(isSave=true, "Save project", dir, filename, filenamePattern="%.hotparticles$",
		onHighlight = (pathObj:Path) {
			loadPreview(pathObj.toString!())

			local ok, filename = pathObj.getFilename!()
			if ok {
				local basename, ext = splitBasenameAndExtension(filename)
				local input         = guiState.getElement!("fileDialog_filename", gui.InputText)
				guiState.setFocus!(input)
				input.field.setSelection!(0, utf8.getLength(basename))
			}
		},
		onChoose = (pathObj:Path) {
			local _, filename = pathObj.getFilename!()

			if not findPattern(filename, "%.hotparticles$") {
				filename    = filename..".hotparticles"
				local input = guiState.getElement!("fileDialog_filename", gui.InputText)
				input.value = input.value..".hotparticles"
				pathObj.setFilename!(filename)
			}

			local path = pathObj.toString!()

			local ok, fileExists = saveProject(projectBeingSaved, path, overwrite=false)
			if ok {
				updateParticleTextures(projectBeingSaved) -- In case any texture uses a relative path.
				popPanel()

			} elseif fileExists {
				local BUTTONS: []gui.Button : {{label="Overwrite"},{label="Cancel"}}

				pushTempChoiceDialog("Confirm save as", filename.." already exists. Overwite it?", BUTTONS, submitIndex=1, [path] (choice:int) {
					if choice ~= 1  return

					saveProject(projectBeingSaved, path, overwrite=true)

					updateParticleTextures(projectBeingSaved) -- In case any texture uses a relative path.
					popPanel("fileDialog")
				})

			} else {
				-- void  Stay in the dialog.
			}
		},
		onClose = () {
			unloadPreview()
			projectBeingSaved = NULL
		}
	)
}

export showOpenProjectDialog :: () {
	local project = app.projects[app.currentProjectIndex]
	local pathObj = Path(project.path)

	local ok, dir = pathObj.getDirectoryAndFilename!()
	if not ok  dir = getSaveDirectory().."/projects"

	showFileDialog("Open project", dir, "", filenamePattern="%.hotparticles$",
		onHighlight = (pathObj:Path) {
			loadPreview(pathObj.toString!())
		},
		onChoose = (pathObj:Path) {
			local path        = pathObj.toString!()
			local ok, project = openProject(path)
			if not ok {
				local input = guiState.getElement!("fileDialog_filename", gui.InputText)
				guiState.setFocus!(input)
				return
			}

			project.preview = false -- In case the project was already opened as a preview (which it probably always is).
			popPanel()

			local _, dir = pathObj.getDirectory!()
			addRecent(app.recentFolders, dir,  app.maxRecentFolders)
			addRecent(app.recentFiles,   path, app.maxRecentFiles)

			-- Make sure the loaded project replaces any single empty project.
			if #app.projects == 2 and isProjectEmpty(app.projects[1]) {
				remove(app.projects, 1)

				guiState.refreshRecursively!("projects")
				setCurrentProject(1)
			}
		},
		onClose = () {
			unloadPreview()
			projectBeingSaved = NULL
		}
	)
}


