--[[============================================================
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

local GIF_RECORDING_MODE :: DEV and 1==0
local GIF_FRAME_DELAY    :: 2 -- 100th of a second. (Using 1 here seem troublesome and may make the GIF play very slowly for some reason.)

export APP_VERSION_STRING   :: !run (getReleaseVersion())
export WORKSPACE_SAVE_DELAY :: 1.00
export WINDOW_TITLE         :: !run format("Hot Particles %s%s", APP_VERSION_STRING, (DEV ? " [DEBUG]" : ""))

export LOG_MAX_ENTRIES      :: 500
export HOTLOADER_USE_WINAPI :: 1==1 -- Enabling this means faster file modification detection and less usage of resources.

export EXPORT_TEMPLATES_DIRECTORY :: "exportTemplates"

export DEV :: !run (indexOf(!import"utils".getProgramArguments(), "dev"))



!preload compiletime [[
	-- For testing:
	_G.love = love or {
		filesystem = {
			getSource              = function()  return require"local.forTests".source               end,
			getSourceBaseDirectory = function()  return require"local.forTests".sourceBaseDirectory  end,
			isFused                = function()  return false                                        end,
		},
	}
]]



global !import "basic"
global !import "color"
global !import "io/path"
global !import "string"

export io     :: !import "io"
export math   :: !import "math"
export os     :: !import "os"
export physfs :: !import "love/physfs"
export utf8   :: !import "utf8"

export love :: !import "love"
export LD :: love.data
export LF :: love.filesystem
export LG :: love.graphics
export LI :: love.image
export LK :: love.keyboard
export LM :: love.mouse
export LT :: love.timer
export LW :: love.window
local  LE :: love.event

global !self
global !load "src/guiSetup"
global !load "src/misc"
global !load "src/workspace"

export gui       :: !load "src/gui"
export hotLoader :: !load "src/hotLoader"

!load "src/shared"



export fontSmall:  LG.Font = NULL
export fontNormal: LG.Font = NULL
export fontLarge:  LG.Font = NULL

export imageBoxGradient: LG.Image = NULL
export imageChecker:     LG.Image = NULL
export imageGradient:    LG.Image = NULL
export imageIcons16:     LG.Image = NULL
export imageNormal:      LG.Image = NULL
export imagePixel:       LG.Image = NULL
export imageRainbow:     LG.Image = NULL

export particleImageNames: []string
export particleImages:     struct { !key:string, !value:ImageAndInfo }
export guiImages:          struct { !key:string, !value:LG.Image }
export dummyCursors:       struct { !key:LM.CursorType, !value:DummyCursor }

export textureBrowserPreviewImage: LG.Image = NULL

export icon16Quads: QuadTable = NULL

local canvasGui:   LG.Canvas = NULL
local canvasWorld: LG.Canvas = NULL

local actionText          = ""
local actionTextTime      = -9999.00
local actionTextDuration :: 0.60
local messageText         = ""
local messageTextTime     = -9999.00
local messageTextDuration = 1.00

export isPositioningParticles = false

export workspaceSaveScheduled = false
export workspaceSaveDelay     = 0.00
export workspaceSaveTime      = -9999.00

export scheduleRecreateCanvases = false

local particleUpdateTime = 0.00
local particleDrawTime   = 0.00
local presentTime        = 0.00

local defaultSearchPaths: []string = NULL

export app: App
export guiState: gui.State

local freezeDtThisFrame = false

local forcePixelatedTextures = false
local forceParticleUpdates   = false

local zoomTime = -9999.00

export updateEventCount = 0

local timeForAnimationPreview   = 0.00
local particleEmitDurationTotal = 0.00

local showParticlePath = 0 -- 0=no, 1=average, 2=range

export isWindows: bool
export isMac:     bool
export lctrl: LK.KeyConstant
export rctrl: LK.KeyConstant
export ctrlText: string

export currentCursor = LM.CursorType.ARROW

!if GIF_RECORDING_MODE {
	local gifRecordingActive    = false
	local gifRecordingFrame     = 1
	local gifRecordingName      = ""
	local gifRecordingDirectory = ""

	local VisualMousePress :: struct { x:int, y:int, progress=0.0 }
	local visualMousePresses: []VisualMousePress
}



export QuadTable :: struct { !key:string, !value:LG.Quad }

export DummyCursor :: struct {
	hotX: int,
	hotY: int,
	data: LI.ImageData = NULL,
}



export ImageAndInfo :: struct {
	fullPath: string,
	fileData: LF.FileData = NULL, -- We use FileData instead of ImageData as the latter is problematic when exporting the textures.  @Cleanup: Does this need to be loaded all the time (since we have the path here anyway)?
	image:    LG.Image    = NULL,
	bundled  = false,
	modified = -1,
}

export ShaderAndInfo :: struct {
	fullPath: string,
	shader:   LG.Shader = NULL,
	modified = -1,
}



export STATS_NONE  :: 0
export STATS_SOME  :: 1
export STATS_ALL   :: 2
export STATS_COUNT :: 3

export App :: struct {
	-- Saved workspace data:

	projects: []Project,
	currentProjectIndex = 1,

	showStats           = STATS_SOME,
	showProjectSettings = false,
	showPanelNumbers    = true,

	recentProjects:  []string,
	recentFolders:   []string,
	recentTextures:  []string,
	recentShaders:   []string,
	recentTemplates: []string,

	bookmarkedFolders: []string,

	hiddenSections: struct { !key:string, !value:bool } = {scaleGlobalSection=true, scaleAllSection=true, customDataProjectSection=true, customDataSystemSection=true},

	gotWindowInfo   = false, -- Load-time only.
	windowX         = 0,
	windowY         = 0,
	windowWidth     = 0,
	windowHeight    = 0,
	windowMaximized = false,

	maxBufferSize    = 16000, -- Default buffer size for ParticleSystem is 1000.
	maxRecentFiles   = 15,
	maxRecentFolders = 4, -- @Deprecated
	maxChanges       = 200,

	preferRelativePaths           = false, -- For file browser.
	initializeSystemInNewProjects = true,

	userGradients: []ColorGradient = {},
}

export ColorGradient :: struct {
	name = "",
	!value: float, -- h1,s1,v1,a1,...
}



export Movement :: enum { NONE::0, CIRCLE, EIGHT, IRREGULAR }

export Project :: struct {
	-- Saved:
	systems: []System,

	bgColor: []float = {0,0,.15}, -- HSV
	bgChecker = 0.0, -- -1..+1
	bgSize    = 8,
	bgPath    = "",
	bgScale   = 1.0,
	bgRepeatX = false,
	bgRepeatY = false,

	pixelateWorld    = false,
	pixelateTextures = false,

	zoomLevel = 0,

	movementPreset        = Movement.NONE,
	movementScaleXEnabled = true,
	movementScaleX        = 1.0,
	movementScaleYEnabled = true,
	movementScaleY        = 1.0,
	movementSpeed         = 1.0,

	exportBaseDirectory         = "",
	exportParticles             = true,
	exportParticlesOverwrite    = false,
	exportParticlesPath         = "",
	exportParticlesTemplate     = "defaultLuaModule", -- If this is empty then exportParticlesTemplatePath is used.
	exportParticlesTemplatePath = "",
	exportTextures              = false,
	exportTexturesOverwrite     = false,
	exportTexturesDirectory     = "",
	exportClipboardTemplate     = "defaultLuaClipboard",
	exportClipboardTemplatePath = "",

	scaleGlobalTimeEnabled  = true,
	scaleGlobalTime         = 1.0,
	scaleGlobalSpaceEnabled = true,
	scaleGlobalSpace        = 1.0,
	scaleGlobalSizeEnabled  = true,
	scaleGlobalSize         = 1.0,

	regionEnabled = true,
	regionWidth   = 0,
	regionHeight  = 0,

	emitterX: float,
	emitterY: float,

	customData = "",

	guiLimits: struct { !key:string, !value:float },

	edited = false, -- Only saved in workspace.
	path   = "",    -- Only saved in workspace.

	-- Runtime-only:
	systemIndex = 1,

	zoom       = 1.0,
	zoomSource = 1.0,
	zoomTarget = 1.0,

	displayedName = "",
	fileIsSaved   = false, -- Saved at least once (or loaded from a saved file). It's possible that the file physically don't exist (maybe deleted or moved).
	preview       = false,

	movementPhase    = 0.0,
	-- For irregular movement:
	movementPhaseAbs = 0.0,
	movementPoint1X  = 0.0,
	movementPoint1Y  = 0.0,
	movementPoint2X  = 0.0,
	movementPoint2Y  = 0.0,
	movementPoint3X  = 0.0,
	movementPoint3Y  = 0.0,
	movementPoint4X  = 0.0,
	movementPoint4Y  = 0.0,

	particleEmitDuration = 0.00,

	currentBgImage: ImageAndInfo = NULL,

	changes: []Change,
	changeIndex = 1, -- Should point at the next slot in 'changes'.

	emitterPlacementX = 0.0,
	emitterPlacementY = 0.0,

	_init :: (project:Project) {
		static n = 0 ; n += 1
		project.displayedName = format("(untitled %d)", n)
	},

	!call :: () -> Project {
		local project: Project
		_init(project)
		return project
	},

	clone :: (source:Project) -> Project {
		local project: Project = {
			bgColor                     = {source.bgColor[1], source.bgColor[2], source.bgColor[3]},
			bgChecker                   = source.bgChecker,
			bgSize                      = source.bgSize,
			bgPath                      = source.bgPath,
			bgScale                     = source.bgScale,
			bgRepeatX                   = source.bgRepeatX,
			bgRepeatY                   = source.bgRepeatY,
			pixelateWorld               = source.pixelateWorld,
			pixelateTextures            = source.pixelateTextures,
			zoomLevel                   = source.zoomLevel,
			movementPreset              = source.movementPreset,
			movementScaleXEnabled       = source.movementScaleXEnabled,
			movementScaleX              = source.movementScaleX,
			movementScaleYEnabled       = source.movementScaleYEnabled,
			movementScaleY              = source.movementScaleY,
			movementSpeed               = source.movementSpeed,
			exportBaseDirectory         = source.exportBaseDirectory,
			exportParticles             = source.exportParticles,
			exportParticlesOverwrite    = source.exportParticlesOverwrite,
			exportParticlesPath         = source.exportParticlesPath,
			exportParticlesTemplate     = source.exportParticlesTemplate,
			exportParticlesTemplatePath = source.exportParticlesTemplatePath,
			exportTextures              = source.exportTextures,
			exportTexturesOverwrite     = source.exportTexturesOverwrite,
			exportTexturesDirectory     = source.exportTexturesDirectory,
			exportClipboardTemplate     = source.exportClipboardTemplate,
			exportClipboardTemplatePath = source.exportClipboardTemplatePath,
			scaleGlobalTimeEnabled      = source.scaleGlobalTimeEnabled,
			scaleGlobalTime             = source.scaleGlobalTime,
			scaleGlobalSpaceEnabled     = source.scaleGlobalSpaceEnabled,
			scaleGlobalSpace            = source.scaleGlobalSpace,
			scaleGlobalSizeEnabled      = source.scaleGlobalSizeEnabled,
			scaleGlobalSize             = source.scaleGlobalSize,
			regionEnabled               = source.regionEnabled,
			regionWidth                 = source.regionWidth,
			regionHeight                = source.regionHeight,
			emitterX                    = source.emitterX,
			emitterY                    = source.emitterY,
			customData                  = source.customData,
			guiLimits                   = copyTable(source.guiLimits),
			edited                      = true,

			zoom       = source.zoom,
			zoomTarget = source.zoomTarget,

			emitterPlacementX = source.emitterX,
			emitterPlacementY = source.emitterY,
		}
		_init(project)

		for source.systems  project.systems[itIndex] = it.clone!()

		updateParticles(project)
		return project
	},
}

export System :: struct {
	-- Saved:
	psDirectionEnabled              = true,
	psDirection                     = 0.0,
	psEmissionAreaDistribution      = LG.AreaSpreadDistribution.NONE,
	psEmissionAreaDxEnabled         = true, -- @Cleanup: Should we join psEmissionAreaDxEnabled and psEmissionAreaDyEnabled?
	psEmissionAreaDx                = 100.0,
	psEmissionAreaDyEnabled         = true,
	psEmissionAreaDy                = 100.0,
	psEmissionAreaAngleEnabled      = true,
	psEmissionAreaAngle             = 0.0,
	psEmissionAreaRelative          = false,
	psEmissionRate                  = 1.0,
	psEmitterContinuous             = true,
	psEmitterLifetime               = 0.0,
	psInsertMode                    = LG.ParticleInsertMode.TOP,
	psLinearAccelerationXEnabled    = true, -- @Cleanup: Should we join psLinearAccelerationXEnabled and psLinearAccelerationYEnabled?
	psLinearAccelerationYEnabled    = true,
	psLinearAccelerationXmin        = 0.0,
	psLinearAccelerationYmin        = 0.0,
	psLinearAccelerationXmax        = 0.0,
	psLinearAccelerationYmax        = 0.0,
	psLinearDampingEnabled          = true,
	psLinearDampingMin              = 0.0,
	psLinearDampingMax              = 0.0,
	psParticleLifetimeMin           = 1.0,
	psParticleLifetimeMax           = 1.0,
	psRadialAccelerationEnabled     = true,
	psRadialAccelerationMin         = 0.0,
	psRadialAccelerationMax         = 0.0,
	psRelativeRotation              = false,
	psRotationEnabled               = true,
	psRotationMin                   = 0.0,
	psRotationMax                   = 0.0,
	psSizes: []float                = {1},
	psSizeVariationEnabled          = true,
	psSizeVariation                 = 0.0,
	psSpeedEnabled                  = true,
	psSpeedMin                      = 0.0,
	psSpeedMax                      = 0.0,
	psSpinMinEnabled                = true, -- @Cleanup: Should we join psSpinMinEnabled and psSpinMaxEnabled?
	psSpinMin                       = 0.0, -- Turns, not angle.
	psSpinMaxEnabled                = true,
	psSpinMax                       = 0.0, -- Turns, not angle.
	psSpinVariationEnabled          = true,
	psSpinVariation                 = 0.0,
	psSpreadEnabled                 = true,
	psSpread                        = 0.0,
	psTangentialAccelerationEnabled = true,
	psTangentialAccelerationMin     = 0.0,
	psTangentialAccelerationMax     = 0.0,

	colors: []float = {0,0,1,1}, -- {h1,s1,v1,a1,...}
	blendMode = LG.BlendMode.ADD,

	texturePath    = "",
	textureName    = "light", -- Preset fallback to texturePath.
	textureOffsetX = .5,
	textureOffsetY = .5,

	shaderPath = "",

	scaleTimeEnabled  = true,
	scaleTime         = 1.0,
	scaleSpaceEnabled = true,
	scaleSpace        = 1.0,
	scaleSizeEnabled  = true,
	scaleSize         = 1.0,

	kickStartEmitEnabled  = true,
	kickStartEmit         = 0,
	kickStartStepsEnabled = true,
	kickStartSteps        = 0,

	title      = "",
	customData = "",

	emitterOffsetEnabled = true,
	emitterOffsetX       = 0.0,
	emitterOffsetY       = 0.0,

	frames: []AnimationFrame,

	gui: struct { !key:string, !value:string },

	-- Runtime-only:
	visible = true,

	particles: LG.ParticleSystem = NULL,

	currentImage:  ImageAndInfo  = NULL,
	currentShader: ShaderAndInfo = NULL,

	!call :: () -> System {
		local system: System

		system.currentImage = particleImages.light

		system.particles = LG.newParticleSystem(system.currentImage.image)
		system.particles.stop!() -- Needed for initial kick-start to work.

		return system
	},

	clone :: (source:System) -> System {
		local system: System = {
			psDirectionEnabled              = source.psDirectionEnabled,
			psDirection                     = source.psDirection,
			psEmissionAreaDistribution      = source.psEmissionAreaDistribution,
			psEmissionAreaDxEnabled         = source.psEmissionAreaDxEnabled,
			psEmissionAreaDx                = source.psEmissionAreaDx,
			psEmissionAreaDyEnabled         = source.psEmissionAreaDyEnabled,
			psEmissionAreaDy                = source.psEmissionAreaDy,
			psEmissionAreaAngleEnabled      = source.psEmissionAreaAngleEnabled,
			psEmissionAreaAngle             = source.psEmissionAreaAngle,
			psEmissionAreaRelative          = source.psEmissionAreaRelative,
			psEmissionRate                  = source.psEmissionRate,
			psEmitterContinuous             = source.psEmitterContinuous,
			psEmitterLifetime               = source.psEmitterLifetime,
			psInsertMode                    = source.psInsertMode,
			psLinearAccelerationXEnabled    = source.psLinearAccelerationXEnabled,
			psLinearAccelerationYEnabled    = source.psLinearAccelerationYEnabled,
			psLinearAccelerationXmin        = source.psLinearAccelerationXmin,
			psLinearAccelerationYmin        = source.psLinearAccelerationYmin,
			psLinearAccelerationXmax        = source.psLinearAccelerationXmax,
			psLinearAccelerationYmax        = source.psLinearAccelerationYmax,
			psLinearDampingEnabled          = source.psLinearDampingEnabled,
			psLinearDampingMin              = source.psLinearDampingMin,
			psLinearDampingMax              = source.psLinearDampingMax,
			psParticleLifetimeMin           = source.psParticleLifetimeMin,
			psParticleLifetimeMax           = source.psParticleLifetimeMax,
			psRadialAccelerationEnabled     = source.psRadialAccelerationEnabled,
			psRadialAccelerationMin         = source.psRadialAccelerationMin,
			psRadialAccelerationMax         = source.psRadialAccelerationMax,
			psRelativeRotation              = source.psRelativeRotation,
			psRotationEnabled               = source.psRotationEnabled,
			psRotationMin                   = source.psRotationMin,
			psRotationMax                   = source.psRotationMax,
			psSizes                         = {unpack(source.psSizes)},
			psSizeVariationEnabled          = source.psSizeVariationEnabled,
			psSizeVariation                 = source.psSizeVariation,
			psSpeedEnabled                  = source.psSpeedEnabled,
			psSpeedMin                      = source.psSpeedMin,
			psSpeedMax                      = source.psSpeedMax,
			psSpinMinEnabled                = source.psSpinMinEnabled,
			psSpinMin                       = source.psSpinMin, -- @Cleanup: Rename min/max to something more accurate.
			psSpinMaxEnabled                = source.psSpinMaxEnabled,
			psSpinMax                       = source.psSpinMax,
			psSpinVariationEnabled          = source.psSpinVariationEnabled,
			psSpinVariation                 = source.psSpinVariation,
			psSpreadEnabled                 = source.psSpreadEnabled,
			psSpread                        = source.psSpread,
			psTangentialAccelerationEnabled = source.psTangentialAccelerationEnabled,
			psTangentialAccelerationMin     = source.psTangentialAccelerationMin,
			psTangentialAccelerationMax     = source.psTangentialAccelerationMax,
			colors                          = {unpack(source.colors)},
			blendMode                       = source.blendMode,
			texturePath                     = source.texturePath,
			textureName                     = source.textureName,
			textureOffsetX                  = source.textureOffsetX,
			textureOffsetY                  = source.textureOffsetY,
			shaderPath                      = source.shaderPath,
			scaleTimeEnabled                = source.scaleTimeEnabled,
			scaleTime                       = source.scaleTime,
			scaleSpaceEnabled               = source.scaleSpaceEnabled,
			scaleSpace                      = source.scaleSpace,
			scaleSizeEnabled                = source.scaleSizeEnabled,
			scaleSize                       = source.scaleSize,
			kickStartEmitEnabled            = source.kickStartEmitEnabled,
			kickStartEmit                   = source.kickStartEmit,
			kickStartStepsEnabled           = source.kickStartStepsEnabled,
			kickStartSteps                  = source.kickStartSteps,
			title                           = source.title,
			customData                      = source.customData,
			emitterOffsetEnabled            = source.emitterOffsetEnabled,
			emitterOffsetX                  = source.emitterOffsetX,
			emitterOffsetY                  = source.emitterOffsetY,
			gui                             = copyTable(source.gui),

			particles    = source.particles.clone!(),
			currentImage = source.currentImage,
		}

		copyFramesTo(source.frames, system.frames)

		system.particles.stop!()
		return system
	},
}

export AnimationFrame :: struct { x=0.0, y=0.0, w=0.0, h=0.0 }

export Change :: struct {
	bundle:   int,
	name:     string,
	label:    string,
	data:     any,
	onDo:     (project:Project) = NULL,
	onUndo:   (project:Project) = NULL,
	finalize: (project:Project) = NULL,
}



export updateParticles :: (project:Project) {
	for project.systems  updateParticles(project, it)
}
export updateParticles :: (project:Project, system:System) {
	updateParticleParams(project, system)
	updateParticleColors(system)
	updateParticleTexture(project, system)
	updateParticleShader(project, system)
}

export updateParticleParams :: (project:Project, s:System) {
	local ps = s.particles

	local time  = (s.scaleTimeEnabled  ? s.scaleTime  : 1) * (project.scaleGlobalTimeEnabled  ? project.scaleGlobalTime  : 1)
	local space = (s.scaleSpaceEnabled ? s.scaleSpace : 1) * (project.scaleGlobalSpaceEnabled ? project.scaleGlobalSpace : 1)
	local size  = (s.scaleSizeEnabled  ? s.scaleSize  : 1) * (project.scaleGlobalSizeEnabled  ? project.scaleGlobalSize  : 1)
	local time2 = time ^ 2

	local sizes: []float
	for s.psSizes  insert(sizes, it*size)

	ps.setDirection!(
		s.psDirectionEnabled ? s.psDirection : 0
	)
	ps.setEmissionArea!(
		s.psEmissionAreaDistribution,
		s.psEmissionAreaDxEnabled    ? s.psEmissionAreaDx * space : 0,
		s.psEmissionAreaDyEnabled    ? s.psEmissionAreaDy * space : 0,
		s.psEmissionAreaAngleEnabled ? s.psEmissionAreaAngle      : 0,
		s.psEmissionAreaRelative
	)
	ps.setEmissionRate!(
		s.psEmissionRate * time
	)
	ps.setEmitterLifetime!(
		s.psEmitterContinuous ? -1 : s.psEmitterLifetime / time
	)
	ps.setInsertMode!(
		s.psInsertMode
	)
	ps.setLinearAcceleration!(
		s.psLinearAccelerationXEnabled ? s.psLinearAccelerationXmin * space * time2 : 0,
		s.psLinearAccelerationYEnabled ? s.psLinearAccelerationYmin * space * time2 : 0,
		s.psLinearAccelerationXEnabled ? s.psLinearAccelerationXmax * space * time2 : 0,
		s.psLinearAccelerationYEnabled ? s.psLinearAccelerationYmax * space * time2 : 0
	)
	ps.setLinearDamping!(
		s.psLinearDampingEnabled ? s.psLinearDampingMin * time : 0,
		s.psLinearDampingEnabled ? s.psLinearDampingMax * time : 0
	)
	ps.setParticleLifetime!(
		s.psParticleLifetimeMin / time,
		s.psParticleLifetimeMax / time
	)
	ps.setRadialAcceleration!(
		s.psRadialAccelerationEnabled ? s.psRadialAccelerationMin * space * time2 : 0,
		s.psRadialAccelerationEnabled ? s.psRadialAccelerationMax * space * time2 : 0
	)
	ps.setRelativeRotation!(
		s.psRelativeRotation
	)
	ps.setRotation!(
		s.psRotationEnabled ? s.psRotationMin : 0,
		s.psRotationEnabled ? s.psRotationMax : 0
	)
	ps.setSizes!(
		sizes
	)
	ps.setSizeVariation!(
		s.psSizeVariationEnabled ? s.psSizeVariation : 0
	)
	ps.setSpeed!(
		s.psSpeedEnabled ? s.psSpeedMin * space * time : 0,
		s.psSpeedEnabled ? s.psSpeedMax * space * time : 0
	)
	ps.setSpin!(
		s.psSpinMinEnabled ? s.psSpinMin * time * math.TAU : 0,
		s.psSpinMaxEnabled ? s.psSpinMax * time * math.TAU : 0
	)
	ps.setSpinVariation!(
		s.psSpinVariationEnabled ? s.psSpinVariation : 0
	)
	ps.setSpread!(
		s.psSpreadEnabled ? s.psSpread : 0
	)
	ps.setTangentialAcceleration!(
		s.psTangentialAccelerationEnabled ? s.psTangentialAccelerationMin * space * time2 : 0,
		s.psTangentialAccelerationEnabled ? s.psTangentialAccelerationMax * space * time2 : 0
	)
}

export updateParticleColors :: (system:System) {
	local colors = system.colors
	local colorsRgba: []float

	for i = 1, #colors, 4 {
		local r, g, b = hsvToRgb(colors[i], colors[i+1], colors[i+2])
		insert(colorsRgba, r)
		insert(colorsRgba, g)
		insert(colorsRgba, b)
		insert(colorsRgba, colors[i+3])
	}

	system.particles.setColors!(colorsRgba)
}

export updateParticleTextures :: (project:Project) {
	for project.systems  updateParticleTexture(project, it)
}

export updateParticleAnimation :: (system:System) {
	if system.frames {
		local iw, ih = system.currentImage.image.getDimensions!()
		local quads: []LG.Quad

		for system.frames {
			insert(quads, LG.newQuad(it.x, it.y, it.w, it.h, iw, ih))
		}

		system.particles.setQuads!(quads)

	} else {
		system.particles.setQuads!()
	}

	updateParticleTextureOffset(system)
}

export updateParticleTextureOffset :: (system:System) {
	if system.frames {
		local animFrame1 = system.frames[1]
		system.particles.setOffset!(animFrame1.w*system.textureOffsetX, animFrame1.h*system.textureOffsetY)
	} else {
		local iw, ih = system.currentImage.image.getDimensions!()
		system.particles.setOffset!(iw*system.textureOffsetX, ih*system.textureOffsetY)
	}
}



-- @Cleanup: The following update* functions are very similar!

export updateBackgroundTexture :: (project:Project, dummy:System=NULL, saveRecent=false) -> (dummy:bool) {
	local loadBackgroundTexture :: (project:Project, saveRecent:bool) -> ImageAndInfo {
		local ok, path, isDangling = getFullPathToBackground(project)
		if not ok {
			if isDangling
				setErrorText("Relative paths require the project to be saved: %s", path)
			else
				setErrorText("Bad texture path '%s'", path)
			return NULL
		}

		local ^ok, dir, filename = Path(path).getDirectoryAndFilename!()
		assert(ok)

		if not connectToRemoteDirectory(dir) {
			setErrorText("Could not access folder '%s'", dir)
			return NULL
		}
		defer disconnectFromRemoteDirectory()

		local imageData, err = LF.newFileData(filename)

		if imageData == NULL {
			setErrorText(err)
			return NULL
		}

		if saveRecent  addRecent(app.recentTextures, project.bgPath, app.maxRecentFiles)
		-- if saveRecent  addRecent(app.recentTextures, path, app.maxRecentFiles)

		local image, ^err = pcall_newImage(filename)
		if image == NULL {
			log(err)
			setErrorText("Could not load texture '%s'", filename)
			return NULL
		}

		static info: LF.FileInfo

		local imageAndInfo: ImageAndInfo = {
			fullPath = path,
			fileData = cast(LF.FileData)imageData,
			image    = image,
			bundled  = false,
			modified = (LF.getInfo(filename, info) ~= nil and info.modtime ~= nil) ? cast(int)info.modtime : -1,
		}
		return imageAndInfo
	}

	local imageAndInfo: ImageAndInfo = NULL

	if project.bgPath  imageAndInfo = loadBackgroundTexture(project, saveRecent) -- @Speed: Don't reload the texture if there's no change (and we don't want to force a reload).

	project.currentBgImage = imageAndInfo

	if imageAndInfo ~= NULL {
		local filter = project.pixelateTextures ? LG.FilterMode.NEAREST : .LINEAR
		imageAndInfo.image.setFilter!(filter, filter)
		imageAndInfo.image.setWrap!(.REPEAT, .REPEAT) -- @Polish: Only use repeat when necessary to avoid artifacts around the background image.
	}

	hotLoader.watchersNeedUpdate = true
	return false -- Dummy value for hot-loader.
}

export updateParticleTexture :: (project:Project, system:System, saveRecent=false) -> (loadedCustomTexture:bool) {
	local loadParticleTexture :: (project:Project, system:System, saveRecent:bool) -> ImageAndInfo {
		local ok, path, isDangling = getFullPathToTexture(project, system)
		if not ok {
			if isDangling
				setErrorText("Relative paths require the project to be saved: %s", path)
			else
				setErrorText("Bad texture path '%s'", path)
			return NULL
		}

		local ^ok, dir, filename = Path(path).getDirectoryAndFilename!()
		assert(ok)

		if not connectToRemoteDirectory(dir) {
			setErrorText("Could not access folder '%s'", dir)
			return NULL
		}
		defer disconnectFromRemoteDirectory()

		local imageData, err = LF.newFileData(filename)

		if imageData == NULL {
			setErrorText(err)
			return NULL
		}

		if saveRecent  addRecent(app.recentTextures, system.texturePath, app.maxRecentFiles)
		-- if saveRecent  addRecent(app.recentTextures, path, app.maxRecentFiles)

		local image, ^err = pcall_newImage(filename)
		if image == NULL {
			log(err)
			setErrorText("Could not load texture '%s'", filename)
			return NULL
		}

		static info: LF.FileInfo

		local imageAndInfo: ImageAndInfo = {
			fullPath = path,
			fileData = cast(LF.FileData)imageData,
			image    = image,
			bundled  = false,
			modified = (LF.getInfo(filename, info) ~= nil and info.modtime ~= nil) ? cast(int)info.modtime : -1,
		}
		return imageAndInfo
	}

	local imageAndInfo: ImageAndInfo = NULL
	local loadedCustomTexture        = true

	if system.texturePath  imageAndInfo = loadParticleTexture(project, system, saveRecent) -- @Speed: Don't reload the texture if there's no change (and we don't want to force a reload).

	if imageAndInfo == NULL {
		imageAndInfo        = particleImages[system.textureName]
		loadedCustomTexture = false
	}

	system.currentImage = imageAndInfo

	system.particles.setTexture!(imageAndInfo.image)
	updateParticleAnimation(system)

	local filter = project.pixelateTextures ? LG.FilterMode.NEAREST : .LINEAR
	imageAndInfo.image.setFilter!(filter, filter)

	hotLoader.watchersNeedUpdate = true
	return loadedCustomTexture
}

export updateParticleShader :: (project:Project, system:System, saveRecent=false) -> (dummy:bool) {
	local loadParticleShader :: (project:Project, system:System, saveRecent:bool) -> ShaderAndInfo {
		local ok, path, isDangling = getFullPathToShader(project, system)
		if not ok {
			if isDangling
				setErrorText("Relative paths require the project to be saved: %s", path)
			else
				setErrorText("Bad shader path '%s'", path)
			return NULL
		}

		local ^ok, dir, filename = Path(path).getDirectoryAndFilename!()
		assert(ok)

		if not connectToRemoteDirectory(dir) {
			setErrorText("Could not access folder '%s'", dir)
			return NULL
		}
		defer disconnectFromRemoteDirectory()

		if saveRecent  addRecent(app.recentShaders, system.shaderPath, app.maxRecentFiles)
		-- if saveRecent  addRecent(app.recentShaders, path, app.maxRecentFiles)

		local shaderCode: string = NULL
		do {
			local _shaderCode, err = LF.read(filename)
			if _shaderCode == nil {
				setErrorText("Could not read '%s': %s", filename, err)
				return NULL
			}
			shaderCode = cast(string) _shaderCode
		}

		-- Note: wrap_GraphicsShader.lua in LÖVE is used as reference for some things here.

		local versionLine = ""
		if findPattern(shaderCode, "^#pragma language %w") {
			local _, _versionLine, _shaderCode = matchPattern(shaderCode, "^([^\n]+\n?)(.*)")
			versionLine = cast(string) _versionLine
			shaderCode  = cast(string) _shaderCode
		}

		shaderCode =
			versionLine.."\z
			#define HOT_PARTICLES\n\z
			uniform float hotParticlesTime;\n\z
			uniform float hotParticlesEmitterTime;\n\z
			"..shaderCode

		local shader, err = pcall_newShader(shaderCode)
		if shader == NULL {
			log(err) -- @Incomplete: Fix line numbers.
			setErrorText("Could not load shader '%s' (see File > Log)", filename)
			log("Note: Line numbers are slightly off because the program edits the shader a bit.")
			return NULL
		}

		static info: LF.FileInfo

		local shaderAndInfo: ShaderAndInfo = {
			fullPath = path,
			shader   = shader,
			modified = (LF.getInfo(filename, info) ~= nil and info.modtime ~= nil) ? cast(int)info.modtime : -1,
		}
		return shaderAndInfo
	}

	local shaderAndInfo: ShaderAndInfo = NULL

	if system.shaderPath  shaderAndInfo = loadParticleShader(project, system, saveRecent) -- @Speed: Don't reload the shader if there's no change (and we don't want to force a reload).

	system.currentShader = shaderAndInfo

	hotLoader.watchersNeedUpdate = true
	return false -- Dummy value for hot-loader.
}



export updateImageFilters :: () {
	local currentProject = app.projects[app.currentProjectIndex]
	local filter         = (currentProject.pixelateTextures or forcePixelatedTextures) ? LG.FilterMode.NEAREST : .LINEAR

	if currentProject.currentBgImage ~= NULL {
		currentProject.currentBgImage.image.setFilter!(filter, filter)
	}

	for particleImageNames {
		particleImages[it].image.setFilter!(filter, filter)
	}

	for currentProject.systems  it.currentImage.image.setFilter!(filter, filter) -- In case systems use custom textures.
}



export newSystem :: (project:Project, showcase=false) -> System {
	local system = System()

	if showcase and app.initializeSystemInNewProjects {
		system.psDirection           = -math.TAU/4
		system.psEmissionRate        = 20
		system.psParticleLifetimeMin = 1.8
		system.psParticleLifetimeMax = 2.2
		system.psSpeedMin            = 90
		system.psSpeedMax            = 100
		system.psSpread              = .05*math.TAU
		system.colors                = {0,0,1,0, 0,0,1,1, 0,0,1,.5, 0,0,1,0}
		system.psSizes               = {.4}
	}
	updateParticleParams(project, system)
	updateParticleColors(system)

	moveEmittersTo(project, project.emitterPlacementX, project.emitterPlacementY, commit=false, instant=true)

	return system
}

export addNewSystem :: (project:Project, showcase=false) {
	insert(project.systems, newSystem(project, showcase))
}

export addNewProject :: () -> Project {
	local project = Project()
	insert(app.projects, project)

	addNewSystem(project, showcase=true)

	return project
}



export createCanvases :: () {
	local ww, wh = LG.getDimensions()

	if canvasGui ~= NULL {
		canvasGui  .release!()
		canvasWorld.release!()
	}

	local SETTINGS: LG.CanvasSettings : {msaa=2^2}
	canvasGui   = LG.newCanvas(ww, wh, SETTINGS)
	canvasWorld = LG.newCanvas(math.max(ww-MAIN_PANEL_WIDTH, 1), wh)
	-- canvasWorld = LG.newCanvas(ww, wh) -- @Incomplete: Make the main panel collapsible for real.

	if app.projects[app.currentProjectIndex].pixelateWorld {
		canvasWorld.setFilter!(.NEAREST, .NEAREST)
	}

	scheduleRecreateCanvases = false
}



export moveEmittersTo :: (project:Project, x,y:float, commit:bool, instant=false) {
	project.emitterPlacementX = x
	project.emitterPlacementY = y

	for project.systems {
		local targetX = x
		local targetY = y

		if it.emitterOffsetEnabled {
			targetX += it.emitterOffsetX
			targetY += it.emitterOffsetY
		}

		if instant
			it.particles.setPosition!(targetX, targetY)
		else
			it.particles.moveTo!(targetX, targetY)
	}

	if commit and not (project.emitterX == x and project.emitterY == y) {
		project.emitterX = x -- @UX: Should we record this change? Leaning towards no. 2021-02-18
		project.emitterY = y
		markEdited(project)
		scheduleSaveWorkspace()
	}
}



export pushQuitEvent :: () {
	saveWorkspace()
	hotLoader.stop()
	LE.quit(0)
}



export connectToRemoteDirectory :: (dir:string) -> (success:bool) {
	if not physfs.mountReadDirectory(dir)  return false

	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it))

	assert(physfs.mountReadDirectory(dir))
	assert(physfs.setWriteDirectory(dir))

	return true
}

export disconnectFromRemoteDirectory :: () {
	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it),     it)
	for defaultSearchPaths       assert(physfs.mountReadDirectory(it, true), it)

	assert(physfs.setWriteDirectory(getSaveDirectory()))
}



export setActionText :: (s:string, clearMessage=true) {
	actionText     = s
	actionTextTime = LT.getTime()
	if clearMessage  messageText = ""
}
export setActionText :: (s:string, v,...:int|float|string) {
	setActionText(format(s, v, ...))
}

export setMessageText :: (s:string) {
	if s  log(s)
	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 3.00
}
export setMessageText :: (s:string, v,...:int|float|string) {
	setMessageText(format(s, v, ...))
}

export setErrorText :: (s:string) {
	s = "Error: "..s
	log(s)
	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 8.00
}
export setErrorText :: (s:string, v,...:int|float|string) {
	setErrorText(format(s, v, ...))
}



local onRun :: () -> (mainLoop:()->int|none) {
	local LOVE: struct { !key:string, !value:(...:love.Variant) } : !foreign lua "love"

	local argsRaw = !import"utils".getCommandLineArguments()
	LOVE.load(love.arg.parseGameArguments(argsRaw), argsRaw)

	LT.step()
	local dt = .0

	return [dt] () -> int|none {
		LE.pump()
		for name, a,b,c,d,e,f in LE.poll() {
			if name == .QUIT {
				-- if not (cast(()->bool)cast(any)LOVE.quit)() { -- We don't currently have a 'quit' handler.
					return a == NULL ? 0 : cast(int)a
				-- }
			}
			local HANDLERS: struct { !key:LE.Event, !value:(...:love.Variant) } : !foreign lua "love.handlers"
			HANDLERS[name](a,b,c,d,e,f)
		}

		dt = LT.step()
		LOVE.update(dt)

		if LG.isActive()  LOVE.draw()

		LT.sleep(0.001)
		return nil
	}
}



local onLoad :: (args:[]string, argsRaw:[]string) {
	io.disableBuffering(io.STDOUT)
	io.disableBuffering(io.STDERR)

	print("Running Hot Particles")
	LW.setTitle(WINDOW_TITLE)

	fontSmall  = LG.newFont(10)
	fontNormal = LG.newFont(12)
	fontLarge  = LG.newFont(16)

	do {
		local TEXT :: "Loading..."
		LG.clear(1, 1, 1, 1)
		LG.setFont(fontLarge)
		LG.setColor(0, 0, 0)
		LG.print(TEXT, (LG.getWidth()-fontLarge.getWidth!(TEXT))//2, (LG.getHeight()-fontLarge.getHeight!())//2)
		LG.present()
		LG.reset()
		-- LT.sleep(1) -- DEBUG
	}

	do {
		local osName = love.system.getOS()

		isWindows = osName == .WINDOWS
		isMac     = osName == .OSX

		lctrl    = isMac ? "lgui" : "lctrl"
		rctrl    = isMac ? "rgui" : "rctrl"
		ctrlText = isMac ? "Cmd"  : "Ctrl"
	}

	local projectsToOpen: []string

	for args {
		if not findPattern(it, "^%-") {
			insert(projectsToOpen, it)

		} elseif it == "--help" or it == "-help" or it == "-?" or it == "/help" or it == "/?" {
			print("Argument synopsis:  HotParticles.exe [fileToOpen1 fileToOpen2 ...]")

		} else {
			printf("Unknown option '%s'.", it)
		}
	}

	LK.setKeyRepeat(true)

	LF.createDirectory("projects") -- Must happen before physfs stuff so the save folder exists.

	defaultSearchPaths = physfs.getSearchPaths()
	!if not DEV  insert(defaultSearchPaths, getAppDirectory())
	disconnectFromRemoteDirectory() -- Resets paths. We didn't actually connect.

	dummyCursors[.ARROW]         = {hotX=2, hotY=2,  data=LI.newImageData("gfx/cursor_arrow.png")}
	dummyCursors[.I_BEAM]        = {hotX=4, hotY=9,  data=LI.newImageData("gfx/cursor_ibeam.png")}
	dummyCursors[.SIZE_VERTICAL] = {hotX=6, hotY=12, data=LI.newImageData("gfx/cursor_sizens.png")}

	imageBoxGradient = LG.newImage("gfx/boxGradient.png")
	imageChecker     = LG.newImage("gfx/checker.png") ; imageChecker.setWrap!(.REPEAT, .REPEAT) ; imageChecker.setFilter!(.NEAREST, .NEAREST)
	imageGradient    = LG.newImage("gfx/gradient.png")
	imageIcons16     = LG.newImage("gfx/icons.png")
	imageNormal      = LG.newImage("gfx/normal.png")
	imagePixel       = LG.newImage("gfx/pixel.png")
	imageRainbow     = LG.newImage("gfx/rainbow.png")

	!load "src/icons"
	generateIcons()

	do {
		local info: LF.FileInfo

		for LF.getDirectoryItems"gfx/particles" {
			local found, name = matchPattern(it, "^(.+)%.png$")

			if found {
				local path      = "gfx/particles/"..it
				local imageData = LF.newFileData(path)
				local image     = LG.newImage(path)

				particleImages[cast(string)name] = {
					fullPath = format("%s/%s", getAppDirectory(), path),
					fileData = imageData,
					image    = image,
					bundled  = not DEV, -- Count all files as unbundled in DEV mode.
					modified = (LF.getInfo(path, info) ~= nil and info.modtime ~= nil) ? cast(int)info.modtime : -1,
				}

				guiImages[cast(string)name] = image

				insert(particleImageNames, cast(string)name)

				--[[ Black/white to transparent/white.
				local img = LI.newImageData(path)
				img.mapPixel!((x,y:int, r,g,b,a:float) -> (r,g,b,a:float) {
					return 1, 1, 1, r
				})
				img.encode!(LI.ImageFormat.PNG, it)
				--]]
			}
		}
	}

	do {
		local ok, gotError, _app = loadWorkspace("workspace")
		if ok {
			app = _app
			assert(app.projects[1] ~= NULL)
		} else {
			if gotError  setErrorText("Could not load previous workspace")
			addNewProject()
		}

		for app.projects {
			updateParticles(it)
			updateBackgroundTexture(it)
		}

		local w = app.windowWidth  ?: 1400
		local h = app.windowHeight ?: 800

		local _, _, flags = LW.getMode()
		flags.resizable   = true
		local maximized   = false

		if ok and app.gotWindowInfo {
			flags.x   = app.windowX      ?: cast(int) flags.x
			flags.y   = app.windowY      ?: cast(int) flags.y
			w         = app.windowWidth  ?: w
			h         = app.windowHeight ?: h
			maximized = app.windowMaximized

			flags.centered = not (app.windowX or app.windowY)
			if flags.centered {
				flags.x = nil
				flags.y = nil
			}

		} else {
			flags.x        = nil
			flags.y        = nil
			flags.centered = true
		}

		!if GIF_RECORDING_MODE {
			w              = 1000
			h              = 500
			flags.x        = nil
			flags.y        = nil
			flags.centered = true
			maximized      = false
		}

		app.windowWidth  = w
		app.windowHeight = h

		LW.updateMode(w, h, flags)
		if maximized  LW.maximize()
	}

	LW.setVSync(app.showStats == STATS_ALL ? 0 : 1)

	setupGuiFrames()
	setupGuiCallbacks()
	guiState.refreshAll!()

	setCurrentProject(app.currentProjectIndex, force=true)

	for projectsToOpen {
		local ok, project, isNew = openProject(it)
		if ok and not isNew  updateParticles(project)
	}
}



local onFileDropped :: (file:LF.DroppedFile) {
	local fullPath = Path(file.getFilename!()).toString!()
	local _, ext   = matchPattern(fullPath, "%.(%w+)$")

	if ext == "hotparticles" {
		openProject(fullPath)
		return
	}

	if pcall_newImage(file) == NULL {
		setErrorText("Could not load '%s'", fullPath)
		return
	}

	local currentProject, system = getCurrentProjectAndSystem()
	setTexturePath(currentProject, system, fullPath)
}



local onKeyPressed :: (key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) {
	local mod            = getModifierKey()
	local modAndKey      = combineKeyAndModifier(mod, key)
	local currentProject = app.projects[app.currentProjectIndex]
	local system         = currentProject.systems[currentProject.systemIndex]

	-- Global keys.
	if not LM.isGrabbed()  if modAndKey == {
		case "c-q":
			pushQuitEvent()
			return

		case "c-f10":
			saveWorkspace()
			LE.restart()
			return

		case "f1":
			app.showStats = (app.showStats + 1) % STATS_COUNT
			LW.setVSync(app.showStats == STATS_ALL ? 0 : 1)
			scheduleSaveWorkspace()
			return

		case "f2":
			app.showPanelNumbers = not app.showPanelNumbers
			scheduleSaveWorkspace()
			return

		case "f8":
			!if GIF_RECORDING_MODE {
				gifRecordingActive = not gifRecordingActive
				log("Recording gif: %s", toString(gifRecordingActive))

				if gifRecordingActive {
					gifRecordingFrame     = 1
					gifRecordingName      = os.getDate("%Y%m%d_%H%M%S")
					gifRecordingDirectory = "gif_"..gifRecordingName
					LF.createDirectory(gifRecordingDirectory)

				} else {
					log("Recorded frames: %d", gifRecordingFrame-1)

					local ok, err, code, cmd = os.execute(loadParams().pathMagick, {
						"convert",
						"-delay", format("%d", GIF_FRAME_DELAY), -- 100th of a second.
						format("%s/%s/frame*.png", getSaveDirectory(), gifRecordingDirectory),
						"-coalesce",    -- Fill out frames.
						"-deconstruct", -- Find areas changed between frames.
						"-loop", "0",   -- Loop forever.
						format("%s/screenshots/%s.gif", getSaveDirectory(), gifRecordingName),
					})
					if ok  print(cmd)

					if not ok {
						setErrorText("Failed executing '%s': %s", cmd, err)
					} elseif code ~= 0 {
						setErrorText("Failed making gif (Error %d)", code)
					} else {
						local fullPath = format("%s/%s", getSaveDirectory(), gifRecordingDirectory)
						print("Gif: "..fullPath)
						-- love.system.openURL("file://"..fullPath)
					}
				}
			}
			return

		case "f12": !through
		case "s-f12":
			!if DEV  LG.captureScreenshot([mod] (screenshot:LI.ImageData) {
				if mod == ModifierKey.S  overlayDummyCursor(screenshot)
				LF.createDirectory("screenshots")
				screenshot.encode!(LI.ImageFormat.PNG, os.getDate("screenshots/%Y%m%d_%H%M%S.png"))
			})
			return

		case "c-s-f12":
			!if DEV  love.system.openURL(format("file://%s/screenshots", getSaveDirectory()))
			return
	}

	if guiState.onKeyPressed!(key, scancode, isRepeat)  return
	if LM.isGrabbed()  return

	-- Context-sensitive global keys.
	if key == "escape" {
		if popPanel()  return

		local BUTTONS: []gui.Button : {{label="Exit"},{label="Cancel"}}

		pushTempChoiceDialog("", "", BUTTONS, submitIndex=1, (i:int) {
			if i == 1  pushQuitEvent()
		})

		return
	}

	if modAndKey == {
		case "r":
			for currentProject.systems {
				it.particles.stop!()
				it.particles.reset!()
			}
			return

		case "p":
			showParticlePath = (showParticlePath + 1) % 3
			setMessageText(
				showParticlePath == 0 ? "Hide particle path" :
				showParticlePath == 1 ? "Show particle path (average)" :
				showParticlePath == 2 ? "Show particle path (random)" :
				""
			)
			return

		case "space":
			for currentProject.systems {
				local ps     = it.particles
				local active = ps.isActive!()
				if not active  ps.start!() -- Needed for emit() to work.
				ps.emit!(1)
				if not active  ps.stop!()
			}
			return

		case "c-s-o":
			local ok, dir = Path(app.projects[app.currentProjectIndex].path).getDirectory!()
			if ok  love.system.openURL("file://"..dir)
			return
	}

	if panelStack  return

	-- Keys in normal view.
	if modAndKey == {
		case "c-s":      if currentProject.fileIsSaved  saveProject(currentProject, currentProject.path, overwrite=true)  else  showSaveProjectAsDialog()
		case "c-s-s":    showSaveProjectAsDialog()
		case "c-e":      pushPanel("exportProject")
		case "c-s-e":    tryExportFiles(quick=true)
		case "c-o":      showOpenProjectDialog()
		case "c-s-t":    openRecentProject()
		case "c-n":      addNewProject() ; guiState.refreshRecursively!("projects") ; setCurrentProject(#app.projects) ; scheduleSaveWorkspace()
		case "c-w":      if not (#app.projects == 1 and not (app.projects[1].path or app.projects[1].edited))  confirmCloseProject(app.currentProjectIndex)

		case "tab":      setCurrentSystem ((currentProject.systemIndex - 0) % #currentProject.systems + 1)
		case "s-tab":    setCurrentSystem ((currentProject.systemIndex - 2) % #currentProject.systems + 1)
		case "c-tab":    setCurrentProject((app.currentProjectIndex    - 0) % #app.projects    + 1)
		case "c-s-tab":  setCurrentProject((app.currentProjectIndex    - 2) % #app.projects    + 1)

		case "h":        system.visible = not system.visible

		case "c-p":      !if DEV  guiState.setActive!("main", not guiState.getElement!("main").active)

		case "c-delete": confirmDeleteSystem(currentProject.systemIndex)
		case "c-d":      duplicateSystem(currentProject.systemIndex)

		case "c-z":      undo()
		case "c-s-z":    redo()

		case "c-k":      pushPanel("preferences")

		case "f10":      showMainMenu()

		case "c-pagedown":
			if currentProject.systems[currentProject.systemIndex+1] ~= NULL {
				local i1 = currentProject.systemIndex
				local i2 = currentProject.systemIndex + 1

				recordChange("", "Reorder particle systems", nil,
					[i1, i2] (project:Project) {  project.systems[i1], project.systems[i2] = project.systems[i2], project.systems[i1] ; project.systemIndex = i2  },
					[i1, i2] (project:Project) {  project.systems[i1], project.systems[i2] = project.systems[i2], project.systems[i1] ; project.systemIndex = i1  },
					--[[  ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(project.systemIndex, force=true)  }
				)
			}
		case "c-pageup":
			if currentProject.systemIndex > 1 {
				local i1 = currentProject.systemIndex
				local i2 = currentProject.systemIndex - 1

				recordChange("", "Reorder particle systems", nil,
					[i1, i2] (project:Project) {  project.systems[i1], project.systems[i2] = project.systems[i2], project.systems[i1] ; project.systemIndex = i2  },
					[i1, i2] (project:Project) {  project.systems[i1], project.systems[i2] = project.systems[i2], project.systems[i1] ; project.systemIndex = i1  },
					--[[  ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(project.systemIndex, force=true)  }
				)
			}

		case "c-s-pagedown":
			if app.projects[app.currentProjectIndex+1] ~= NULL {
				local i1 = app.currentProjectIndex
				local i2 = app.currentProjectIndex + 1

				app.projects[i1], app.projects[i2] = app.projects[i2], app.projects[i1]
				app.currentProjectIndex            = i2

				guiState.refreshRecursively!("projects")
			}
		case "c-s-pageup":
			if app.currentProjectIndex > 1 {
				local i1 = app.currentProjectIndex
				local i2 = app.currentProjectIndex - 1

				app.projects[i1], app.projects[i2] = app.projects[i2], app.projects[i1]
				app.currentProjectIndex            = i2

				guiState.refreshRecursively!("projects")
			}
	}
}

local onKeyReleased :: (key:LK.KeyConstant, scancode:LK.Scancode) {
	guiState.onKeyReleased!(key, scancode)
}

local onTextInput :: (text:string) {
	if guiState.onTextInput!(text)  return
}

local macCtrlClick = false

local onMousePressed :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch         return
	if LM.isGrabbed()  return

	!if GIF_RECORDING_MODE  if gifRecordingActive {
		insert(visualMousePresses, cast(VisualMousePress) {x=mx, y=my})
	}

	-- @Cleanup: Make sure this is actually needed:
	if isMac and mbutton == 1 and LK.isDown("lctrl", "rctrl") {
		if LM.isDown(2)  return -- Make sure the user can't control-click while already right-clicking as those methods should result in the same action. :MacRightClick
		mbutton      = 2
		macCtrlClick = true
	} elseif macCtrlClick and mbutton == 2 {
		return -- :MacRightClick
	}

	if guiState.onMousePressed!(mx, my, mbutton, presses)  return

	local showWorld = getVisibilityFlags()
	if not showWorld  return

	if mbutton == 1 {
		isPositioningParticles = true
		LM.setGrabbed(true)
		LK.setKeyRepeat(false)
		onMouseMoved(mx,my, 0,0, false)

	} elseif mbutton == 2 {
		local ITEMS :: {"Reset emitter position"}

		guiState.showContextMenu!(ITEMS, (choice:int) {
			if choice == {
				case 1: moveEmittersTo(app.projects[app.currentProjectIndex], 0, 0, commit=true, instant=true)
			}
		})
	}
}

local onMouseMoved :: (mx,my:int, dx,dy:int, isTouch:bool) {
	if isTouch  return

	if isPositioningParticles {
		local currentProject = app.projects[app.currentProjectIndex]

		local x = (mx - (LG.getWidth()+MAIN_PANEL_WIDTH)/2) / currentProject.zoom
		local y = (my - (LG.getHeight()                )/2) / currentProject.zoom

		moveEmittersTo(currentProject, x, y, commit=false)
		return
	}

	guiState.onMouseMoved!(mx, my, dx, dy)
}

local onMouseReleased :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch  return

	if macCtrlClick and mbutton == 1 {
		mbutton      = 2
		macCtrlClick = false
	}

	if isPositioningParticles and mbutton == 1 {
		isPositioningParticles = false

		local currentProject = app.projects[app.currentProjectIndex]
		moveEmittersTo(currentProject, currentProject.emitterPlacementX, currentProject.emitterPlacementY, commit=true)

		LM.setGrabbed(false)
		LK.setKeyRepeat(true)

		guiState.onMouseMoved!(mx, my, 0, 0)

		return
	}

	guiState.onMouseReleased!(mx, my, mbutton, presses)
}

local onMouseWheel :: (dx,dy:int) {
	if LM.isGrabbed()                  return
	if guiState.onMouseWheel!(dx, dy)  return
	if not dy                          return

	local showWorld = getVisibilityFlags()
	if not showWorld  return

	local mx, my = LM.getPosition()
	if guiState.getTopmostActiveModal!() ~= NULL or guiState.isOverGui!(mx, my)  return

	local mod = getModifierKey()
	if mod ~= .NONE  return

	local currentProject = app.projects[app.currentProjectIndex]
	local zoomLevel      = currentProject.zoomLevel
	local now            = LT.getTime()

	for 1, math.abs(dy) {
		-- Stick slightly to 100% zoom.
		if zoomLevel == 0 and now-zoomTime < 0.15  break

		zoomLevel = clampZoomLevel(currentProject, zoomLevel+math.getSign(dy))
	}

	zoomTime = now

	if zoomLevel == currentProject.zoomLevel  return

	currentProject.zoomLevel = zoomLevel
	limitZoomLevel(currentProject)

	setActionText("Zoom: %d%%", currentProject.zoomTarget * 100)
}



local onUpdate :: (dt:float) {
	updateEventCount += 1

	!if GIF_RECORDING_MODE  if gifRecordingActive  dt = GIF_FRAME_DELAY / 100

	if freezeDtThisFrame {
		dt                = 0
		freezeDtThisFrame = false
	} else {
		local _, _, flags = LW.getMode()
		-- This will make things go *really* slow if it's the performance that's
		-- making dt high. It's probably not that much of an issue though.
		if flags.refreshrate and dt > 1/10  dt = 1/flags.refreshrate
	}

	local mod  = getModifierKey()
	local slow = not guiState.focusId and mod == .NONE and LK.isDown"g"
	local fast = not guiState.focusId and mod == .NONE and LK.isDown"f"

	local dtForParticles      = dt / (slow ? 20 : 1)
	local particleUpdateCount = fast ? 10 : 1

	timeForAnimationPreview += particleUpdateCount * dtForParticles

	local project           = app.projects[app.currentProjectIndex]
	local showWorld         = getVisibilityFlags()
	local doUpdateParticles = showWorld and (forceParticleUpdates or guiState.getTopmostActiveModal!() == NULL)

	if doUpdateParticles {
		local systemsActive  = false

		local time = LT.getTime()
		for project.systems  it.particles.update!(dtForParticles)
		particleUpdateTime = LT.getTime()-time

		project.particleEmitDuration += dtForParticles
		particleEmitDurationTotal    += dtForParticles

		for 2, particleUpdateCount {
			project.particleEmitDuration += dtForParticles
			for project.systems  it.particles.update!(dtForParticles)
		}

		for system: project.systems {
			local ps      = system.particles
			systemsActive = systemsActive or ps.isActive!() or ps.getCount!() > 0

			if ps.getCount!() > 0.95 * ps.getBufferSize!() {
				if updateBufferSize(system)  setActionText("Increased buffer size")
			}
		}

		if systemsActive {
			-- Make sure continuous emitters are always active.
			for system: project.systems {
				if system.psEmitterContinuous  system.particles.start!()
			}

		} else {
			project.particleEmitDuration = 0

			for system: project.systems {
				system.particles.start!()

				-- Note: Kick-starting may make things look a bit weird if the
				-- emitter has a too short lifetime compared to the particles.
				if system.kickStartStepsEnabled and system.kickStartSteps {
					local kickStartDt = getKickStartDt(system)
					for i = 1, system.kickStartSteps  system.particles.update!(kickStartDt)
				}

				system.particles.emit!(system.kickStartEmitEnabled ? system.kickStartEmit : 0)
			}
		}
	}

	if workspaceSaveScheduled {
		workspaceSaveDelay -= dt
		if workspaceSaveDelay <= 0  saveWorkspace()
	}

	if scheduleRecreateCanvases  createCanvases()

	if doUpdateParticles and not isPositioningParticles {
		local MOVEMENT_BASE :: 250

		-- project.movementSpeed = LK.isDown"." ? .04 : 1 -- DEBUG

		local lastMovementPhaseAbs  = project.movementPhaseAbs
		project.movementPhase      +=         (project.movementSpeed) * dt
		project.movementPhaseAbs   += math.abs(project.movementSpeed) * dt

		using project.movementPreset
		if !complete project.movementPreset == {
			case NONE:
				-- void

			case CIRCLE:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					project,
					MOVEMENT_BASE * (project.movementScaleXEnabled ? project.movementScaleX : 0) * math.cos(angle),
					MOVEMENT_BASE * (project.movementScaleYEnabled ? project.movementScaleY : 0) * math.sin(angle),
					commit = false
				)

			case EIGHT:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					project,
					MOVEMENT_BASE   * (project.movementScaleXEnabled ? project.movementScaleX : 0) * math.cos(angle),
					MOVEMENT_BASE/2 * (project.movementScaleYEnabled ? project.movementScaleY : 0) * math.sin(angle*2),
					commit = false
				)

			case IRREGULAR:
				if math.floor(project.movementPhaseAbs) ~= math.floor(lastMovementPhaseAbs) or lastMovementPhaseAbs == 0 {
					local dx       = project.movementPoint3X - project.movementPoint4X
					local dy       = project.movementPoint3Y - project.movementPoint4Y
					local angleOld = math.atan(-dy, -dx)

					project.movementPoint1X = project.movementPoint4X
					project.movementPoint1Y = project.movementPoint4Y
					project.movementPoint2X = project.movementPoint4X - dx
					project.movementPoint2Y = project.movementPoint4Y - dy
					project.movementPoint4X = .8*MOVEMENT_BASE * (2*love.math.random()-1)
					project.movementPoint4Y = .8*MOVEMENT_BASE * (2*love.math.random()-1)

					dx             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					dy             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					local angleNew = math.atan(dy, dx)

					if math.angleDistance(angleNew, angleOld) > math.TAU/4 {
						dx = -dx
						dy = -dy
					}

					project.movementPoint3X = project.movementPoint4X + dx
					project.movementPoint3Y = project.movementPoint4Y + dy
				}

				local phase    = project.movementPhaseAbs % 1
				local phaseOld =     math.sin  (phase * math.TAU/4)
				local phaseNew = 1 - math.cos  (phase * math.TAU/4)
				local phaseMid = 1 - math.cos01(phase * math.TAU/2)

				moveEmittersTo(
					project,
					(project.movementScaleXEnabled ? project.movementScaleX : 0) * math.lerp(
						math.lerp(project.movementPoint1X, project.movementPoint2X, phaseOld),
						math.lerp(project.movementPoint3X, project.movementPoint4X, phaseNew),
						phaseMid
					),
					(project.movementScaleYEnabled ? project.movementScaleY : 0) * math.lerp(
						math.lerp(project.movementPoint1Y, project.movementPoint2Y, phaseOld),
						math.lerp(project.movementPoint3Y, project.movementPoint4Y, phaseNew),
						phaseMid
					),
					commit = false
				)
		}
	}

	project.zoom = math.moveTowards(
		project.zoom,
		project.zoomTarget,
		math.abs(project.zoomTarget - project.zoomSource) * dt / 0.05
	)

	guiState.update!(dt)
	hotLoader.update(dt)

	!if GIF_RECORDING_MODE  for < visualMousePresses {
		it.progress += dt/.20
		if it.progress >= 1  remove(visualMousePresses, itIndex)
	}
}



local getVisibilityFlags :: () -> bool, bool, bool, bool, bool, bool {
	static wasHoveringTextureOffset,    hoverTimeTextureOffset    = false, -9999.00
	static wasHoveringAreaDistribution, hoverTimeAreaDistribution = false, -9999.00
	static wasHoveringEmitterRelated,   hoverTimeEmitterRelated   = false, -9999.00

	local isHoveringTextureOffset
		=  math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("textureOffsetX").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("textureOffsetY").id

	local isHoveringAreaDistribution
		=  math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("areaDistribution").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("areaAngle").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("areaDx").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("areaDy").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("emitterOffsetX").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("emitterOffsetY").id

	local isHoveringEmitterRelated
		=  isHoveringAreaDistribution
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("emitterMovement").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("emitterMovementSx").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("emitterMovementSy").id
		or math.max(guiState.activeId, guiState.hoveredId) == guiState.getElement!("emitterMovementSpeed").id

	if isHoveringTextureOffset ~= wasHoveringTextureOffset {
		wasHoveringTextureOffset = isHoveringTextureOffset
		hoverTimeTextureOffset   = LT.getTime()
	}
	if isHoveringAreaDistribution ~= wasHoveringAreaDistribution {
		wasHoveringAreaDistribution = isHoveringAreaDistribution
		hoverTimeAreaDistribution   = LT.getTime()
	}
	if isHoveringEmitterRelated ~= wasHoveringEmitterRelated {
		wasHoveringEmitterRelated = isHoveringEmitterRelated
		hoverTimeEmitterRelated   = LT.getTime()
	}

	local DELAY :: 4/60
	local showTextureOffset    = (isHoveringTextureOffset    and LT.getTime() - hoverTimeTextureOffset    > DELAY)
	local showAreaDistribution = (isHoveringAreaDistribution and LT.getTime() - hoverTimeAreaDistribution > DELAY)
	local showAnimationFrames  = guiState.getElement!("animation").active
	local showTexturePreview   = textureBrowserPreviewImage ~= NULL
	local showEmitterPosition  = (isHoveringEmitterRelated   and LT.getTime() - hoverTimeEmitterRelated   > DELAY)
	local showWorld            = not (showTextureOffset or showAnimationFrames or showTexturePreview)

	static didShowWorld = true

	if showWorld ~= didShowWorld {
		didShowWorld           = showWorld
		forcePixelatedTextures = not showWorld -- A bit misplaced... @Cleanup
		updateImageFilters()
	}

	return showWorld, showTextureOffset, showAreaDistribution, showAnimationFrames, showTexturePreview, showEmitterPosition
}

local onDraw :: () {
	static statsAll:   LG.Stats
	static statsWorld: LG.Stats

	local ww, wh  = LG.getDimensions()
	local project = app.projects[app.currentProjectIndex]

	local showWorld, showTextureOffset, showAreaDistribution, showAnimationFrames, showTexturePreview, showEmitterPosition = getVisibilityFlags()

	local bgR, bgG, bgB      = hsvToRgb(project.bgColor)
	local _, _, bgBrightness = rgbToHsp(bgR, bgG, bgB)

	LG.reset()

	-- World.
	do {
		local midX = (ww-MAIN_PANEL_WIDTH)/2
		local midY = wh/2

		LG.setCanvas(canvasWorld)

		LG.clear(bgR, bgG, bgB, 1)

		-- Background pattern.
		if math.abs(project.bgChecker) > .9/255 {
			if project.bgChecker > 0
				LG.setColor(1, 1, 1, project.bgChecker)
			else
				LG.setColor(0, 0, 0, -project.bgChecker)
			gui.drawChecker(0, 0, ww-MAIN_PANEL_WIDTH, wh, project.bgSize/4)
		}

		-- Background image.
		if project.currentBgImage ~= NULL {
			local scale = project.bgScale
			if not project.pixelateWorld  scale *= project.zoom

			local iw, ih = project.currentBgImage.image.getDimensions!()

			static quad: LG.Quad = NULL
			if quad == NULL  quad = LG.newQuad(0,0, 1,1, 1,1)

			quad.setViewport!(
				x  = project.bgRepeatX ? -midX/scale - iw/2 : 0,
				y  = project.bgRepeatY ? -midY/scale - ih/2 : 0,
				w  = project.bgRepeatX ? 2*midX/scale       : iw,
				h  = project.bgRepeatY ? 2*midY/scale       : ih,
				sw = iw,
				sh = ih
			)

			LG.setColor(1, 1, 1)
			LG.draw(
				project.currentBgImage.image, quad,
				x  = project.bgRepeatX ? 0 : midX-iw/2*scale,
				y  = project.bgRepeatY ? 0 : midY-ih/2*scale,
				r  = 0,
				sx = scale
			)
		}

		-- Particles.
		if showWorld {
			LG.translate(midX, midY)
			if not project.pixelateWorld  LG.scale(project.zoom)

			local time = LT.getTime()
			LG.setColor(1, 1, 1)

			for system: project.systems  if system.visible {
				local shaderAndInfo = system.currentShader
				local shader        = shaderAndInfo ~= NULL ? shaderAndInfo.shader : NULL

				if shader ~= NULL {
					if shader.hasUniform!"hotParticlesTime"         shader.send!("hotParticlesTime",        particleEmitDurationTotal)
					if shader.hasUniform!"hotParticlesEmitterTime"  shader.send!("hotParticlesEmitterTime", project.particleEmitDuration)
				}

				LG.setShader(shader)
				LG.setBlendMode(system.blendMode)
				LG.draw(system.particles)
			}

			particleDrawTime = LT.getTime() - time -- Not sure how accurate this actually is. This value is still very low even while the actual FPS is tanking a lot.
			-- !if DEV  LG.getStats(statsWorld)

			LG.setShader()
			LG.setBlendMode(.ALPHA)

			if showAreaDistribution {
				local system = project.systems[project.systemIndex]
				local x,  y  = system.particles.getPosition!()
				local dx     = system.psEmissionAreaDxEnabled    ? system.psEmissionAreaDx * system.scaleSpace : 0
				local dy     = system.psEmissionAreaDyEnabled    ? system.psEmissionAreaDy * system.scaleSpace : 0
				local angle  = system.psEmissionAreaAngleEnabled ? system.psEmissionAreaAngle                  : 0

				LG.pushAll()
				LG.translate(x, y)
				LG.rotate(angle)
				LG.setLineWidth(math.max(8/project.zoom, (project.pixelateWorld ? 1 : 0)))
				LG.setColor(1, 0, 0, .6)

				if !complete system.psEmissionAreaDistribution == {
					case .NONE:
						-- void

					case .ELLIPSE:
						LG.ellipse(LG.DrawMode.FILL, 0,0, dx,dy, 64)

					case .UNIFORM:
						LG.rectangle(LG.DrawMode.FILL, -dx,-dy, 2*dx, 2*dy)

					case .BORDER_ELLIPSE:
						LG.ellipse(LG.DrawMode.LINE, 0,0, dx,dy, 64)

					case .BORDER_RECTANGLE:
						LG.rectangle(LG.DrawMode.LINE, -dx,-dy, 2*dx,2*dy)

					case .NORMAL:
						local STDDEV_IN_IMAGE :: .1411132813
						local iw, ih = imageNormal.getDimensions!()
						local sx     = dx / (iw * STDDEV_IN_IMAGE)
						local sy     = dy / (ih * STDDEV_IN_IMAGE)
						LG.draw(imageNormal, 0,0, 0, sx,sy, iw/2,ih/2)
				}

				LG.pop()
			}

			if showEmitterPosition {
				local x, y = project.systems[project.systemIndex].particles.getPosition!()
				local lw   = math.max(2/project.zoom, (project.pixelateWorld ? 1 : 0))
				local len  = 6 * lw

				LG.setColor(1, 0, 0, .6)
				LG.setLineWidth(lw)
				LG.line(x-len, y, x+len, y)
				LG.line(x, y-len, x, y+len)
				LG.setLineWidth(1)
			}

			if showParticlePath {
				-- Some code here is ported from LÖVE.
				local MAX_SEGMENTS       :: 1000
				local RANDOM_LINES       :: 8 -- @Incomplete: Add a @Setting for how long these are visible as one frame may possibly be too short?
				local RATE_WHEN_NO_VSYNC :: 250

				local system = project.systems[project.systemIndex]
				local ps     = system.particles

				local direction0 = ps.getDirection!()
				local spread     = ps.getSpread!()

				local accRadialMin,  accRadialMax  = ps.getRadialAcceleration!()
				local accTangentMin, accTangentMax = ps.getTangentialAcceleration!()
				local dampMin,       dampMax       = ps.getLinearDamping!()
				local lifeMin,       lifeMax       = ps.getParticleLifetime!()
				local speedMin,      speedMax      = ps.getSpeed!()

				local accXmin, accYmin, accXmax, accYmax = ps.getLinearAcceleration!()

				local areaDistribution, areaDx, areaDy, areaAngle, areaRelative = ps.getEmissionArea!()

				local _, _, flags = LW.getMode()

				LG.setColor(.3, .3, 1)

				for 1, (showParticlePath == 1 ? 1 : RANDOM_LINES) {
					local accRadial, accTangent, accX, accY, damp, life, speed, direction: float = NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL

					if showParticlePath == 1 {
						accRadial  = (accRadialMin  + accRadialMax ) / 2
						accTangent = (accTangentMin + accTangentMax) / 2
						accX       = (accXmin       + accXmax      ) / 2
						accY       = (accYmin       + accYmax      ) / 2
						damp       = (dampMin       + dampMax      ) / 2
						life       = (lifeMin       + lifeMax      ) / 2
						speed      = (speedMin      + speedMax     ) / 2
						direction  = direction0
					} else {
						accRadial  = math.getRandom(accRadialMin,  accRadialMax)
						accTangent = math.getRandom(accTangentMin, accTangentMax)
						accX       = math.getRandom(accXmin,       accXmax)
						accY       = math.getRandom(accYmin,       accYmax)
						damp       = math.getRandom(dampMin,       dampMax)
						life       = math.getRandom(lifeMin,       lifeMax)
						speed      = math.getRandom(speedMin,      speedMax)
						direction  = direction0 + spread * math.getRandom(-.5, +.5)
					}

					local dt = (
						app.showStats == STATS_ALL
						? 1 / RATE_WHEN_NO_VSYNC
						: 1 / (flags.refreshrate ?: 60)
					)

					local segments = math.round(life / dt)

					segments = math.clamp(segments, 2, MAX_SEGMENTS)
					dt       = life / segments

					local x0, y0 = ps.getPosition!()

					local x = x0
					local y = y0

					if showParticlePath == 2 {
						if !complete areaDistribution == {
							case .NONE:
								-- void

							case .ELLIPSE:
								local c      = math.cos(areaAngle)
								local s      = math.sin(areaAngle)
								local randX  = math.getRandom(-1.0, 1.0)
								local randY  = math.getRandom(-1.0, 1.0)
								local min    = areaDx * randX * math.sqrt(1 - (randY^2)/2)
								local max    = areaDy * randY * math.sqrt(1 - (randX^2)/2)
								x           += c*min - s*max
								y           += s*min + c*max

							case .UNIFORM:
								local c      = math.cos(areaAngle)
								local s      = math.sin(areaAngle)
								local randX  = math.getRandom(-areaDx, areaDx)
								local randY  = math.getRandom(-areaDy, areaDy)
								x           += c*randX - s*randY
								y           += s*randX + c*randY

							case .BORDER_ELLIPSE:
								local c     = math.cos(areaAngle)
								local s     = math.sin(areaAngle)
								local rand  = math.getRandom(0, math.TAU)
								local min   = math.cos(rand) * areaDx
								local max   = math.sin(rand) * areaDy
								x          += c*min - s*max
								y          += s*min + c*max

							case .BORDER_RECTANGLE:
								local c     = math.cos(areaAngle)
								local s     = math.sin(areaAngle)
								local range = 2 * (areaDx + areaDy)
								local randX = math.getRandom(-range, range)
								local randY = areaDy * 2

								if randX < -randY {
									local min  = randX + randY + areaDx
									x         += c*min - s*-areaDy
									y         += s*min + c*-areaDy
								} elseif randX < 0 {
									local max  = randX + areaDy
									x         += c*-areaDx - s*max
									y         += s*-areaDx + c*max
								} elseif randX < randY {
									local max  = randX - areaDy
									x         += c*areaDx - s*max
									y         += s*areaDx + c*max
								} else {
									local min  = randX - randY - areaDx
									x         += c*min - s*areaDy
									y         += s*min + c*areaDy
								}

							case .NORMAL:
								local getRandomNormal :: (stddev:float) -> float {
									static lastRandomNormal: float = NULL

									if lastRandomNormal ~= NULL {
										local r          = lastRandomNormal
										lastRandomNormal = NULL
										return r * stddev
									}

									local r   = math.sqrt(-2 * math.log(1-math.getRandom()))
									local phi = math.TAU * (1-math.getRandom())

									lastRandomNormal = r * math.cos(phi)
									return r * math.sin(phi) * stddev
								}

								local c      = math.cos(areaAngle)
								local s      = math.sin(areaAngle)
								local randX  = getRandomNormal(areaDx)
								local randY  = getRandomNormal(areaDy)
								x           += c*randX - s*randY
								y           += s*randX + c*randY
						}

						if areaRelative  direction += math.atan(y-y0, x-x0)
					}

					local points = {x, y} -- @Memory

					local speedX = speed * math.cos(direction)
					local speedY = speed * math.sin(direction)

					for 1, segments {
						-- @Accuracy: This all seem to break to some extent for extreme values (at least for damping).
						local prevSpeedX = speedX
						local prevSpeedY = speedY

						speedX, speedY = math.damp(speedX,speedY, 0,0, damp, dt)

						x += (prevSpeedX+speedX)/2 * dt
						y += (prevSpeedY+speedY)/2 * dt

						local originAngle = math.atan(y-y0, x-x0)

						speedX += dt * accX
						speedY += dt * accY
						speedX += dt * accRadial  * math.cos(originAngle)
						speedY += dt * accRadial  * math.sin(originAngle)
						speedX += dt * accTangent * math.cos(originAngle + math.TAU/4)
						speedY += dt * accTangent * math.sin(originAngle + math.TAU/4)

						insert(points, x)
						insert(points, y)
					}

					LG.line(points)
					-- LG.points(points) -- DEBUG
				}
			}

			if project.regionEnabled and project.regionWidth and project.regionHeight {
				local lw :: 2

				if bgBrightness < .5
					LG.setColor(1, 1, 1, .7)
				else
					LG.setColor(0, 0, 0, .7)

				LG.setLineWidth(lw)
				LG.rectangle(LG.DrawMode.LINE, -(project.regionWidth+lw)/2, -(project.regionHeight+lw)/2, project.regionWidth+lw, project.regionHeight+lw)
				LG.setLineWidth(1)
			}

			--[[ DEBUG
			LG.setColor(1, 1, 1, .15)
			LG.line(project.movementPoint1X, project.movementPoint1Y, project.movementPoint2X, project.movementPoint2Y)
			LG.line(project.movementPoint2X, project.movementPoint2Y, project.movementPoint3X, project.movementPoint3Y)
			LG.line(project.movementPoint3X, project.movementPoint3Y, project.movementPoint4X, project.movementPoint4Y)
			LG.setColor(1, 1, 1, .3)
			LG.print("1", project.movementPoint1X, project.movementPoint1Y)
			LG.print("2", project.movementPoint2X, project.movementPoint2Y)
			LG.print("3", project.movementPoint3X, project.movementPoint3Y)
			LG.print("4", project.movementPoint4X, project.movementPoint4Y)
			--]]

			LG.reset()
		}
	}

	-- GUI.
	do {
		LG.setCanvas(canvasGui)
		LG.clear(0, 0, 0, 0)

		LG.setFont(fontNormal)

		-- Texture or animation frames.
		if showTextureOffset or showAnimationFrames or showTexturePreview {
			local PADDING :: 20

			local system = project.systems[project.systemIndex]
			local image  = showTexturePreview ? textureBrowserPreviewImage : system.currentImage.image
			local iw, ih = image.getDimensions!()

			local scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/iw, (wh-2*PADDING)/ih)

			local x0 = (ww - iw*scale + MAIN_PANEL_WIDTH) // 2
			local y0 = (wh - ih*scale                   ) // 2

			if showTextureOffset or showTexturePreview {
				local w = iw
				local h = ih

				if showTextureOffset and system.frames {
					local quads        = system.particles.getQuads!()
					local quad         = getAnimationPreviewQuad(system.particles, quads)
					local _, _, qw, qh = quads[1].getViewport!()

					w = math.round(qw)
					h = math.round(qh)

					scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/w, (wh-2*PADDING)/h)

					x0 = (ww - w*scale + MAIN_PANEL_WIDTH) // 2
					y0 = (wh - h*scale                   ) // 2

					LG.setColor(1, 1, 1)
					LG.draw(image, quad, x0, y0, 0, scale)

				} else {
					LG.setColor(1, 1, 1)
					LG.draw(image, x0, y0, 0, scale)
				}

				if showTextureOffset {
					local HALF_WIDTH  :: 3
					local HALF_LENGTH :: 20
					local x = math.round(x0 + w*scale*system.textureOffsetX)
					local y = math.round(y0 + h*scale*system.textureOffsetY)
					LG.setColor(0, 0, 0, .9)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH-1, y-HALF_LENGTH-1, 2*HALF_WIDTH+2, 2*HALF_LENGTH+2)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH-1, y-HALF_WIDTH-1, 2*HALF_LENGTH+2, 2*HALF_WIDTH+2)
					LG.setColor(1, 1, 1)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH, y-HALF_LENGTH, 2*HALF_WIDTH, 2*HALF_LENGTH)
					LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH, y-HALF_WIDTH, 2*HALF_LENGTH, 2*HALF_WIDTH)
				}
			}

			if showAnimationFrames {
				LG.setColor(0, 0, 0, .2)
				gui.drawBoxGradient(x0, y0, math.round(iw*scale), math.round(ih*scale), bw=20, drawCenter=false)

				LG.setColor(1, 1, 1)
				LG.draw(image, x0, y0, 0, scale)

				if system.frames {
					local drawFrame :: (x0,y0:int, scale:float, frame:AnimationFrame, highlight:bool) {
						local x1 = math.round(x0 + scale * (frame.x          ))
						local y1 = math.round(y0 + scale * (frame.y          ))
						local x2 = math.round(x0 + scale * (frame.x + frame.w))
						local y2 = math.round(y0 + scale * (frame.y + frame.h))
						if highlight {
							LG.setLineWidth(2)
							LG.rectangle(LG.DrawMode.LINE, x1+1, y1+1, x2-x1-2, y2-y1-2)
							LG.setLineWidth(1)
						} else {
							LG.rectangle(LG.DrawMode.LINE, x1+.5, y1+.5, x2-x1-1, y2-y1-1)
						}
					}

					LG.setColor(0, 1, 0)
					for system.frames  drawFrame(x0,y0, scale, it, false)

					local frameIndex = getAnimationPreviewProgress(system.particles, #system.frames)
					LG.setColor(1, 1, 1)
					drawFrame(x0,y0, scale, system.frames[frameIndex], true)

					local occupiedCoords: Table(int, bool)

					for system.frames {
						local text = format("%d", itIndex)
						local x    = math.round(x0 + scale * it.x) + 2
						local y    = math.round(y0 + scale * it.y)

						while occupiedCoords[y*iw+x]  y += fontNormal.getHeight!()
						occupiedCoords[y*iw+x] = true

						LG.setColor(0, 0, 0)
						LG.print(text, x+1, y+1)

						if itIndex == frameIndex
							LG.setColor(1, 1, 1)
						else
							LG.setColor(0, 1, 0)
						LG.print(text, x, y)
					}
				}

				local mx, my = LM.getPosition()

				if LW.hasMouseFocus() and not (guiState.activeId or guiState.isOverGui!(mx, my)) {
					local text = format(
						"[%d, %d]",
						math.clamp(math.floor((mx-x0)/scale), 0, iw),
						math.clamp(math.floor((my-y0)/scale), 0, ih)
					)
					local x = math.min(mx, ww-fontNormal.getWidth!(text)-2)
					local y = my + 20
					if y+fontNormal.getHeight!() > wh-2  y = my-10-fontNormal.getHeight!()
					LG.setColor(0, 0, 0)
					LG.print(text, x+1, y+1)
					LG.setColor(1, 1, 1)
					LG.print(text, x, y)
				}
			}
		}

		-- Stats.
		if app.showStats {
			local particleCountTotal        = 0
			local particleCountTotalOptimal = 0
			for project.systems {
				particleCountTotal        += it.particles.getCount!()
				particleCountTotalOptimal += getOptimalBufferSize(it, moreExact=true)
			}

			local fontH = fontNormal.getHeight!()

			local x = MAIN_PANEL_WIDTH+5
			local y = 5

			if bgBrightness < .5
				LG.setColor(1, 1, 1, .7)
			else
				LG.setColor(0, 0, 0, .7)

			local drawStatsLine = [x,y,fontH] (pre:string, s:string, ...:int|float|string) {
				LG.print(pre, x, y)
				if s  LG.print(format(s, ...), x+fontNormal.getWidth!(pre), y)
				y += fontH+1
			}

			drawStatsLine("FPS: ", "%d%s", LT.getFPS(), (app.showStats == STATS_ALL ? "" : " (vsync)"))

			if app.showStats == STATS_ALL {
				local _, _, flags = LW.getMode()
				local ratio       = 1 / presentTime / flags.refreshrate

				if not flags.refreshrate {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms", 1000*presentTime)
				} elseif ratio >= 10 {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.0f.0 x framerate)", 1000*presentTime, ratio)
				} elseif ratio >= 2 {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.1f0 x framerate)",  1000*presentTime, ratio)
				} else {
					drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.2f x framerate)",   1000*presentTime, ratio)
				}

				drawStatsLine("ParticleSystemUpdateTime: ", "%.3f ms",  1000*particleUpdateTime)
				drawStatsLine("ParticleSystemDrawTime: ",   "%.3f ms",  1000*particleDrawTime)
			}

			drawStatsLine("ParticleCountTotal: ", "%d/%d", particleCountTotal, particleCountTotalOptimal)

			if #project.systems > 1  for project.systems {
				local bufferSize = it.particles.getBufferSize!()
				drawStatsLine(
					"ParticleCount_",
					"%d: %d/%d (%d%s)",
					itIndex,
					it.particles.getCount!(),
					getOptimalBufferSize(it, moreExact=true),
					bufferSize,
					(bufferSize >= app.maxBufferSize ? " MAX" : "")
				)
			}

			drawStatsLine("EmitterTime: ", "%.3f sec", project.particleEmitDuration)

			!if DEV {
				local stats = statsAll
				if app.showStats == STATS_ALL and stats ~= NULL {
					y += 5
					drawStatsLine("memory: ",                 "%.2f MiB", !import"gc".getMemoryUsage()/1024)
					drawStatsLine("drawcalls (batched): ",    "%d (%d)",  stats.drawcalls, stats.drawcallsbatched)
					drawStatsLine("switches canvas/shader: ", "%d/%d",    stats.canvasswitches, stats.shaderswitches)
					drawStatsLine("texture memory: ",         "%.2f MiB", stats.texturememory/1024^2)
					drawStatsLine("images/fonts/canvases: ",  "%d/%d/%d", stats.images, stats.fonts, stats.canvases)
				}
				if app.showStats == STATS_SOME {
					y += 5
					drawStatsLine("(hide with F1)", "")
				}
			} else {
				y += 5
				drawStatsLine("(hide with F1)", "")
			}
		}

		-- Panel(s).
		guiState.draw!()

		-- GUI texts.
		local drawGuiText :: (text:string, time:float, duration:float, y:int) {
			local PADDING_X :: 20
			local PADDING_Y :: 8

			local visibility = 1 - (LT.getTime() - time) / duration
			if visibility <= 0  return

			local anyModalVisible = (guiState.getTopmostActiveModal!() ~= NULL)

			local w = fontLarge.getWidth!(text)
			local x = (LG.getWidth() + (anyModalVisible ? 0 : MAIN_PANEL_WIDTH) - w) // 2
			local a = visibility ^ .5

			if anyModalVisible {
				if findPattern(text, "^Error: ")
					LG.setColor(.4, 0, 0, a)
				else
					LG.setColor(0, 0, 0, a)
				LG.rectangle(LG.DrawMode.FILL, x-PADDING_X, y-PADDING_Y, w+2*PADDING_X, fontLarge.getHeight!()+2*PADDING_Y, 3)

			} else {
				LG.setColor(0, 0, 0, a)
				LG.print(text, x+1, y+1)
			}

			LG.setColor(1, 1, 1, a)
			LG.print(text, x, y)
		}

		local anyInfiniteEmitter = false
		local anyFiniteEmitter   = false

		for project.systems {
			if it.particles.getEmitterLifetime!() < 0
				anyInfiniteEmitter = true
			else
				anyFiniteEmitter   = true
		}

		LG.origin()
		LG.setFont(fontLarge)

		local dist = fontLarge.getHeight!() + 5

		if project.preview {
			local _, filename = Path(project.path).getFilename!()
			drawGuiText("Preview of "..filename, 0, math.HUGE, 10)
		}
		if anyFiniteEmitter and anyInfiniteEmitter {
			drawGuiText("Warning: Mixing infinite and finite emitters", 0, math.HUGE, 10+1*dist)
		}
		drawGuiText(messageText, messageTextTime, messageTextDuration, 10+2*dist)
		drawGuiText(actionText,  actionTextTime,  actionTextDuration,  10+3*dist)

		-- Dev/debug stuff.
		!if DEV {
			local showSaveIndicator = true
			!if GIF_RECORDING_MODE  showSaveIndicator = not gifRecordingActive

			if showSaveIndicator {
				local visibility = 1 - (LT.getTime() - workspaceSaveTime) / 0.40
				if visibility > 0 {
					LG.setColor(1, 1, 1, .4*visibility^.5)
					LG.circle(LG.DrawMode.FILL, ww-10, 10, 4, 8)
				}
			}

			-- LG.setColor(1, 1, 1)
			-- LG.print(format("%d", LT.getFPS()))
		}

		--[[ Mouse stuff.
		local mx, my = LM.getPosition()
		if isPositioningParticles {
			LG.setColor(1, 0, 0)
			LG.line(mx-50, my, mx+50, my)
			LG.line(mx, my-50, mx, my+50)
		}
		--]]

		!if GIF_RECORDING_MODE {
			LG.setLineWidth(2)
			LG.setColor(1, 1, 1)
			for visualMousePresses  LG.circle(LG.DrawMode.LINE, it.x, it.y, math.lerp(2, 22, it.progress), 32)
			LG.setLineWidth(1)
		}

		LG.reset()
	}

	-- Put stuff on the screen!
	LG.clear(0, 0, 0, 1)
	LG.setBlendMode(LG.BlendMode.ALPHA, LG.BlendAlphaMode.PREMULTIPLIED)

	if project.pixelateWorld {
		LG.draw(canvasWorld, (ww+MAIN_PANEL_WIDTH)/2,wh/2, 0, project.zoom,project.zoom, (ww-MAIN_PANEL_WIDTH)/2, wh/2)
	} else {
		LG.draw(canvasWorld, MAIN_PANEL_WIDTH,0)
	}

	LG.draw(canvasGui)

	!if DEV  LG.getStats(statsAll)

	!if GIF_RECORDING_MODE  if gifRecordingActive {
		LG.captureScreenshot((screenshot:LI.ImageData) {
			if gifRecordingFrame % 10 == 0  printf("Frame %d (%.2f sec)", gifRecordingFrame, gifRecordingFrame*GIF_FRAME_DELAY/100)

			overlayDummyCursor(screenshot)

			local path = format("%s/frame%04d.png", gifRecordingDirectory, gifRecordingFrame)
			screenshot.encode!(LI.ImageFormat.PNG, path)

			gifRecordingFrame += 1
		})
	}

	local time = LT.getTime()
	LG.present()
	presentTime = LT.getTime()-time
}

local overlayDummyCursor :: (screenshot:LI.ImageData) {
	if not LW.hasMouseFocus()  return

	local dummyCursor = dummyCursors[currentCursor]
	local cursorData  = dummyCursor.data
	local mx, my      = LM.getPosition()
	local w,  h       = cursorData.getDimensions!()

	local screenshotW, screenshotH = screenshot.getDimensions!()

	local x1 = mx - dummyCursor.hotX
	local y1 = my - dummyCursor.hotY
	local x2 = x1 + w - 1
	local y2 = y1 + h - 1

	local mapX1 = math.max(x1, 0)
	local mapY1 = math.max(y1, 0)
	local mapX2 = math.min(x2, screenshotW-w)
	local mapY2 = math.min(y2, screenshotH-h)

	screenshot.mapPixel!(mapX1, mapY1, mapX2-mapX1+1, mapY2-mapY1+1, [cursorData, x1, y1] (x,y:int, r,g,b,a:float) -> (r,g,b,a:float) {
		local r2, g2, b2, a2 = cursorData.getPixel!(x-x1, y-y1)
		return
			math.lerp(r, r2, a2),
			math.lerp(g, g2, a2),
			math.lerp(b, b2, a2),
			1 - (1-a) * (1-a2)
	})
}



local onResize :: (ww,wh:int) {
	createCanvases()
	guiState.layoutNeedsUpdate = true
	freezeDtThisFrame          = true -- Fixes things jumping forward like crazy (in Windows at least).

	local maximized = LW.isMaximized()

	if not maximized {
		local w, h, flags = LW.getMode()
		app.windowX       = cast(int) flags.x
		app.windowY       = cast(int) flags.y
		app.windowWidth   = w
		app.windowHeight  = h
	}
	app.windowMaximized = maximized

	scheduleSaveWorkspace()
}



local onFocus :: (hasFocus:bool) {
	guiState.onFocus!(hasFocus)
}



local main :: () {
	!import "utils"
	local LOVE: table : !foreign lua "love"

	LOVE.run           = wrapFunctionInGloaErrorHandler(onRun)
	LOVE.load          = wrapFunctionInGloaErrorHandler(onLoad)
	LOVE.filedropped   = wrapFunctionInGloaErrorHandler(onFileDropped)
	LOVE.keypressed    = wrapFunctionInGloaErrorHandler(onKeyPressed)
	LOVE.keyreleased   = wrapFunctionInGloaErrorHandler(onKeyReleased)
	LOVE.textinput     = wrapFunctionInGloaErrorHandler(onTextInput)
	LOVE.mousepressed  = wrapFunctionInGloaErrorHandler(onMousePressed)
	LOVE.mousemoved    = wrapFunctionInGloaErrorHandler(onMouseMoved)
	LOVE.mousereleased = wrapFunctionInGloaErrorHandler(onMouseReleased)
	LOVE.wheelmoved    = wrapFunctionInGloaErrorHandler(onMouseWheel)
	LOVE.update        = wrapFunctionInGloaErrorHandler(onUpdate)
	LOVE.draw          = wrapFunctionInGloaErrorHandler(onDraw)
	LOVE.resize        = wrapFunctionInGloaErrorHandler(onResize)
	LOVE.focus         = wrapFunctionInGloaErrorHandler(onFocus)
	LOVE.errorhandler  = nil
	LOVE.errhand       = nil
}



export setCurrentProject :: (i:int, force=false) {
	if app.currentProjectIndex == i and not force  return

	app.currentProjectIndex = i
	guiState.getElement!("projects", gui.Tabs).index = i

	guiState.refreshRecursively!("projectSettings")
	guiState.refreshRecursively!("systems")
	guiState.refreshRecursively!("undoRedo")
	guiState.refreshRecursively!("undoRedoText")

	scheduleRecreateCanvases = true
	updateImageFilters()

	setCurrentSystem(app.projects[i].systemIndex, force=true)

	updateWindowTitle()
}

export setCurrentSystem :: (i:int, force=true) {
	local currentProject = app.projects[app.currentProjectIndex]
	if currentProject.systemIndex == i and not force  return

	currentProject.systemIndex = i
	guiState.getElement!("systems", gui.Tabs).index = i

	guiState.refreshRecursively!("system")
}

export isSystemCurrent :: (system:System) -> bool {
	local currentProject = app.projects[app.currentProjectIndex]
	return system == currentProject.systems[currentProject.systemIndex]
}



export scheduleSaveWorkspace :: () {
	workspaceSaveScheduled = true
	workspaceSaveDelay     = WORKSPACE_SAVE_DELAY
}



export openProject :: (fullPath:string, asPreview=false, ignoreOpened=false) -> (success:bool, project:Project, isNew:bool) {
	local pathObj = Path(fullPath)
	fullPath      = pathObj.toString!()

	local ok, dir, filename = pathObj.getDirectoryAndFilename!()
	if not ok {
		removeRecent(app.recentProjects, fullPath)
		if not asPreview  setErrorText("Bad project path '%s'", fullPath)
		return false, NULL, NULL
	}

	if not ignoreOpened {
		for app.projects  if it.path == fullPath {
			setCurrentProject(itIndex)
			if not asPreview  addRecent(app.recentProjects, fullPath, app.maxRecentFiles)
			return true, it, false
		}
	}

	if not connectToRemoteDirectory(dir) {
		removeRecent(app.recentProjects, fullPath)
		if not asPreview  setErrorText("Could not access folder '%s'", dir)
		return false, NULL, NULL
	}
	defer disconnectFromRemoteDirectory()

	if not asPreview  addRecent(app.recentFolders, dir, app.maxRecentFiles)

	local ^ok, gotError, _app = loadWorkspace(filename)
	if not ok {
		removeRecent(app.recentProjects, fullPath)
		if not asPreview  setErrorText("Could not load '%s'", filename)
		return false, NULL, NULL
	}

	local project = _app.projects[1]
	if project == NULL {
		if not asPreview  setErrorText("File is missing data")
		return false, NULL, NULL
	}

	if not asPreview  addRecent(app.recentProjects, fullPath, app.maxRecentFiles)

	project.path          = fullPath
	project.displayedName = filename
	project.fileIsSaved   = true
	project.preview       = asPreview
	insert(app.projects, project)

	updateParticles(project)
	updateBackgroundTexture(project)

	local currentProject = app.projects[app.currentProjectIndex]
	if not asPreview and isProjectEmpty(currentProject) {
		remove(app.projects, app.currentProjectIndex)
	}

	guiState.refreshRecursively!("projects")
	setCurrentProject(#app.projects, force=true)
	scheduleSaveWorkspace()

	return true, project, true
}

export reopenCurrentProject :: () {
	local projectIndex = app.currentProjectIndex
	local projectOld   = app.projects[projectIndex]

	if not projectOld.fileIsSaved  return -- @Incomplete: Replace the project with an empty one instead of doing nothing?

	remove(app.projects, projectIndex)
	local ok, projectNew = openProject(projectOld.path, ignoreOpened=true)

	if ok {
		remove(app.projects, #app.projects)
		insert(app.projects, projectIndex, projectNew)
	} else {
		insert(app.projects, projectIndex, projectOld)
	}

	guiState.refreshRecursively!("projects")
	setCurrentProject(projectIndex, force=true)
}

export openRecentProject :: () {
	for app.recentProjects  if not indexWith(app.projects, "path", it) {
		openProject(it)
		break
	}
}

export confirmCloseProject :: (projectIndex:int) {
	local closeProject :: (projectIndex:int) {
		local isCurrent  = (projectIndex == app.currentProjectIndex)
		local _, project = remove(app.projects, projectIndex)

		if project.path  addRecent(app.recentProjects, project.path, app.maxRecentFiles)

		if app.projects[1] == NULL
			addNewProject()
		elseif projectIndex < app.currentProjectIndex
			app.currentProjectIndex -= 1
		else
			app.currentProjectIndex = math.min(app.currentProjectIndex, #app.projects)

		hotLoader.watchersNeedUpdate = true

		guiState.refreshRecursively!("projects")
		if isCurrent  setCurrentProject(app.currentProjectIndex, force=true)
		scheduleSaveWorkspace()
	}

	if app.projects[projectIndex].edited {
		local BUTTONS: []gui.Button : {{label="Close"},{label="Cancel"}}

		pushTempChoiceDialog("Confirm close", "The project has unsaved changes. Close it anyway?", BUTTONS, submitIndex=1, [projectIndex] (choice:int) {
			if choice == 1  closeProject(projectIndex)
		})

	} else {
		closeProject(projectIndex)
	}
}



export confirmDeleteSystem :: (systemIndexToDelete:int) {
	-- @UX: Don't confirm if the system has no modifications.
	local BUTTONS: []gui.Button : {{label="Delete"},{label="Cancel"}}

	local psCanvas = guiState.canvas!({ name="temp_deleteSystemPreview", width=DIALOG_WIDTH-40, height=200 })

	guiState.onDraw.temp_deleteSystemPreview = [systemIndexToDelete] (canvasEl:gui.Canvas, cw,ch:int) {
		local currentProject = app.projects[app.currentProjectIndex]
		local system         = currentProject.systems[systemIndexToDelete]
		local scale          = ch / LG.getHeight() * currentProject.zoom
		local r, g, b        = hsvToRgb(currentProject.bgColor)
		local emitterX, emitterY: float

		if currentProject.movementPreset == .NONE {
			emitterX, emitterY = system.particles.getPosition!()
		}

		LG.setColor(1, 1, 1)

		LG.clear(r, g, b, 1)
		LG.setShader(system.currentShader ~= NULL ? system.currentShader.shader : NULL)
		LG.setBlendMode(system.blendMode)

		LG.draw(system.particles,
			cw/2 - emitterX*scale,
			ch/2 - emitterY*scale,
			0, scale
		)

		LG.setShader()
		LG.setBlendMode(.ALPHA)
	}

	forceParticleUpdates = true

	pushTempChoiceDialog("Confirm delete", "Delete this particle system?", BUTTONS, submitIndex=1, extraContent=psCanvas, [systemIndexToDelete] (choice:int) {
		guiState.onDraw.temp_deleteSystemPreview = nil
		forceParticleUpdates                     = false

		if choice ~= 1  return

		local currentProject = app.projects[app.currentProjectIndex]
		local system         = currentProject.systems[systemIndexToDelete]

		if #currentProject.systems == 1 {
			local emptySystem = newSystem(currentProject)
			recordChange("", "Delete particle system", nil,
				[emptySystem] (project:Project) {  project.systems[1] = emptySystem  },
				[system     ] (project:Project) {  project.systems[1] = system       },
				--[[       ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(1, force=true)  }
			)
		} else {
			recordChange("", "Delete particle system", nil,
				[systemIndexToDelete        ] (project:Project) {  remove(project.systems, systemIndexToDelete) ; project.systemIndex = math.min(project.systemIndex, #project.systems)  },
				[systemIndexToDelete, system] (project:Project) {  insert(project.systems, systemIndexToDelete, system)  },
				--[[                       ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(project.systemIndex, force=true)  }
			)
		}
	})
}

export duplicateSystem :: (systemIndex:int) {
	local currentProject = app.projects[app.currentProjectIndex]
	local system         = currentProject.systems[systemIndex].clone!()

	recordChange("", "Duplicate particle system", nil,
		[systemIndex, system] (project:Project) {  insert(project.systems, systemIndex+1, system) ; project.systemIndex = systemIndex+1  },
		[systemIndex        ] (project:Project) {  remove(project.systems, systemIndex+1)         ; project.systemIndex = math.min(project.systemIndex, #project.systems)  },
		--[[               ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(project.systemIndex, force=true)  }
	)
}



export getGuiValue :: (system:System, name:string) -> (success:bool, value:string) {
	local value = system.gui[name]
	if value == NULL  return false, ""
	return true, value
}

export setGuiValue :: (system:System, name:string, value:string) {
	system.gui[name] = value
	scheduleSaveWorkspace()
}



export getAnimationPreviewProgress :: (ps:LG.ParticleSystem, frameCount:int) -> (i:int, progress:float, progressInSeconds:float) {
	local min, max = ps.getParticleLifetime!()
	local lifetime = math.max((min + max) / 2, .0001) -- Use average lifetime.
	local progress = (timeForAnimationPreview / lifetime) % 1
	local i        = math.clamp(math.floor(1 + progress * frameCount), 1, frameCount)
	return i, progress, lifetime*progress
}

export getAnimationPreviewQuad :: (ps:LG.ParticleSystem, quads:[]LG.Quad) -> (quad:LG.Quad--[[may be NULL]], progress:float, progressInSeconds:float) {
	local i, progress, progressInSeconds = getAnimationPreviewProgress(ps, #quads)
	return quads[i], progress, progressInSeconds
}



local getFullPathToProjectResource :: (project:Project, path:string) -> (success:bool, fullPath:string, isDanglingRelativePath:bool) {
	if not path  return false, "", false

	local pathObj = Path(path)

	if pathObj.isAbsolute {
		if not pathObj.getFilename!()  return false, "", false
		return true, path, false

	} elseif project.fileIsSaved {
		local fullPathObj = Path(project.path)
		fullPathObj.pop!() -- @Robustness: Should we check if the path is empty after this?
		fullPathObj.append!(pathObj)
		return true, fullPathObj.toString!(), false

	} else {
		return false, path, true
	}
}



export getFullPathToTexture :: (project:Project, system:System) -> (success:bool, fullPath:string, isDanglingRelativePath:bool) {
	local path = system.texturePath
	if not path  return true, format("%s/gfx/particles/%s.png", getAppDirectory(), system.textureName), false
	-- if not path  return true, particleImages[system.textureName].fullPath, false -- Doesn't work in test code!
	return getFullPathToProjectResource(project, path)
}
export getFullPathToShader :: (project:Project, system:System) -> (success:bool, fullPath:string, isDanglingRelativePath:bool) {
	return getFullPathToProjectResource(project, system.shaderPath)
}
export getFullPathToBackground :: (project:Project) -> (success:bool, fullPath:string, isDanglingRelativePath:bool) {
	return getFullPathToProjectResource(project, project.bgPath)
}
export getFullPathToCustomParticlesTemplate :: (project:Project) -> (success:bool, fullPath:string, isDanglingRelativePath:bool) {
	return getFullPathToProjectResource(project, project.exportParticlesTemplatePath)
}
export getFullPathToCustomClipboardTemplate :: (project:Project) -> (success:bool, fullPath:string, isDanglingRelativePath:bool) {
	return getFullPathToProjectResource(project, project.exportClipboardTemplatePath)
}

export setTexturePath :: (project:Project, system:System, pathNew:string) {
	local pathOld = system.texturePath
	if pathNew == pathOld  return

	local saveRecent = true

	recordChange("", "Texture path", nil,
		[system, pathNew            ] (project:Project) {  system.texturePath = pathNew  },
		[system, pathOld, saveRecent] (project:Project) {  system.texturePath = pathOld ; saveRecent = false  },
		[system,          saveRecent] (project:Project) {  updateParticleTexture(project, system, saveRecent) ; saveRecent = false ; guiState.refreshRecursively!("texturePath")  }
	)
}
export setShaderPath :: (project:Project, system:System, pathNew:string) {
	local pathOld = system.shaderPath
	if pathNew == pathOld  return

	local saveRecent = true

	recordChange("", "Shader path", nil,
		[system, pathNew            ] (project:Project) {  system.shaderPath = pathNew  },
		[system, pathOld, saveRecent] (project:Project) {  system.shaderPath = pathOld ; saveRecent = false  },
		[system,          saveRecent] (project:Project) {  updateParticleShader(project, system, saveRecent) ; saveRecent = false ; guiState.refreshRecursively!("shaderPath")  }
	)
}
export setBackgroundPath :: (project:Project, pathNew:string) {
	local pathOld = project.bgPath
	if pathNew == pathOld  return

	local saveRecent = true

	recordChange("", "Background path", nil,
		[pathNew            ] (project:Project) {  project.bgPath = pathNew  },
		[pathOld, saveRecent] (project:Project) {  project.bgPath = pathOld ; saveRecent = false  },
		[         saveRecent] (project:Project) {  updateBackgroundTexture(project, NULL, saveRecent) ; saveRecent = false ; guiState.refreshRecursively!("bgPath")  }
	)
}
export setCustomParticlesTemplatePath :: (project:Project, pathNew:string, saveRecent=false) {
	if pathNew == project.exportParticlesTemplatePath  return
	project.exportParticlesTemplatePath = pathNew
	markEdited(project)
	if saveRecent and pathNew  addRecent(app.recentTemplates, pathNew, app.maxRecentFiles)
	scheduleSaveWorkspace()
}
export setCustomClipboardTemplatePath :: (project:Project, pathNew:string, saveRecent=false) {
	if pathNew == project.exportClipboardTemplatePath  return
	project.exportClipboardTemplatePath = pathNew
	markEdited(project)
	if saveRecent and pathNew  addRecent(app.recentTemplates, pathNew, app.maxRecentFiles)
	scheduleSaveWorkspace()
}



export toggleRelativePath :: (project:Project, path:string, fullPathGetter:()->(success:bool,fullPath:string), relativeTo="") -> (success:bool, path:string) {
	if not path  return false, ""

	if not (relativeTo or project.path) {
		setErrorText("Relative paths require the project to be saved")
		return false, ""
	}

	local pathObj = Path(path)

	if pathObj.isAbsolute {
		local dir = relativeTo
		if not dir  _, dir = Path(project.path).getDirectory!()

		local ok, pathRelativeObj = pathObj.getRelativeTo!(dir)
		if not ok {
			setErrorText("Could not get relative path to '%s'", path)
			return false, ""
		}
		return true, pathRelativeObj.toString!()

	} else {
		local ok, pathFull = fullPathGetter()
		if not ok {
			setErrorText("Could not get full path to '%s'", path)
			return false, ""
		}
		return true, pathFull
	}
}



export markEdited :: (project:Project) {
	if project.edited  return

	project.edited = true

	guiState.refreshRecursively!("projects")
	updateWindowTitle()
}



export updateBufferSize :: (system:System) -> (gotUpdated:bool) {
	local ps                = system.particles
	local bufferSizeCurrent = ps.getBufferSize!()
	local bufferSize        = math.min(bufferSizeCurrent, app.maxBufferSize)
	local optimalBufferSize = getOptimalBufferSize(system)

	while bufferSize < optimalBufferSize  bufferSize *= 2

	if bufferSize == bufferSizeCurrent  return false

	ps.setBufferSize!(bufferSize)
	return true
}

export getOptimalBufferSize :: (system:System, moreExact=false) -> int {
	local ps               = system.particles
	local particleLifetime = math.max(ps.getParticleLifetime!()) -- s
	local emitterLifetime  = ps.getEmitterLifetime!()            -- s
	local rate             = ps.getEmissionRate!()               -- n/s
	local relevantTime     = emitterLifetime < 0 ? particleLifetime : math.min(particleLifetime, emitterLifetime)
	local bufferSize       = math.ceil((system.kickStartEmitEnabled ? system.kickStartEmit : 0) + rate * relevantTime * (moreExact ? 1 : 1.05)) -- n/s * s  =  n
	return math.max(math.min(bufferSize, app.maxBufferSize), 1)
}



export updateWindowTitle :: () {
	local currentProject = app.projects[app.currentProjectIndex]
	LW.setTitle(format(
		"%s - %s%s",
		WINDOW_TITLE,
		(currentProject.path ?: currentProject.displayedName),
		(currentProject.edited ? " •" : "")
	))
}



export getCurrentProjectAndSystem :: () -> Project, System {
	local currentProject = app.projects[app.currentProjectIndex]
	local system         = currentProject.systems[currentProject.systemIndex]
	return currentProject, system
}



export getKickStartDt :: (system:System) -> float {
	if not (system.kickStartStepsEnabled and system.kickStartSteps)  return 0

	local ps = system.particles
	return (
		math.min(
			ps.getEmitterLifetime!() < 0 ? math.HUGE : ps.getEmitterLifetime!(),
			math.max(ps.getParticleLifetime!())
		)
		/ system.kickStartSteps
	)
}



export isProjectEmpty :: (project:Project) -> bool {
	return not (project.edited or project.path)
}



export recordChange :: (name:string, label:string, data:any, onDo:(project:Project), onUndo:(project:Project), finalize:(project:Project)=NULL--[[, trigger=true]]) -> Change {
	-- @Polish: Reset currentProject.edited if all changes since the last save has been undone/redone. (Beware of changed emitter position though!)
	local currentProject = app.projects[app.currentProjectIndex]

	-- Discard undone changes.
	for #currentProject.changes, currentProject.changeIndex, -1  currentProject.changes[it] = NULL

	while currentProject.changes[app.maxChanges] ~= NULL  remove(currentProject.changes, 1) -- This may remove more than one if app.maxChanges changed.

	local change: Change = {
		bundle   = updateEventCount,
		name     = name, -- May be empty.
		label    = label,
		data     = data,
		onDo     = onDo,
		onUndo   = onUndo,
		finalize = finalize,
	}
	insert(currentProject.changes, change)
	currentProject.changeIndex = #currentProject.changes + 1

	-- if trigger {
		onDo(currentProject)
		if finalize ~= NULL  finalize(currentProject)
	-- }

	markEdited(currentProject)
	guiState.refreshRecursively!("undoRedo")
	guiState.refreshRecursively!("undoRedoText")
	scheduleSaveWorkspace()

	return change
}

export undo :: (silent=false) {
	local currentProject = app.projects[app.currentProjectIndex]
	if currentProject.changeIndex == 1  return

	currentProject.changeIndex -= 1

	local change = currentProject.changes[currentProject.changeIndex]
	local bundle = change.bundle
	local labels: []string
	local labelsAdded: struct { !key:string, !value:bool }

	while true {
		if not (silent or labelsAdded[change.label]) {
			labelsAdded[change.label] = true
			insert(labels, change.label)
		}
		change.onUndo(currentProject)
		if change.finalize ~= NULL  change.finalize(currentProject)

		change = currentProject.changes[currentProject.changeIndex-1]
		if not (change ~= NULL and change.bundle == bundle)  break

		currentProject.changeIndex -= 1
	}

	if not silent {
		reverseArray(labels)
		setActionText("Undo:  "..concatenate(labels, ", "), clearMessage=false)
	}

	markEdited(currentProject)
	guiState.refreshRecursively!("undoRedo")
	guiState.refreshRecursively!("undoRedoText")
	scheduleSaveWorkspace()
}

export redo :: () {
	local currentProject = app.projects[app.currentProjectIndex]
	if currentProject.changeIndex > #currentProject.changes  return

	local change = currentProject.changes[currentProject.changeIndex]
	local bundle = change.bundle
	local labels: []string
	local labelsAdded: struct { !key:string, !value:bool }

	while true {
		if not labelsAdded[change.label] {
			labelsAdded[change.label] = true
			insert(labels, change.label)
		}
		change.onDo(currentProject)
		if change.finalize ~= NULL  change.finalize(currentProject)

		change = currentProject.changes[currentProject.changeIndex+1]
		if not (change ~= NULL and change.bundle == bundle)  break

		currentProject.changeIndex += 1
	}

	currentProject.changeIndex += 1

	setActionText("Redo:  "..concatenate(labels, ", "), clearMessage=false)

	markEdited(currentProject)
	guiState.refreshRecursively!("undoRedo")
	guiState.refreshRecursively!("undoRedoText")
	scheduleSaveWorkspace()
}



export getFirstChangeInPreviousBundle :: (project:Project) -> Change {
	if project.changeIndex == 1  return NULL

	local change = project.changes[project.changeIndex-1]

	for project.changeIndex-2, 1, -1 {
		local _change = project.changes[it]
		if _change.bundle ~= change.bundle  break
		change = _change
	}

	return change
}



export clampZoomLevel :: (project:Project, zoomLevel:int) -> (zoomLevel:int) {
	return math.clamp(zoomLevel, (project.pixelateWorld ? -2 : -8), 12)
}

export limitZoomLevel :: (project:Project) {
	project.zoomLevel  = clampZoomLevel(project, project.zoomLevel)
	project.zoomSource = project.zoom
	project.zoomTarget = 2 ^ (project.zoomLevel/2)
}



export showMainMenu :: () {
	local recentItems: []gui.MenuItem
	insert(recentItems, cast(gui.MenuItem) {name="openLast",label="Reopen closed file",shortcut=ctrlText.."+Shift+T"})
	insert(recentItems, cast(gui.MenuItem) {label="-"})

	if app.recentProjects {
		for app.recentProjects  insert(recentItems, cast(gui.MenuItem) {name="openRecent",data=it,label=it})
	} else {
		insert(recentItems, cast(gui.MenuItem) {label="(no recent files)"})
	}

	insert(recentItems, cast(gui.MenuItem) {label="-"})
	insert(recentItems, cast(gui.MenuItem) {name="clearRecent",label="Clear items"})

	local items: []gui.MenuItem = {
		{label="New project",         name="new",         shortcut=ctrlText.."+N"},
		{label="-"},
		{label="Open project...",     name="open",        shortcut=ctrlText.."+O"},
		{label="Open recent",         submenu=recentItems},
		{label="Reopen project",      name="reopen"},
		{label="-"},
		{label="Save project",        name="save",        shortcut=ctrlText.."+S"},
		{label="Save new project...", name="saveAs",      shortcut=ctrlText.."+Shift+S"},
		{label="Export...",           name="export",      shortcut=ctrlText.."+E"},
		{label="Quick export files",  name="exportQuick", shortcut=ctrlText.."+Shift+E"},
		{label="-"},
		{label="Preferences",         name="preferences", shortcut=ctrlText.."+K"},
		{label="Log",                 name="log"},
		{label="-"},
		{label="Exit",                name="exit",        shortcut=ctrlText.."+Q"},
	}

	local buttons = guiState.getElement!("menuAndSettingsButtons", gui.Buttons)

	guiState.showMenu!(buttons.layoutX, buttons.layoutY+buttons.layoutHeight, items, (choice:string, data:any) {
		local currentProject = app.projects[app.currentProjectIndex]
		if choice == {
			case "new":         addNewProject() ; guiState.refreshRecursively!("projects") ; setCurrentProject(#app.projects) ; scheduleSaveWorkspace()
			case "open":        showOpenProjectDialog()
			case "openLast":    openRecentProject()
			case "openRecent":  openProject(cast(string)data)
			case "reopen":      reopenCurrentProject()
			case "clearRecent": app.recentProjects = {}
			case "save":        if currentProject.fileIsSaved  saveProject(currentProject, currentProject.path, overwrite=true)  else  showSaveProjectAsDialog()
			case "saveAs":      showSaveProjectAsDialog()
			case "export":      pushPanel("exportProject")
			case "exportQuick": tryExportFiles(quick=true)
			case "preferences": pushPanel("preferences")
			case "log":         pushPanel("log")
			case "exit":        pushQuitEvent()
		}
	})
}



local projectBeingSaved:     Project = NULL
local lastProjectBeforeTemp: Project = NULL

local loadPreview :: (fullPath:string) {
	local lastIndex = app.currentProjectIndex

	local ok, project = openProject(fullPath, asPreview=true)
	if not ok  return

	if lastProjectBeforeTemp == NULL {
		lastProjectBeforeTemp = app.projects[lastIndex]
	}
}

local unloadPreview :: () {
	local currentProject = app.projects[app.currentProjectIndex]

	for < app.projects  if it.preview {
		remove(app.projects, itIndex)
	}

	local ok, i = indexOf(app.projects, (currentProject.preview ? lastProjectBeforeTemp : currentProject))
	assert(ok)
	guiState.refreshRecursively!("projects")
	setCurrentProject(i, force=true)

	lastProjectBeforeTemp = NULL
	scheduleSaveWorkspace()
}

export showSaveProjectAsDialog :: () {
	local currentProject = app.projects[app.currentProjectIndex]
	local pathObj        = Path(currentProject.path)

	local ok, dir, filename = pathObj.getDirectoryAndFilename!()
	if not ok {
		dir      = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"
		filename = "untitled.hotparticles"
	}

	projectBeingSaved = currentProject -- Needed as we load previews even in the save dialog, which means app.currentProjectIndex may change.

	showFileDialog(.SAVE, "Save project", dir, filename, filenamePattern="%.hotparticles$",
		onHighlight = (pathObj:Path, fullPathObj:Path) {
			loadPreview(pathObj.toString!())

			--[[
			local ok, filename = pathObj.getFilename!()
			if ok {
				local basename, ext = splitBasenameAndExtension(filename)
				local input         = guiState.getElement!("fileDialog_filename", gui.InputText)
				guiState.setFocus!(input)
				input.field.setSelection!(0, utf8.getLength(basename))
			}
			--]]
		},
		onChoose = (pathObj:Path, fullPathObj:Path) {
			local _, filename = fullPathObj.getFilename!()

			if not findPattern(filename, "%.hotparticles$") {
				filename    = filename..".hotparticles"
				local input = guiState.getElement!("fileDialog_filename", gui.InputText)
				input.value = input.value..".hotparticles"
				fullPathObj.setFilename!(filename)
			}

			local fullPath = fullPathObj.toString!()

			local ok, fileExists = saveProject(projectBeingSaved, fullPath, overwrite=false)
			if ok {
				updateParticleTextures(projectBeingSaved) -- In case any texture uses a relative path.
				popPanel()

			} elseif fileExists {
				local BUTTONS: []gui.Button : {{label="Overwrite"},{label="Cancel"}}

				pushTempChoiceDialog("Confirm save as", filename.." already exists. Overwite it?", BUTTONS, submitIndex=1, [fullPath] (choice:int) {
					if choice ~= 1  return

					saveProject(projectBeingSaved, fullPath, overwrite=true)

					updateParticleTextures(projectBeingSaved) -- In case any texture uses a relative path.
					popPanel("fileDialog")
				})

			} else {
				-- void  Stay in the dialog.
			}
		},
		onClose = () {
			unloadPreview()
			projectBeingSaved = NULL
		}
	)
}

export showOpenProjectDialog :: () {
	local currentProject = app.projects[app.currentProjectIndex]
	local fullPathObj    = Path(currentProject.path)

	local ok, dir = fullPathObj.getDirectoryAndFilename!()
	if not ok  dir = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"

	local popped = false

	showFileDialog(.OPEN, "Open project", dir, "", filenamePattern="%.hotparticles$", multiple=true,
		onHighlight = (pathObj:Path, fullPathObj:Path) {
			loadPreview(fullPathObj.toString!())
		},
		onChoose = [popped] (pathObj:Path, fullPathObj:Path) {
			local fullPath    = fullPathObj.toString!()
			local ok, project = openProject(fullPath)

			if not ok {
				local input = guiState.getElement!("fileDialog_filename", gui.InputText)
				guiState.setFocus!(input)
				return
			}

			project.preview = false -- In case the project was already opened as a preview (which it probably always is, at least if only one project was chosen).

			if not popped {
				popped = true
				popPanel() -- @Robustness: Preferably we'd like to process all paths, if multiple were chosen, before popping the panel.
			}

			local _, dir = fullPathObj.getDirectory!()
			addRecent(app.recentFolders,  dir,      app.maxRecentFiles)
			addRecent(app.recentProjects, fullPath, app.maxRecentFiles)

			-- Make sure the loaded project replaces any single empty project.
			if #app.projects == 2 and isProjectEmpty(app.projects[1]) {
				remove(app.projects, 1)

				guiState.refreshRecursively!("projects")
				setCurrentProject(1)
			}
		},
		onClose = () {
			unloadPreview()
		}
	)
}



export showRecentFilesContextMenu :: (title:string, recentPaths:[]string, onChoose:(path:string)) {
	local items = {title..":","-"}

	if recentPaths {
		for recentPaths  insert(items, it)
		insert(items, "-")
		insert(items, "Clear history")
	} else {
		insert(items, "(no recent files)")
	}

	guiState.showContextMenu!(items, [*] (choice:int) {
		if choice <= 1 or not recentPaths {
			-- void
		} elseif choice == #recentPaths+2 {
			for recentPaths  recentPaths[itIndex] = NULL
		} else {
			onChoose(recentPaths[choice-1])
		}
	})
}



export copyFrames :: (frames:[]AnimationFrame) -> []AnimationFrame {
	local copy: []AnimationFrame
	for frames {
		copy[itIndex] = {x=it.x, y=it.y, w=it.w, h=it.h}
	}
	return copy
}

export copyFramesTo :: (from:[]AnimationFrame, to:[]AnimationFrame) {
	for from {
		to[itIndex] = {x=it.x, y=it.y, w=it.w, h=it.h}
	}
}



local replaceQuestionMarks :: (project:Project, path:string) -> string {
	if not find(path, "?")  return path

	local filename = "untitled"

	if project.path {
		_, filename = Path(project.path).getFilename!()
		filename    = replacePatternWithPattern(filename, "(.)%.[^.]+", "%1") ?: "untitled"
	}

	return (replace(path, "?", filename))
}

export resolveBaseOuputPath :: (project:Project) -> (success:bool, dir:string) {
	local dirObj = Path(replaceQuestionMarks(project, project.exportBaseDirectory))

	if not dirObj.isAbsolute {
		local ok, dir = Path(project.path).getDirectory!()
		if not ok  return false, NULL
		dirObj.prepend!(dir)
	}

	return true, dirObj.toString!()
}

export resolveParticlesOuputPath :: (project:Project) -> (success:bool, path:string) {
	local pathObj = Path(replaceQuestionMarks(project, project.exportParticlesPath))

	do {
		local ok, filename = pathObj.getFilename!()
		if not ok {
			pathObj.setFilename!(getExportedParticlesDefaultFilename(project))
		} elseif filename == ".." {
			return false, NULL
		}
	}

	if not pathObj.isAbsolute {
		local ok, baseDir = resolveBaseOuputPath(project)
		if not ok  return false, NULL
		pathObj.prepend!(baseDir)
	}

	return true, pathObj.toString!()
}

export resolveTextureOutputDirectory :: (project:Project) -> (success:bool, path:string) {
	local pathObj = Path(replaceQuestionMarks(project, project.exportTexturesDirectory))

	if not pathObj.isAbsolute {
		local ok, baseDir = resolveBaseOuputPath(project)
		if not ok  return false, NULL
		pathObj.prepend!(baseDir)
	}

	return true, pathObj.toString!()
}

export resolveTextureOutputPath :: (project:Project, system:System) -> (success:bool, path:string, sameAsInput:bool) {
	if not system.texturePath {
		local ok, dir = resolveTextureOutputDirectory(project)
		if not ok  return false, NULL, NULL

		local pathObj = Path(dir)
		pathObj.append!(system.textureName..".png")

		return true, pathObj.toString!(), false
	}

	local inputPath: string = NULL
	do {
		local ok, ^inputPath = getFullPathToTexture(project, system)
		if not ok  return false, NULL, NULL
	}

	-- Resolve to current path to see if the texture is inside the base directory already.
	local pathObj = Path(inputPath) -- Always a full path here.

	do {
		local hasBaseDir, baseDir = resolveBaseOuputPath(project)

		if hasBaseDir {
			local baseDirObj = Path(baseDir)
			assert(baseDirObj.isAbsolute)

			if baseDirObj.contains!(pathObj)  return true, inputPath, true
		}
	}

	-- If the path isn't in the base directory, resolve to a completely generated path.
	pathObj = Path(pathObj.path[#pathObj.path]) -- Keep the filename.

	do {
		local ok, dir = resolveTextureOutputDirectory(project)
		if not ok  return false, NULL, NULL
		pathObj.prepend!(dir)
	}

	return true, pathObj.toString!(), false
}

--[[
!run {
	local Test :: struct {
		project: Project,
		expectedBaseDirectory: string,
		expectedParticlesPath: string,
		expectedTexturePaths:  []string,
	}

	local TESTS: []Test : {
		{
			project = {
				fileIsSaved             = true,
				path                    = "C:/MyProject/particles/cool.hotparticles",
				exportBaseDirectory     = "..",
				exportParticlesPath     = "data/particles_?.lua",
				exportTexturesDirectory = "gfxOutput",
				systems                 = {{texturePath="../gfx/cool.png"},{texturePath="D:/Misc/Yes.png"},{texturePath="../../outside.png"},{textureName="star"}},
			},
			expectedBaseDirectory = "C:/MyProject",
			expectedParticlesPath = "C:/MyProject/data/particles_cool.lua",
			expectedTexturePaths  = {"C:/MyProject/gfx/cool.png","C:/MyProject/gfxOutput/Yes.png","C:/MyProject/gfxOutput/outside.png","C:/MyProject/gfxOutput/star.png"},
		},
		{
			project = {
				fileIsSaved             = true,
				path                    = "C:/TheFoo/my.hotparticles",
				exportBaseDirectory     = "",
				exportParticlesPath     = "",
				exportTexturesDirectory = "C:/TheFoo",
				systems                 = {{texturePath="gfx/cat.jpg"},{texturePath="D:/Dogs/Good boy.jpg"}},
			},
			expectedBaseDirectory = "C:/TheFoo",
			expectedParticlesPath = "C:/TheFoo/my.lua",
			expectedTexturePaths  = {"C:/TheFoo/gfx/cat.jpg","C:/TheFoo/Good boy.jpg"},
		},
		{
			project = {
				fileIsSaved             = true,
				path                    = "C:/Place1/very.hotparticles",
				exportBaseDirectory     = "D:/Place2",
				exportParticlesPath     = "E:/Place3/?.lua",
				exportTexturesDirectory = "F:/Place4",
				systems                 = {{texturePath="G:/Place5/the.png"}},
			},
			expectedBaseDirectory = "D:/Place2",
			expectedParticlesPath = "E:/Place3/very.lua",
			expectedTexturePaths  = {"F:/Place4/the.png"},
		},
		{
			project = {
				fileIsSaved             = false,
				path                    = "",
				exportBaseDirectory     = "D:/Place2",
				exportParticlesPath     = "E:/Place3/?.lua",
				exportTexturesDirectory = "F:/Place4",
				systems                 = {{texturePath="G:/Place5/the.png"}},
			},
			expectedBaseDirectory = "D:/Place2",
			expectedParticlesPath = "E:/Place3/untitled.lua",
			expectedTexturePaths  = {"F:/Place4/the.png"},
		},
	}

	for test: TESTS {
		local project = test.project
		print()
		print(project.path)

		print("exportBaseDirectory")
		print("  HAS   ", project.exportBaseDirectory)
		print("  EXPECT", test.expectedBaseDirectory)
		local ok, dir = resolveBaseOuputPath(project)
		assert(ok, "not ok")
		print("  GOT   ", dir)
		assert(dir == test.expectedBaseDirectory, "no match")

		print("exportParticlesPath")
		print("  HAS   ", project.exportParticlesPath)
		print("  EXPECT", test.expectedParticlesPath)
		local ^ok, path = resolveParticlesOuputPath(project)
		assert(ok, "not ok")
		print("  GOT   ", path)
		assert(path == test.expectedParticlesPath, "no match")

		for system: project.systems {
			print("texturePath")
			print("  HAS   ", system.texturePath, "|", system.textureName..".png")
			print("  EXPECT", test.expectedTexturePaths[itIndex])
			ok, path = resolveTextureOutputPath(project, system)
			assert(ok, "not ok")
			print("  GOT   ", path)
			assert(path == test.expectedTexturePaths[itIndex], "no match")
		}
	}

	print("All tests passed!")
	!import"os".exit(2)
}
--]]



export tryExportFiles :: (quick=false) {
	local currentProject = app.projects[app.currentProjectIndex]

	if not (currentProject.exportParticles or currentProject.exportTextures) {
		setErrorText("Nothing to export")
		return
	}

	-- Gather data.
	local particlesData = ""
	local particlesPath = ""

	if currentProject.exportParticles {
		if currentProject.exportParticlesTemplate {
			local ok, ^particlesData = generateDataToExportFromTemplate(currentProject.exportParticlesTemplate, "")
			if not ok  return -- Error already reported.
		} else {
			local ok, fullPath = getFullPathToCustomParticlesTemplate(currentProject)
			if not ok {
				setErrorText("Possibly invalid template path")
				return
			}
			ok, particlesData = generateDataToExportFromTemplate("", fullPath)
			if not ok  return -- Error already reported.
		}

		local ok, ^particlesPath = resolveParticlesOuputPath(currentProject)
		if not ok {
			setErrorText("No particle system output path")
			return
		}
	}

	local texturePaths: []string
	local texturePathSameAsInput: []bool -- We don't copy these ones.

	if currentProject.exportTextures  for currentProject.systems {
		local ok, path, sameAsInput = resolveTextureOutputPath(currentProject, it)

		if not ok {
			setErrorText("Missing texture output path(s)")
			return
		}

		texturePaths[itIndex]           = path
		texturePathSameAsInput[itIndex] = sameAsInput
	}

	-- Check existing files.
	local filesToConfirmOverwrite: []string

	do {
		if currentProject.exportParticles and not currentProject.exportParticlesOverwrite {
			local _, dir, filename = Path(particlesPath).getDirectoryAndFilename!()

			if not connectToRemoteDirectory(dir) {
				setErrorText("Could not access folder '%s'", dir)
				return
			}
			defer disconnectFromRemoteDirectory()

			if getFileInfo(filename)  insert(filesToConfirmOverwrite, particlesPath)
		}

		local texturePathSet: struct { !key:string, !value:bool }

		if currentProject.exportTextures and not currentProject.exportTexturesOverwrite  for currentProject.systems {
			local path = texturePaths[itIndex]

			if texturePathSet[path]  continue
			texturePathSet[path] = true

			if texturePathSameAsInput[itIndex]  continue

			local _, dir, filename = Path(path).getDirectoryAndFilename!()

			if not connectToRemoteDirectory(dir) {
				setErrorText("Could not access folder '%s'", dir)
				return
			}
			defer disconnectFromRemoteDirectory()

			if getFileInfo(filename)  insert(filesToConfirmOverwrite, path)
		}
	}

	-- Write files.
	local writeExportFiles = [currentProject, particlesData, particlesPath, texturePaths, texturePathSameAsInput] () {
		if currentProject.exportParticles {
			local _, dir, filename = Path(particlesPath).getDirectoryAndFilename!()

			if not connectToRemoteDirectory(dir) {
				setErrorText("Could not access folder '%s'", dir)
				return
			}
			defer disconnectFromRemoteDirectory()

			log("Writing %s", particlesPath)
			local ok, err = LF.write(filename, particlesData)
			if not ok {
				setErrorText(err)
				return
			}
		}

		local texturePathSet: struct { !key:string, !value:bool }

		if currentProject.exportTextures  for system: currentProject.systems {
			local path = texturePaths[itIndex]

			if texturePathSet[path] continue
			texturePathSet[path] = true

			if texturePathSameAsInput[itIndex]  continue

			local _, dir, filename = Path(path).getDirectoryAndFilename!()

			if not connectToRemoteDirectory(dir) {
				setErrorText("Could not access folder '%s'", dir)
				return
			}
			defer disconnectFromRemoteDirectory()

			log("Writing %s", path)
			local ok, err = LF.write(filename, system.currentImage.fileData.getString!())
			if not ok {
				setErrorText(err)
				return
			}
		}

		setMessageText("Exported files")
	}

	if filesToConfirmOverwrite {
		local BUTTONS: []gui.Button : {{label="Overwrite"},{label="Cancel"}}

		local text = (
			#filesToConfirmOverwrite == 1
			? "This file will be overwritten:"
			: format("These %d files will be overwritten:", #filesToConfirmOverwrite)
		)

		local fileListEl = guiState.text!({ textIsTooltip=true })
		for filesToConfirmOverwrite  insert(fileListEl.textLines, it)

		pushTempChoiceDialog("Confirm export", text, BUTTONS, submitIndex=1, extraContent=fileListEl, width=DIALOG_WIDTH_EXPORT, [writeExportFiles,quick] (choice:int) {
			if choice ~= 1  return
			writeExportFiles()
			if not quick  popPanel()
		})

	} else {
		writeExportFiles()
		if not quick  popPanel()
	}
}

export generateDataToExportFromTemplate :: (templateName:string, templateFullPath:string) -> (success:bool, data:string) {
	local lua            :: !import "lua"
	local setEnvironment :: (f:(), env:table)              !foreign lua "setfenv"
	local pcall          :: (callback:any) -> bool, string !foreign lua "pcall"

	local path:    string = NULL
	local luaCode: string = NULL

	if templateName {
		path                    = format("%s/%s.lua", EXPORT_TEMPLATES_DIRECTORY, templateName)
		local ok, ^luaCode, err = readEntireFileLocal(path)
		if not ok {
			setErrorText("Could not load template: %s", err)
			return false, ""
		}
	} else {
		path                    = templateFullPath
		local ok, ^luaCode, err = readEntireFileAnywhere(path)
		if not ok {
			setErrorText("Could not load template: %s", err)
			return false, ""
		}
	}

	local ok, chunk, err = lua.loadString(cast(string)luaCode, (), "@"..path)
	if not ok {
		setErrorText("Could not load template: %s", err)
		return false, ""
	}

	-- Prepare data for template.
	local currentProject = app.projects[app.currentProjectIndex]
	local publicParticleSystems: []table

	for system: currentProject.systems {
		-- Note: We use values from the ParticleSystem instead of the System object
		-- whenever possible when exporting as those values are more representable
		-- of what the user expects.
		local ps = system.particles

		local publicParticleSystem: table
		insert(publicParticleSystems, publicParticleSystem)

		do {
			local texturePath       = ""
			local ^ok, _texturePath = resolveTextureOutputPath(currentProject, system)

			if ok {
				local ^ok, basePath = resolveBaseOuputPath(currentProject)
				if ok {
					local ^ok, texturePathObj = Path.getRelativeTo(_texturePath, basePath)
					if ok and texturePathObj.path[1] ~= ".."  texturePath = texturePathObj.toString!()
				}
			}

			publicParticleSystem.texturePath = texturePath
		}

		do {
			local shaderPath     = ""
			local shaderFilename = ""

			local ^ok, shaderPathFull = getFullPathToShader(currentProject, system)
			if ok {
				ok, shaderFilename = Path(system.shaderPath).getFilename!()
				if not ok  shaderFilename = ""

				shaderPath = shaderFilename

				local ^ok, basePath = resolveBaseOuputPath(currentProject)
				if ok {
					local ^ok, shaderPathObj = Path.getRelativeTo(shaderPathFull, basePath)
					if ok and shaderPathObj.path[1] ~= ".."  shaderPath = shaderPathObj.toString!()
				}
			}

			publicParticleSystem.shaderPath     = shaderPath
			publicParticleSystem.shaderFilename = shaderFilename
		}

		publicParticleSystem.blendMode        = system.blendMode
		publicParticleSystem.bufferSize       = getOptimalBufferSize(system)
		publicParticleSystem.customData       = system.customData
		publicParticleSystem.direction        = ps.getDirection!()
		publicParticleSystem.emissionRate     = ps.getEmissionRate!()
		publicParticleSystem.emitAtStart      = system.kickStartEmitEnabled ? system.kickStartEmit : 0
		publicParticleSystem.emitterLifetime  = ps.getEmitterLifetime!()
		publicParticleSystem.insertMode       = ps.getInsertMode!()
		publicParticleSystem.kickStartDt      = getKickStartDt(system)
		publicParticleSystem.kickStartSteps   = system.kickStartStepsEnabled ? system.kickStartSteps : 0
		publicParticleSystem.relativeRotation = ps.hasRelativeRotation!()
		publicParticleSystem.sizes            = cast([]float) { ps.getSizesAsVararg!() }
		publicParticleSystem.sizeVariation    = ps.getSizeVariation!()
		publicParticleSystem.spinVariation    = ps.getSpinVariation!()
		publicParticleSystem.spread           = ps.getSpread!()
		publicParticleSystem.texturePreset    = (system.texturePath == "" or publicParticleSystem.texturePath == "") ? system.textureName : ""
		publicParticleSystem.title            = system.title

		do { local min,max   = ps.getLinearDamping!()          ; publicParticleSystem.linearDamping          = cast(table) {min,max, min=min,max=max} }
		do { local min,max   = ps.getParticleLifetime!()       ; publicParticleSystem.particleLifetime       = cast(table) {min,max, min=min,max=max} }
		do { local min,max   = ps.getRadialAcceleration!()     ; publicParticleSystem.radialAcceleration     = cast(table) {min,max, min=min,max=max} }
		do { local min,max   = ps.getRotation!()               ; publicParticleSystem.rotation               = cast(table) {min,max, min=min,max=max} }
		do { local min,max   = ps.getSpeed!()                  ; publicParticleSystem.speed                  = cast(table) {min,max, min=min,max=max} }
		do { local min,max   = ps.getTangentialAcceleration!() ; publicParticleSystem.tangentialAcceleration = cast(table) {min,max, min=min,max=max} }
		do { local start,end = ps.getSpin!()                   ; publicParticleSystem.spin                   = cast(table) {start,end, atStart=start,atEnd=end} }
		do { local x,y       = ps.getOffset!()                 ; publicParticleSystem.textureOffset          = cast(table) {x,y, x=x,y=y} }

		do {
			local xmin, ymin, xmax, ymax = ps.getLinearAcceleration!()
			publicParticleSystem.linearAcceleration = cast(table) {
				xmin, ymin, xmax, ymax,
				xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax
			}
		}

		do {
			local distribution, dx, dy, angle, relative = ps.getEmissionArea!()
			publicParticleSystem.emissionArea = cast(table) {
				distribution, dx, dy, angle, relative,
				distribution=distribution, dx=dx, dy=dy, angle=angle, relative=relative,
			}
		}

		do {
			local publicColors: []float

			for {ps.getColorsAsVararg!()} {
				insert(publicColors, it[1])
				insert(publicColors, it[2])
				insert(publicColors, it[3])
				insert(publicColors, it[4])
			}

			publicParticleSystem.colors = publicColors
		}

		do {
			local iw, ih = system.currentImage.image.getDimensions!()
			local publicQuads: []table

			for system.frames {
				local publicQuad: table = {
					it.x, it.y, it.w, it.h, iw, ih,
					x=it.x, y=it.y, width=it.w, height=it.h,
				}
				insert(publicQuads, publicQuad)
			}

			publicParticleSystem.textureWidth  = iw
			publicParticleSystem.textureHeight = ih
			publicParticleSystem.quads         = publicQuads
		}

		do {
			local x = 0.0
			local y = 0.0

			if system.emitterOffsetEnabled {
				x = system.emitterOffsetX
				y = system.emitterOffsetY
			}

			publicParticleSystem.emitterOffset = cast(table) {x,y, x=x,y=y}
		}

		-- Deprecated stuff:
		publicParticleSystem.offset = publicParticleSystem.textureOffset
	}

	-- Run template.
	local writeLuaValue :: (buffer:[]string, level:int, v:any) {
		level += 1

		if !complete lua.getType(v) == {
			case .BOOLEAN: !through
			case .NIL:     !through
			case .NUMBER:
				if     v == 0           insert(buffer, "0") -- Avoid writing "-0".
				elseif v == +math.HUGE  insert(buffer, "math.huge")
				elseif v == -math.HUGE  insert(buffer, "(-math.huge)")
				elseif v ~= v           insert(buffer, "(0/0)")
				else                    insert(buffer, format("%s", cast(string)v)) -- The type we cast to doesn't matter here.

			case .STRING:
				local s = replace(format("%q", cast(string)v), "\\\n", "\\n")
				insert(buffer, s)

			case .TABLE: -- Assume it's an array.
				insert(buffer, "{")
				writeLuaCsv(buffer, level, cast([]any)v)
				insert(buffer, "}")

			case .FUNCTION: !through
			case .THREAD:   !through
			case .USERDATA:
				errorf(level, "cannot serialize values of type '%s'", cast(string)lua.getType(v))

			case:
				errorf(level, "values of type '%s' are not supported", cast(string)lua.getType(v))
		}
	}

	local writeLuaCsv :: (buffer:[]string, level:int, arr:[]any) {
		level += 1
		for arr {
			if itIndex > 1  insert(buffer, ", ")
			writeLuaValue(buffer, level, it)
		}
	}

	local buffer: []string

	local exportedValues: table = {
		customData       = currentProject.customData,
		emitterPosition  = {x=currentProject.emitterX, y=currentProject.emitterY, currentProject.emitterX, currentProject.emitterY},
		particleSystems  = publicParticleSystems,
		pixelateTextures = currentProject.pixelateTextures,
	}

	local globals: table = {
		Text = [buffer] (s:string) {
			if lua.getType(s) ~= .STRING {
				errorf(2, "bad argument #1 to 'Text'. (string expected, got %s)", cast(string)lua.getType(s))
			}
			insert(buffer, s)
		},

		Lua = [buffer] (v:any) {
			writeLuaValue(buffer, 2, v)
		},

		LuaCsv = [buffer] (v:any) {
			if lua.getType(v) == .TABLE
				writeLuaCsv(buffer, 2, cast([]any)v)
			else
				writeLuaValue(buffer, 2, v)
		},

		exported = exportedValues,
	}

	for exportedValues  globals[itIndex] = it

	local env = prepareSandbox(globals)
	setEnvironment(chunk, env)

	ok, err = pcall(chunk)
	if not ok {
		setErrorText("Error in template: %s", err)
		return false, ""
	}

	return true, concatenate(buffer)
}



export getExportedParticlesDefaultFilename :: (project:Project) -> string {
	if not project.path  return "untitled.lua"

	local _, filename = Path(project.path).getFilename!()
	filename          = replacePatternWithPattern(filename, "(.)%.[^.]+", "%1") ?: "untitled"
	filename          = filename..".lua"
	return filename
}


