--[[============================================================
--=
--=  Workspace loading and saving
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	loadWorkspace
	saveWorkspace, saveProject

--============================================================]]

local LAST_FILE_VERSION :: 3



local writeValue :: (buffer:[]string, v:int, eol=false) {
	insert(buffer, format(" %d", v))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, v:float, eol=false) {
	insert(buffer, " ")
	insert(buffer, toString(v))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, v:string, eol=false) {
	v = replace(v, "\\", "\\\\")
	v = replace(v, "\n", "\\n")
	insert(buffer, format(" %d %s!", #v, v))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, v:bool, eol=false) {
	insert(buffer, (v ? " true" : " false"))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, arr:[]$T, eol=false) {
	for arr  writeValue(buffer, it)
	if eol  insert(buffer, "\n")
}

local writeValues :: (buffer:[]string, v1,v2:$T, eol=false) {
	writeValue(buffer, v1, eol=false)
	writeValue(buffer, v2, eol=eol)
}

local writeProject :: (buffer:[]string, project:Project, isSavingWorkspace:bool) {
	insert(buffer, ":project\n")

	if isSavingWorkspace {
		if project.path   { insert(buffer, "path") ; writeValue(buffer, eol=true, project.path) }
		if project.edited { insert(buffer, "edited\n") }
	}

	insert(buffer, "bgColor")          ; writeValue(buffer, eol=true, {project.bgColorH, project.bgColorS, project.bgColorV})
	insert(buffer, "bgChecker")        ; writeValue(buffer, eol=true, project.bgChecker)
	insert(buffer, "pixelateWorld")    ; writeValue(buffer, eol=true, project.pixelateWorld)
	insert(buffer, "pixelateTextures") ; writeValue(buffer, eol=true, project.pixelateTextures)
	insert(buffer, "zoom")             ; writeValue(buffer, eol=true, project.zoomLevel)

	insert(buffer, "exportBaseDirectory")      ; writeValue(buffer, eol=true, project.exportBaseDirectory)
	insert(buffer, "exportParticles")          ; writeValue(buffer, eol=true, project.exportParticles)
	insert(buffer, "exportParticlesOverwrite") ; writeValue(buffer, eol=true, project.exportParticlesOverwrite)
	insert(buffer, "exportParticlesTemplate")  ; writeValue(buffer, eol=true, project.exportParticlesTemplate)
	insert(buffer, "exportParticlesPath")      ; writeValue(buffer, eol=true, project.exportParticlesPath)
	insert(buffer, "exportTextures")           ; writeValue(buffer, eol=true, project.exportTextures)
	insert(buffer, "exportTexturesOverwrite")  ; writeValue(buffer, eol=true, project.exportTexturesOverwrite)
	insert(buffer, "exportTexturesDirectory")  ; writeValue(buffer, eol=true, project.exportTexturesDirectory)
	insert(buffer, "exportClipboardTemplate")  ; writeValue(buffer, eol=true, project.exportClipboardTemplate)

	insert(buffer, "movement")
	writeValue(buffer, cast(int) project.movementPreset)
	writeValue(buffer, project.movementScaleX)
	writeValue(buffer, project.movementScaleY)
	writeValue(buffer, project.movementSpeed)
	insert(buffer, "\n")

	for cast(table) project.guiLimits {
		insert(buffer, "guiLimit")
		writeValue(buffer, cast(string) itIndex)
		writeValue(buffer, cast(type_of(project.guiLimits[""])) it)
		insert(buffer, "\n")
	}

	for system: project.systems {
		insert(buffer, ":system\n")

		insert(buffer, "blendMode")        ; writeValue(buffer, eol=true, cast(string) system.blendMode)
		insert(buffer, "colors")           ; writeValue(buffer, eol=true, system.colors)
		insert(buffer, "direction")        ; writeValue(buffer, eol=true, system.psDirection)
		insert(buffer, "emissionRate")     ; writeValue(buffer, eol=true, system.psEmissionRate)
		insert(buffer, "emitterLifetime")  ; writeValue(buffer, eol=true, system.psEmitterLifetime)
		insert(buffer, "insertMode")       ; writeValue(buffer, eol=true, cast(string) system.psInsertMode)
		insert(buffer, "relativeRotation") ; writeValue(buffer, eol=true, system.psRelativeRotation)
		insert(buffer, "sizes")            ; writeValue(buffer, eol=true, system.psSizes)
		insert(buffer, "sizeVariation")    ; writeValue(buffer, eol=true, system.psSizeVariation)
		insert(buffer, "spinVariation")    ; writeValue(buffer, eol=true, system.psSpinVariation)
		insert(buffer, "spread")           ; writeValue(buffer, eol=true, system.psSpread)
		insert(buffer, "texture")          ; writeValue(buffer, eol=true, system.textureName)
		insert(buffer, "texturePath")      ; writeValue(buffer, eol=true, system.texturePath)
		insert(buffer, "scaleTime")        ; writeValue(buffer, eol=true, system.scaleTime)
		insert(buffer, "scaleSpace")       ; writeValue(buffer, eol=true, system.scaleSpace)
		insert(buffer, "scaleSize")        ; writeValue(buffer, eol=true, system.scaleSize)

		insert(buffer, "linearDamping")          ; writeValues(buffer, eol=true, system.psLinearDampingMin,          system.psLinearDampingMax)
		insert(buffer, "offset")                 ; writeValues(buffer, eol=true, system.offsetX,                     system.offsetY)
		insert(buffer, "particleLifetime")       ; writeValues(buffer, eol=true, system.psParticleLifetimeMin,       system.psParticleLifetimeMax)
		insert(buffer, "radialAcceleration")     ; writeValues(buffer, eol=true, system.psRadialAccelerationMin,     system.psRadialAccelerationMax)
		insert(buffer, "rotation")               ; writeValues(buffer, eol=true, system.psRotationMin,               system.psRotationMax)
		insert(buffer, "speed")                  ; writeValues(buffer, eol=true, system.psSpeedMin,                  system.psSpeedMax)
		insert(buffer, "spin")                   ; writeValues(buffer, eol=true, system.psSpinMin,                   system.psSpinMax)
		insert(buffer, "tangentialAcceleration") ; writeValues(buffer, eol=true, system.psTangentialAccelerationMin, system.psTangentialAccelerationMax)

		do {
			insert(buffer, "emissionArea")
			writeValue(buffer, cast(string) system.psEmissionAreaDistribution)
			writeValue(buffer, system.psEmissionAreaDx)
			writeValue(buffer, system.psEmissionAreaDy)
			writeValue(buffer, system.psEmissionAreaAngle)
			writeValue(buffer, system.psEmissionAreaRelative)
			insert(buffer, "\n")
		}
		do {
			insert(buffer, "linearAcceleration")
			writeValue(buffer, system.psLinearAccelerationXmin)
			writeValue(buffer, system.psLinearAccelerationYmin)
			writeValue(buffer, system.psLinearAccelerationXmax)
			writeValue(buffer, system.psLinearAccelerationYmax)
			insert(buffer, "\n")
		}

		if system.frames {
			insert(buffer, "frames")
			for system.frames {
				writeValue(buffer, it.x)
				writeValue(buffer, it.y)
				writeValue(buffer, it.w)
				writeValue(buffer, it.h)
			}
			insert(buffer, "\n")
		}

		for cast(table) system.gui {
			insert(buffer, "gui")
			writeValue(buffer, cast(string) itIndex)
			writeValue(buffer, cast(type_of(system.gui[""])) it)
			insert(buffer, "\n")
		}
	}
}

export saveWorkspace :: () {
	if not workspaceSaveScheduled  return

	-- print("Saving workspace.")

	workspaceSaveScheduled = false
	workspaceSaveDelay     = 0
	workspaceSaveTime      = LT.getTime()

	local projectIndexToSave = 0

	for app.projects  if not it.preview {
		projectIndexToSave += 1
		if itIndex == app.currentProjectIndex  break
	}
	-- Note: projectIndexToSave may be slightly wrong when loaded if the program
	-- exits before closing previews, but that's not the end of the world!

	local buffer: []string
	insert(buffer, format("%d\n", LAST_FILE_VERSION))

	insert(buffer, "stats")               ; writeValue(buffer, eol=true, app.showStats)
	insert(buffer, "showProjectSettings") ; writeValue(buffer, eol=true, app.showProjectSettings)
	insert(buffer, "showPanelNumbers")    ; writeValue(buffer, eol=true, app.showPanelNumbers)
	insert(buffer, "project")             ; writeValue(buffer, eol=true, projectIndexToSave)
	insert(buffer, "recentFiles")         ; writeValue(buffer, eol=true, app.recentFiles)
	insert(buffer, "recentFolders")       ; writeValue(buffer, eol=true, app.recentFolders)
	insert(buffer, "bookmarkedFolders")   ; writeValue(buffer, eol=true, app.bookmarkedFolders)

	for app.projects  if not it.preview {
		writeProject(buffer, it, isSavingWorkspace=true)
	}

	local ok, err = LF.write("workspace", concatinate(buffer))
	if not ok  setErrorText("Could not save workspace: %s", err)
}

export saveProject :: (project:Project, overwrite=false) -> (success:bool, fileExists:bool) {
	local setErrorMessage :: (fileExists:bool, s:string) -> (success:bool, fileExists:bool) {
		setErrorText(s)
		return false, fileExists
	}
	local setErrorMessage :: (fileExists:bool, s:string, v,...:int|float|string) -> (success:bool, fileExists:bool) {
		setErrorText(s, v, ...)
		return false, fileExists
	}

	local ok, dir, filename = Path(project.path).getDirectoryAndFilename!()
	if not ok  return setErrorMessage(false, "Invalid path '%s'", project.path)

	ok = connectToRemoteDirectory(dir)
	if not ok  return setErrorMessage(false, "Could not access folder '%s'", dir)
	defer disconnectFromRemoteDirectory()

	addRecent(app.recentFolders, dir, MAX_RECENT_FOLDERS)

	if not overwrite {
		local info = LF.getInfo(filename)
		if info ~= nil  return false, true
	}

	local buffer: []string
	insert(buffer, format("%d\n", LAST_FILE_VERSION))

	writeProject(buffer, project, isSavingWorkspace=false)

	local ^ok, err = LF.write(filename, concatinate(buffer))
	if not ok  return setErrorMessage(false, "Could not write project to file: %s", err)

	addRecent(app.recentFiles, project.path, MAX_RECENT_FILES)

	project.fileIsSaved   = true
	project.displayedName = filename
	project.edited        = false

	gui.refreshRecursively(guiState, "projects")
	scheduleSaveWorkspace()
	setMessageText("Saved '%s'", project.displayedName)
	return true, false
}



local parsingError :: (path:string, ln:int, s:string, ...:int|float|string) -> (success:bool, gotError:bool, app:App) {
	printf("Error: %s:%d: "..s, path, ln, ...)
	return false, true, NULL
}

local readInt :: (version:int, line:string, ptr:int) -> (success:bool, ptr:int, n:int) {
	local found, nStr, _ptr = matchPattern(line, "^ +(%-?%d+)()", ptr)
	if not found  return false, NULL, NULL

	local ok, n = stringToInt(cast(string)nStr)
	if not ok  return false, NULL, NULL

	return true, cast(int)_ptr, n
}
local readFloat :: (version:int, line:string, ptr:int) -> (success:bool, ptr:int, n:float) {
	local         found, nStr, _ptr = matchPattern(line, "^ +(%-?%d*%.?%d+[Ee][-+]?%d+)()", ptr)
	if not found  found, nStr, _ptr = matchPattern(line, "^ +(%-?%d*%.?%d+)()",             ptr)
	if not found  return false, NULL, NULL

	local ok, n = stringToFloat(cast(string)nStr)
	if not ok  return false, NULL, NULL

	return true, cast(int)_ptr, n
}

local readBool :: (version:int, line:string, ptr:int) -> (success:bool, ptr:int, b:bool) {
	local found, boolStr, _ptr = matchPattern(line, "^ +(%S+)()", ptr)
	if not found  return false, NULL, NULL

	if boolStr == {
		case "true":  return true,  cast(int)_ptr, true
		case "false": return true,  cast(int)_ptr, false
		case:         return false, NULL,          NULL
	}
}

local readString :: (version:int, line:string, ptr:int) -> (success:bool, ptr:int, s:string) {
	-- Strings consist of a length (int) and then the actual string.
	local ok, ^ptr, len = readInt(version, line, ptr)
	if not ok  return false, NULL, NULL

	if line[ptr] ~= !char " "  return false, NULL, NULL
	ptr += 1

	local v = getSubstring(line, ptr, ptr+len-1)
	if #v ~= len  return false, NULL, NULL
	ptr += len

	if version > 2 {
		if line[ptr] ~= !char "!"  return false, NULL, NULL
		ptr += 1
	}

	local gotError = false
	v = replacePatternWithFunction(v, "\\(.)", [gotError] (c:string) -> string|none {
		if c == "n"   return "\n"
		if c == "\\"  return "\\"
		gotError = true
		return nil
	})
	if gotError  return false, NULL, NULL

	return true, ptr, v
}

local readIntArray :: (version:int, line:string, ptr:int) -> (success:bool, ptr:int, arr:[]int) {
	local arr: []int

	while ptr <= #line {
		local ok, _ptr, n = readInt(version, line, ptr)
		if not ok  return false, NULL, NULL

		ptr = cast(int) _ptr
		insert(arr, n)
	}

	return true, ptr, arr
}
local readFloatArray :: (version:int, line:string, ptr:int) -> (success:bool, ptr:int, arr:[]float) {
	local arr: []float

	while ptr <= #line {
		local ok, _ptr, n = readFloat(version, line, ptr)
		if not ok  return false, NULL, NULL

		ptr = cast(int) _ptr
		insert(arr, n)
	}

	return true, ptr, arr
}
local readStringArray :: (version:int, line:string, ptr:int) -> (success:bool, ptr:int, arr:[]string) {
	local arr: []string

	while ptr <= #line {
		local ok, _ptr, n = readString(version, line, ptr)
		if not ok  return false, NULL, NULL

		ptr = cast(int) _ptr
		insert(arr, n)
	}

	return true, ptr, arr
}

export loadWorkspace :: (path:string) -> (success:bool, gotError:bool, app:App) {
	local file, err = LF.newFile(path, LF.FileMode.READ)
	if file == NULL  return false, false, NULL
	defer (cast(LF.File)file).close!()

	local app: App !shadow
	local projects = app.projects

	do {
		local project: Project = NULL
		local system:  System  = NULL

		local ln   = 0
		local iter = (cast(LF.File)file).lines!()

		local version: int
		do {
			local line1 = iter(nil, nil)
			if line1 == nil  return parsingError(path, ln, "Missing file version.")

			local ok, ^version = stringToInt(cast(string) line1)
			if not ok                       return parsingError(path, ln, "Invalid version line format.")
			if version < 1                  return parsingError(path, ln, "Invalid version number '%d'.", version)
			if version > LAST_FILE_VERSION  return parsingError(path, ln, "Unsupported version number '%d'.", version)
		}

		for line in iter, nil, nil {
			ln += 1
			if line == ""  continue

			if line[1] == !char ":" {
				local label = getSubstring(line, 2)

				if label == {
					case "project":
						project = Project()
						system  = NULL
						insert(projects, project)

					case "system":
						if project == NULL  return parsingError(path, ln, "Unexpected 'system' label.")
						system = System()
						insert(project.systems, system)

					case:
						return parsingError(path, ln, "Unknown label '%s'.", label)
				}

				continue
			}

			local ok, param, ptr = matchPattern(line, "(%S+)()")
			if not ok  return parsingError(path, ln, "Bad parameter line format: %s", line)

			if project == NULL {
				if param == {
					case "stats":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.showStats = flag
					case "showProjectSettings":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.showProjectSettings = flag
					case "showPanelNumbers":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.showPanelNumbers = flag

					case "project":
						local ^ok, ^ptr, i = readInt(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.currentProjectIndex = i

					case "recentFiles":
						local ^ok, ^ptr, paths = readStringArray(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.recentFiles = paths
					case "recentFolders":
						local ^ok, ^ptr, paths = readStringArray(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.recentFolders = paths

					case "bookmarkedFolders":
						local ^ok, ^ptr, paths = readStringArray(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.bookmarkedFolders = paths

					case:
						return parsingError(path, ln, "Unknown program parameter '%s'.", param)
				}

			} elseif system == NULL {
				if param == {
					case "path":
						local ^ok, ^ptr, savedPath = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)

						project.path        = savedPath
						project.fileIsSaved = true

						local ^ok, filename = Path.getFilename(savedPath)
						if ok  project.displayedName = filename

					case "edited":
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.edited = true

					case "bgColor":
						local ^ok, ^ptr, h = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, s = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, v = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						if version < 2  h, s, v = rgbToHsv(h, s, v)
						project.bgColorH = h
						project.bgColorS = s
						project.bgColorV = v

					case "bgChecker":
						local ^ok, ^ptr, amount = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.bgChecker = amount

					case "pixelateWorld":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.pixelateWorld = flag
					case "pixelateTextures":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.pixelateTextures = flag

					case "zoom":
						local ^ok, ^ptr, zoomLevel = readInt(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.zoomLevel  = zoomLevel
						project.zoom       = 2^zoomLevel
						project.zoomSource = project.zoom
						project.zoomTarget = project.zoom

					case "exportBaseDirectory":
						local ^ok, ^ptr, dir = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportBaseDirectory = dir
					case "exportParticles":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportParticles = flag
					case "exportParticlesOverwrite":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportParticlesOverwrite = flag
					case "exportParticlesTemplate":
						local ^ok, ^ptr, name = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportParticlesTemplate = name
					case "exportParticlesPath":
						local ^ok, ^ptr, pathValue = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportParticlesPath = pathValue
					case "exportTextures":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportTextures = flag
					case "exportTexturesOverwrite":
						local ^ok, ^ptr, flag = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportTexturesOverwrite = flag
					case "exportTexturesDirectory":
						local ^ok, ^ptr, dir = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportTexturesDirectory = dir
					case "exportClipboardTemplate":
						local ^ok, ^ptr, name = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.exportClipboardTemplate = name

					case "movement":
						local ^ok, ^ptr, preset = readInt  (version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, sx     = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, sy     = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, speed  = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.movementPreset = cast(Movement) preset -- @Robustness: Validate enum value.
						project.movementScaleX = sx
						project.movementScaleY = sy
						project.movementSpeed  = speed

					case "guiLimit":
						local ^ok, ^ptr, name  = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, limit = readFloat (version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.guiLimits[name] = limit

					case:
						return parsingError(path, ln, "Unknown project parameter '%s'.", param)
				}

			} else {
				if param == {
					case "colors":
						local ^ok, ^ptr, colors = readFloatArray(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if #colors % 4   ~= 0     return parsingError(path, ln, "Bad color array format: %s", line)
						if colors[1]     == NULL  return parsingError(path, ln, "No colors.")
						if colors[8*4+1] ~= NULL  return parsingError(path, ln, "Too many colors. (Max is 8, got %d)", #colors // 4)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						if version < 2 {
							for i = 1, #colors, 4 {
								colors[i], colors[i+1], colors[i+2] = rgbToHsv(colors[i], colors[i+1], colors[i+2])
							}
						}
						system.colors = colors

					case "blendMode":
						local ^ok, ^ptr, blendMode = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.blendMode = cast(LG.BlendMode) blendMode -- @Robustness: Validate enum value.

					case "texture":
						local ^ok, ^ptr, textureName = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.textureName = textureName

					case "texturePath":
						local ^ok, ^ptr, texturePath = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.texturePath = texturePath

					case "bufferSize":
						-- void @Obsolete

					case "direction":
						local ^ok, ^ptr, dir = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psDirection = dir

					case "emissionRate":
						local ^ok, ^ptr, rate = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psEmissionRate = rate

					case "emitterLifetime":
						local ^ok, ^ptr, lifetime = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psEmitterLifetime = lifetime

					case "insertMode":
						local ^ok, ^ptr, mode = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psInsertMode = cast(LG.ParticleInsertMode) mode -- @Robustness: Validate enum value.

					case "relativeRotation":
						local ^ok, ^ptr, relative = readBool(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psRelativeRotation = relative

					case "sizes":
						local ^ok, ^ptr, sizes = readFloatArray(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if sizes[1]   == NULL     return parsingError(path, ln, "No sizes.")
						if sizes[8+1] ~= NULL     return parsingError(path, ln, "Too many sizes. (Max is 8, got %d)", #sizes)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psSizes = sizes

					case "sizeVariation":
						local ^ok, ^ptr, variation = readFloat(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psSizeVariation = variation

					case "spinVariation":
						local ^ok, ^ptr, variation = readFloat(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psSpinVariation = variation

					case "spread":
						local ^ok, ^ptr, spread = readFloat(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psSpread = spread

					case "scaleTime":
						local ^ok, ^ptr, scale = readFloat(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.scaleTime = scale

					case "scaleSpace":
						local ^ok, ^ptr, scale = readFloat(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.scaleSpace = scale

					case "scaleSize":
						local ^ok, ^ptr, scale = readFloat(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.scaleSize = scale

					case "linearDamping":
						local ^ok, ^ptr, min = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psLinearDampingMin = min
						system.psLinearDampingMax = max

					case "particleLifetime":
						local ^ok, ^ptr, min = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psParticleLifetimeMin = min
						system.psParticleLifetimeMax = max

					case "radialAcceleration":
						local ^ok, ^ptr, min = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psRadialAccelerationMin = min
						system.psRadialAccelerationMax = max

					case "rotation":
						local ^ok, ^ptr, min = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psRotationMin = min
						system.psRotationMax = max

					case "speed":
						local ^ok, ^ptr, min = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psSpeedMin = min
						system.psSpeedMax = max

					case "spin":
						local ^ok, ^ptr, min = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psSpinMin = min
						system.psSpinMax = max

					case "tangentialAcceleration":
						local ^ok, ^ptr, min = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psTangentialAccelerationMin = min
						system.psTangentialAccelerationMax = max

					case "offset":
						local ^ok, ^ptr, x = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, y = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.offsetX = x
						system.offsetY = y

					case "emissionArea":
						local ^ok, ^ptr, distribution = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, dx           = readFloat (version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, dy           = readFloat (version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, angle        = readFloat (version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, relative     = readBool  (version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psEmissionAreaDistribution = cast(LG.AreaSpreadDistribution) distribution -- @Robustness: Validate enum value.
						system.psEmissionAreaDx           = dx
						system.psEmissionAreaDy           = dy
						system.psEmissionAreaAngle        = angle
						system.psEmissionAreaRelative     = relative

					case "linearAcceleration":
						local ^ok, ^ptr, xmin = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, ymin = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, xmax = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, ymax = readFloat(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.psLinearAccelerationXmin = xmin
						system.psLinearAccelerationYmin = ymin
						system.psLinearAccelerationXmax = xmax
						system.psLinearAccelerationYmax = ymax

					case "frames":
						local ^ok, ^ptr, values = readIntArray(version, line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad animation frame array format: %s", line)
						if #values % 4 ~= 0       return parsingError(path, ln, "Bad animation frame array format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)

						for 1, #values, 4 {
							local animFrame: AnimationFrame = {
								x = values[it  ],
								y = values[it+1],
								w = values[it+2],
								h = values[it+3],
							}
							insert(system.frames, animFrame)
						}

					case "gui":
						local ^ok, ^ptr, name  = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, value = readString(version, line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.gui[name] = value

					case:
						return parsingError(path, ln, "Unknown project parameter '%s'.", param)
				}
			}
		}

		if not projects  return parsingError(path, ln, "No projects.")
	}

	for project: projects {
		if not project.systems  return parsingError(path, 0, "Missing systems for at least one project.")

		for project.systems {
			updateParticleParams(it) -- Needed for updateBufferSize().
			updateBufferSize(it.particles)
		}
	}

	return true, false, app
}


