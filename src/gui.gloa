--[[============================================================
--=
--=  Retained-mode GUI
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	State

	Buttons, Radio, Tabs
	Canvas
	Checkbox
	Direction
	Frame
	Hbox, Vbox
	InputText
	Scrollable
	Section
	Separator
	Slider, Color, ColorPreview
	Text

	delete
	draw
	drawChecker, drawCheckerBox
	getElement, getElementAt, getWidgetAt, findParent
	getTopmostActiveModal
	isElementVisible
	isInsideElement, isOverGui
	onKeyPressed, onKeyReleased, onTextInput
	onMousePressed, onMouseMoved, onMouseReleased, onMouseWheel
	pressButton
	refresh, refreshRecursively, refreshAll
	setActive
	setFocus, blurFocus
	showMenu, showContextMenu, showContextMenuWithInput, hideContextMenu
	update

--============================================================]]



export SPACING       :: 3
export SPACING_LARGE :: 10

local BUTTON_RADIUS    :: 3
local BUTTON_PADDING_Y :: 2

export SCROLLABLE_PADDING   :: 5 -- Vertical.
export SCROLLBAR_WIDTH      :: 8
export SCROLLBAR_MIN_LENGTH :: 16

local SECTION_DEFAULT_LABEL_WIDTH :: 100

local SLIDER_MIN_WIDTH    :: 12
local SLIDER_MIN_LENGTH   :: 70
local COLOR_PREVIEW_WIDTH :: 24

local INPUT_MIN_WIDTH :: 40

local CHECKBOX_SIZE :: 14 -- @Temp until we have an image.

local DIRECTION_RADIUS :: 25

local BUTTON_IMAGE_MAX_SIZE :: 18
local PARTICLE_PREVIEW_SIZE :: 30
local SPECIAL_TAB_WIDTH     :: 32

local TAB_BOTTOM_LINE_WIDTH :: 2

export TEXT_OPACITY                 :: .85
local  HOVER_OUTLINE_OPACITY        :: .3
local  HOVER_OUTLINE_OPACITY_STRONG :: .7

local DRAG_RADIUS :: 8 -- Distance moved before dragging starts for real.

local CONTEXT_MENU_MIN_WIDTH :: 150



export clipboardScalar = 0.0
export clipboardAngle  = 0.0
export clipboardColor: []float = {0,0,0,0}
export hasClipboardScalar = false
export hasClipboardAngle  = false
export hasClipboardColor  = false



export State :: struct {
	frames:      []Frame,
	scrollables: []Scrollable,

	elementsById:   struct { !key: int,    !value: Element },
	elementsByName: struct { !key: string, !value: Element },

	nextId = 1,

	hoveredId    = 0,
	hoveredSubid = 0,

	activeId       = 0,
	activeSubid    = 0,
	activeMod      = ModifierKey.NONE,
	activeStartMx  = 0,
	activeStartMy  = 0,
	activeDragging = false, -- For the drag event - not for sliders etc.!

	focusId = 0, -- Keyboard focus.

	currentTooltip = "",
	tooltipTime    = 0.00,
	tooltipX       = 0,
	tooltipY1      = 0, -- Primary.
	tooltipY2      = 0, -- Fallback.

	layoutNeedsUpdate = true,

	extraScrollableSpace = 0,

	contextMenus: []Frame,

	scrollbarHandleDragOffset = 0,

	onRefresh:      struct { !key:string, !value:any--[[ (el:Element) ]] },
	onActive:       struct { !key:string, !value:any--[[ (el:Element) ]] },
	onInactive:     struct { !key:string, !value:any--[[ (el:Element) ]] },
	onSubmit:       struct { !key:string, !value:any--[[ (el:Element) ]] },
	onBeforeAction: struct { !key:string, !value:any--[[ (widget:Widget, subid:int) -> (ignore:bool) ]] }, -- Only used for Radio and Tabs.
	onBegin:        struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onAction:       struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onEnd:          struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onDouble:       struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onOption:       struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onClose:        struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onDragBegin:    struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onDrag:         struct { !key:string, !value:any--[[ (widget:Widget, subid:int, mx,my:int) ]] },
	onDragEnd:      struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onMouseEnter:   struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onDraw:         struct { !key:string, !value:any--[[ (canvas:Canvas, cw,ch:int) ]] },

	buttons      :: (state:State, el:Buttons)      -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	canvas       :: (state:State, el:Canvas)       -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	checkbox     :: (state:State, el:Checkbox)     -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	color        :: (state:State, el:Color)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	colorPreview :: (state:State, el:ColorPreview) -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	direction    :: (state:State, el:Direction)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	frame        :: (state:State, el:Frame)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	hbox         :: (state:State, el:Hbox)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	inputText    :: (state:State, el:InputText)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	radio        :: (state:State, el:Radio)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	scrollable   :: (state:State, el:Scrollable)   -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	section      :: (state:State, el:Section)      -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	separator    :: (state:State, el:Separator)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	slider       :: (state:State, el:Slider)       -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	tabs         :: (state:State, el:Tabs)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	text         :: (state:State, el:Text)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	vbox         :: (state:State, el:Vbox)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },

	-- @Cleanup: Use !self here istead of _*, maybe.  (@Compiler: We get redeclaration error becase !self.getElement etc. isn't a simple identifier.)
	blurFocus :: _blurFocus,
	delete :: _delete,
	draw :: _draw,
	findParent :: _findParent,
	getElement :: _getElement,
	getElementAt :: _getElementAt,
	getScrollOffset :: _getScrollOffset,
	getTopmostActiveModal :: _getTopmostActiveModal,
	getWidgetAt :: _getWidgetAt,
	hideContextMenu :: _hideContextMenu,
	isElementVisible :: _isElementVisible,
	isInsideElement :: _isInsideElement,
	isOverGui :: _isOverGui,
	onFocus :: _onFocus,
	onKeyPressed :: _onKeyPressed,
	onKeyReleased :: _onKeyReleased,
	onMouseMoved :: _onMouseMoved,
	onMousePressed :: _onMousePressed,
	onMouseReleased :: _onMouseReleased,
	onMouseWheel :: _onMouseWheel,
	onTextInput :: _onTextInput,
	pressButton :: _pressButton,
	refresh :: _refresh,
	refreshAll :: _refreshAll,
	refreshRecursively :: _refreshRecursively,
	scrollTo :: _scrollTo,
	setActive :: _setActive,
	setFocus :: _setFocus,
	showContextMenu :: _showContextMenu,
	showContextMenuWithInput :: _showContextMenuWithInput,
	showMenu :: _showMenu,
	update :: _update,
}

local _blurFocus :: blurFocus
local _delete :: delete
local _draw :: draw
local _findParent :: findParent
local _getElement :: getElement
local _getElementAt :: getElementAt
local _getScrollOffset :: getScrollOffset
local _getTopmostActiveModal :: getTopmostActiveModal
local _getWidgetAt :: getWidgetAt
local _hideContextMenu :: hideContextMenu
local _isElementVisible :: isElementVisible
local _isInsideElement :: isInsideElement
local _isOverGui :: isOverGui
local _onFocus :: onFocus
local _onKeyPressed :: onKeyPressed
local _onKeyReleased :: onKeyReleased
local _onMouseMoved :: onMouseMoved
local _onMousePressed :: onMousePressed
local _onMouseReleased :: onMouseReleased
local _onMouseWheel :: onMouseWheel
local _onTextInput :: onTextInput
local _pressButton :: pressButton
local _refresh :: refresh
local _refreshAll :: refreshAll
local _refreshRecursively :: refreshRecursively
local _scrollTo :: scrollTo
local _setActive :: setActive
local _setFocus :: setFocus
local _showContextMenu :: showContextMenu
local _showContextMenuWithInput :: showContextMenuWithInput
local _showMenu :: showMenu
local _update :: update



local register :: (state:State, el:Element, T:Type) -> Element {
	el.type = T
	el.id   = state.nextId
	state.nextId += 1

	state.elementsById[el.id] = el
	if el.name  state.elementsByName[el.name] = el

	if T == {
		case Scrollable: insert(state.scrollables, cast(Scrollable) el)
	}

	return el
}

local unregisterTree :: (state:State, el:Element) {
	state.elementsById[el.id] = NULL
	if el.name  state.elementsByName[el.name] = NULL

	if el.type == {
		case Scrollable: local found, i = indexOf(state.scrollables, cast(Scrollable) el) ; assert(found) ; remove(state.scrollables, i)
	}

	for el  unregisterTree(state, it)
}



export Style :: enum { NORMAL, CONTEXT_MENU, LIST }

export Element :: struct {
	active         = true,
	name           = "",
	label          = "",
	labelLeft      = "",
	labelLeftAlign = Alignment.CENTER,
	tooltip        = "",
	weight         = .0,
	inset          = 0,
	width          = 0, -- Zero means automatic.
	height         = 0, -- Zero means automatic. For scrollables, non-positive means distance from the bottom of the screen.
	minWidth       = 0,
	minHeight      = 0,
	maxWidth       = -1, -- Negative means no limit.
	maxHeight      = -1, -- Negative means no limit.
	style          = Style.NORMAL,
	data:     any,
	dataTemp: any,

	type: Type = NULL,
	id:   int  = NULL,

	frame:  Frame   = NULL,
	parent: Element = NULL,
	!value: Element, -- Children.

	layoutX: int,
	layoutY: int,
	layoutHeight: int,
	layoutWidth:  int,
}

export Widget :: struct {
	using Element,
}



export Layout :: enum { DOCKED, FLOATING }

export Frame :: struct {
	using Element,

	layout = Layout.DOCKED,
	modal  = false,
	temp   = false,
	x      = -1, -- Negative means centered. Only used if floating.
	y      = -1, -- Negative means centered. Only used if floating.

	parentFrame: Frame = NULL,
}



export Scrollable :: struct {
	using Widget,

	-- ...

	contentHeight: int,

	scroll       = 0.0,
	scrollSource = 0.0,
	scrollTarget = 0,
}

export Section :: struct {
	using Widget,

	icon16     = "",
	labelWidth = SECTION_DEFAULT_LABEL_WIDTH,
}

local Box :: struct {
	-- expandChildren = true,

	using Element,
}
export Hbox :: struct {
	using Box,
}
export Vbox :: struct {
	using Box,
}



export Text :: struct {
	using Element,

	text = "",
	textLines: []string,
	size = 2, -- 1=small, 2=normal, 3=large

	textHeight = 0,
}

export Separator :: struct {
	using Element,

	thick = false,
}



export Button :: struct {
	name     = "", -- Inherited from parent if empty.
	label    = "",
	suffix   = "", -- Appears faded after the label.
	shortcut = "", -- Appears on the right side. Requires the parent's Buttons.align to be LEFT to work properly.
	image    = "",
	tooltip  = "",
	value: any,
	draggable   = false,
	submenuIcon = false,
	system: System = NULL,

	imageScale = 1.0,

	labelWidth    = 0,
	suffixWidth   = 0,
	shortcutWidth = 0,
	contentWidth  = 0,
}

export Alignment :: enum { CENTER, LEFT, RIGHT, TOP, BOTTOM }

export Buttons :: struct {
	using Widget,

	buttons: []Button,
	align           = Alignment.CENTER,
	vertical        = false,
	buttonMinHeight = 0,

	buttonWidth:  float, -- Round when necessary!
	buttonHeight: float, -- Round when necessary!
}

export Radio :: struct {
	using Buttons,

	index = 1,
}

export Tabs :: struct {
	using Radio,

	specialLastTab = false,
}



export Checkbox :: struct {
	using Widget,

	checked = false,
}



export Slider :: struct {
	using Widget,

	-- Settings:
	value = 0.0,

	min = 0.0,
	max = 1.0,

	steps = 32,

	limitName   = "",
	limitCenter = 0.0,

	linkMultiDrag: []string,

	readoutMulti = 1.0,
	readout      = "",
	readoutZero  = "",

	isInt       = false,
	exponential = false,
	--
}

export Color :: struct {
	using Widget,

	alpha = true,
	color: []float = {0,0,1,1}, -- {r,g,b,a}
	linkMultiDrag: []string,

	sliderWidth = 0.0, -- Round when necessary!
}



export ColorPreview :: struct {
	using Widget,

	linkColors: []string,
	blendMode = LG.BlendMode.ALPHA,
}



export Direction :: struct {
	using Widget,

	angle      = 0.0,
	linkOther  = "",
	linkSpread = "",
	linkMultiDrag: []string,
}



export InputText :: struct {
	using Widget,

	value = "",

	field: InputField = NULL,
}



export Canvas :: struct {
	using Widget,
}



export MenuItem :: struct {
	name:     string,
	data:     any,
	label:    string,
	shortcut: string,
	submenu:  []MenuItem,

	submenuFrame: Frame = NULL,
}



export onKeyPressed :: (state:State, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (handled:bool) {
	-- Modifier keys.
	if (state.activeId or state.hoveredId) and (key == lctrl or key == rctrl or key == "lshift" or key == "rshift" or key == "lalt" or key == "ralt") {
		local mx, my = LM.getPosition()
		state.onMouseMoved!(mx, my, 0, 0)
	}
	if state.activeId  return true

	--   escape other  situation
	-- ----------------------------------------------
	--   pass   pass   nothing
	-- * blur   input  normal input focused
	-- * close  eat    normal input focused + context menu
	--   close  eat    context menu
	-- * blur   input  context menu + inner input focused

	-- Key events for inputs (which may be in a context menu).
	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]

		-- Input outside context menu.
		if state.contextMenus and not indexOf(state.contextMenus, input.frame) {
			if key == "escape"  state.hideContextMenu!(mayDeactivateSubmenu=true)
			return true
		}

		if key == "escape" {
			state.blurFocus!(abort=true)
		} elseif key == "return" or key == "kpenter" {
			state.blurFocus!(abort=false)
			triggerSubmitEvent(state, input)
		} else {
			input.field.keypressed!(key, scancode, isRepeat)
		}
		return true
	}

	-- Context menu.
	if state.contextMenus {
		if key == "escape"  state.hideContextMenu!(mayDeactivateSubmenu=true)
		return true
	}

	-- Submit modals.
	if key == "return" or key == "kpenter" {
		local topModal = state.getTopmostActiveModal!()

		if topModal ~= NULL {
			triggerSubmitEvent(state, topModal)
			return true
		}
	}

	-- Key events for other widgets.
	local widget = cast(Widget) state.elementsById[state.hoveredId]
	local mod    = getModifierKey()

	if widget ~= NULL  if widget.type == {
		case Direction:
			local direction = cast(Direction) widget

			if (mod == .NONE or mod == .S or mod == .C) and (key == "left" or key == "right") {
				local delta = math.TAU * ((mod == .S) ? 22.5/360 : (mod == .C) ? 1/360 : 5/360)

				triggerBeginEvent(state, direction, "", 0)
				direction.angle = ((key == "left" ? direction.angle-delta : direction.angle+delta) + math.PI) % math.TAU - math.PI
				triggerActionEvent(state, direction, "", 0, alsoEnd=true)

				return true
			}

		case Slider:
			local slider = cast(Slider) widget

			if (mod == .NONE or mod == .S or mod == .C) and (key == "left" or key == "right") {
				local delta = (
					slider.isInt
					? ((mod == .S) ? 20 : (mod == .C) ? 1 : 5)
					: (
						(slider.max - slider.min)
						* getLimitMultiplier(slider)
						/ ((mod == .S) ? 16 : (mod == .C) ? 1024 : 128)
					)
				)

				triggerBeginEvent(state, slider, "", 0)
				slider.value = math.clamp(
					slider.value + delta * (key == "left" ? -1 : 1),
					applyLimitMultiplier(slider, slider.min),
					applyLimitMultiplier(slider, slider.max)
				)
				triggerActionEvent(state, slider, "", 0, alsoEnd=true)

				return true
			}

		case Color:
			local colorEl = cast(Color) widget

			if (mod == .NONE or mod == .S or mod == .C) and (key == "left" or key == "right") {
				local component = state.hoveredSubid

				local delta = (
					component == 1
					? ((mod == .S) ? 30  : (mod == .C) ? 1  : 6) / 360
					: ((mod == .S) ? 7.5 : (mod == .C) ? .5 : 2) / 100
				)

				triggerBeginEvent(state, colorEl, "", component)
				colorEl.color[component] = math.clamp01(key == "left" ? colorEl.color[component]-delta : colorEl.color[component]+delta)
				triggerActionEvent(state, colorEl, "", component, alsoEnd=true)

				return true
			}
	}

	return false
}

export onKeyReleased :: (state:State, key:LK.KeyConstant, scancode:LK.Scancode) {
	if (state.activeId or state.hoveredId) and (key == lctrl or key == rctrl or key == "lshift" or key == "rshift" or key == "lalt" or key == "ralt") {
		local mx, my = LM.getPosition()
		state.onMouseMoved!(mx, my, 0, 0)
	}
}

export onTextInput :: (state:State, text:string) -> (handled:bool) {
	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]

		-- Input outside context menu.
		if state.contextMenus and not indexOf(state.contextMenus, input.frame) {
			return true
		}

		input.field.textinput!(text)
		return true
	}

	return false
}

export onMousePressed :: (state:State, mx,my:int, mbutton:int, presses:int) -> (handled:bool) {
	updateLayoutIfNeeded(state)

	if state.focusId {
		if state.hoveredId == state.focusId {
			local input = cast(InputText) state.elementsById[state.focusId]
			input.field.mousepressed!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input)), mbutton, presses)
		} else {
			state.blurFocus!(abort=false)
		}
	}

	for < frame: state.frames  if state.isInsideElement!(mx, my, frame) {
		if (mbutton == 1 or mbutton == 2) and state.hoveredId and not state.focusId {
			local input = cast(InputText) state.elementsById[state.hoveredId]
			if input.type == InputText {
				state.setFocus!(input)
				input.field.mousepressed!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input)), mbutton, presses)
			}
		}

		if mbutton == 1 and state.hoveredId {
			local el      = state.elementsById[state.hoveredId]
			local buttons = cast(Buttons) el
			local slider  = cast(Slider)  el

			if el.type == Buttons and (buttons.style == .CONTEXT_MENU or buttons.style == .LIST) {
				local handled = false
				if presses % 2 == 0 {
					handled = triggerDoublePressEvent(state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid)
				}
				if not handled {
					triggerBeginEvent (state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid)
					triggerActionEvent(state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid, alsoEnd=true)
				}

			} elseif el.type == Slider and presses % 2 == 0 and triggerDoublePressEvent(state, slider, "", 0) {
				-- void

			} else {
				state.activeId      = state.hoveredId
				state.activeSubid   = state.hoveredSubid
				state.activeMod     = getModifierKey()
				state.activeStartMx = mx
				state.activeStartMy = my

				LM.setGrabbed(true)
				LK.setKeyRepeat(false)

				if el.type == Scrollable {
					local scrollable           = cast(Scrollable) el
					local handlePos, handleLen = getScrollbarHandle(scrollable, visual=false)

					if my >= scrollable.layoutY+handlePos and my < scrollable.layoutY+handlePos+handleLen {
						state.scrollbarHandleDragOffset = - (my - scrollable.layoutY - handlePos)
					} else {
						state.scrollbarHandleDragOffset = - (handleLen // 2)
					}
				}

				state.onMouseMoved!(mx, my, 0, 0, begin=true)
			}
		}

		if state.contextMenus and not indexOf(state.contextMenus, frame)  state.hideContextMenu!()
		return true
	}

	state.hideContextMenu!()
	return state.activeId > 0 or state.getTopmostActiveModal!() ~= NULL
}

export onMouseMoved :: (state:State, mx,my:int, dx,dy:int, begin=false, end=false) {
	updateLayoutIfNeeded(state)

	local updateMouseCursor :: (state:State) {
		using currentCursor

		if (
			state.hoveredId
			and (state.focusId == state.hoveredId or state.elementsById[state.hoveredId].type == InputText)
		) {
			currentCursor = I_BEAM

		} elseif (
			(state.activeId or state.hoveredId)
			and state.elementsById[math.max(state.activeId, state.hoveredId)].type == Slider
			and (cast(Slider) state.elementsById[math.max(state.activeId, state.hoveredId)]).limitName
			and ((state.activeId and state.activeMod == .A) or (not state.activeId and getModifierKey() == .A))
		) {
			currentCursor = SIZE_VERTICAL

		} else {
			currentCursor = ARROW
		}

		LM.setCursor(LM.getSystemCursor(currentCursor))
	}

	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		if input.field.mousemoved!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input))) {
			updateMouseCursor(state)
			return
		}
	}

	-- Update hovered ID.
	local lastHoveredId    = state.hoveredId
	local lastHoveredSubid = state.hoveredSubid

	local widget = cast(Widget) state.elementsById[state.activeId]
	if not (
		widget ~= NULL
		and (widget.type == Buttons or widget.type == Radio or widget.type == Tabs)
		and (cast(Buttons)widget).buttons[state.activeSubid].draggable
	) {
		local found, ^widget = state.getWidgetAt!(mx, my)

		state.hoveredId    = 0
		state.hoveredSubid = 0

		if found {
			if not state.activeId or widget.id == state.activeId {
				state.hoveredId = widget.id
			}

			local hoveredSubid = 0

			if state.hoveredId  if widget.type == {
				case Tabs:  !through
				case Radio: !through
				case Buttons:
					local buttons = cast(Buttons) widget
					if buttons.vertical
						hoveredSubid = math.clamp(math.floor(1 + (my-buttons.layoutY-getScrollOffset(buttons)) / buttons.buttonHeight), 1, #buttons.buttons)
					else
						hoveredSubid = math.clamp(math.floor(1 + (mx-buttons.layoutX                         ) / buttons.buttonWidth ), 1, #buttons.buttons)

				case Color:
					local colorEl = cast(Color) widget
					local iFloat  = 1 + (my - (colorEl.layoutY + getScrollOffset(colorEl))) / SLIDER_MIN_WIDTH
					hoveredSubid  = math.clamp(math.floor(iFloat), 1, (colorEl.alpha ? 4 : 3))
			}

			if not state.activeId or hoveredSubid == state.activeSubid {
				state.hoveredSubid = hoveredSubid
			} else {
				state.hoveredId = 0
			}
		}
	}

	if state.hoveredId and not (state.hoveredId == lastHoveredId and state.hoveredSubid == lastHoveredSubid) {
		widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget.type == {
			case Tabs:  !through
			case Radio: !through
			case Buttons:
				local buttons = cast(Buttons) widget
				local button  = buttons.buttons[state.hoveredSubid]
				triggerMouseEnterEvent(state, buttons, button.name, state.hoveredSubid)
		}
	}

	-- Drag active widget.
	widget = cast(Widget) state.elementsById[state.activeId]

	local mod = getModifierKey()

	if widget ~= NULL  if widget.type == {
		case Slider:
			local slider = cast(Slider) widget

			if state.activeMod == .A {
				-- Change limits.
				if dy {
					local limitMultiplier = math.clamp(getLimitMultiplier(slider) * 0.99 ^ dy, 1e-7, 1e+7)
					setLimitMultiplier(slider, limitMultiplier)
				}

			} else {
				local x1      = slider.layoutX +                      SLIDER_MIN_WIDTH // 2
				local x2      = slider.layoutX + slider.layoutWidth - SLIDER_MIN_WIDTH // 2
				local value01 = (mx-x1) / (x2-x1)
				value01       = applyExponential(slider, value01, 2)

				local min = applyLimitMultiplier(slider, slider.min)
				local max = applyLimitMultiplier(slider, slider.max)

				-- Snap value to something sensible.
				if mod == .C or mod == .CS {
					local getSnap :: (max:float, stepsCirca:int) -> float {
						-- Not sure if this makes any sense... Math is hard, yo!
						local snapBad = max / stepsCirca * .55 -- 11/16 -- !run math.sqrt(.5)
						local snap    = 1.0

						while snap > snapBad  snap /= 2
						while snap < snapBad  snap *= 2

						return snap
					}

					local range = max - min
					local snap  = getSnap(range, slider.steps)
					local value = min + value01 * range
					value       = math.round(value / snap) * snap
					value01     = (value - min) / range
				}

				-- Get final value.
				local value = math.lerp(min, max, math.clamp01(value01))

				if slider.isInt  value = math.round(value)

				-- Update stored value.
				if begin  triggerBeginEvent(state, slider, "", 0)
				if value ~= slider.value {
					slider.value = value
					triggerActionEvent(state, slider, "", 0)
				}
				if end  triggerEndEvent(state, slider, "", 0)

				-- Update linked sliders.
				if state.activeMod == .S or state.activeMod == .CS {
					for slider.linkMultiDrag {
						local other = cast(Slider) state.elementsByName[it]

						if other ~= NULL and other ~= slider and other.type == Slider and isElementVisible(other) {
							if begin  triggerBeginEvent(state, other, "", 0)
							if other.value ~= value {
								other.value = value
								triggerActionEvent(state, other, "", 0)
							}
							if end  triggerEndEvent(state, other, "", 0)
						}
					}
				}
			}

		case Color:
			local colorEl   = cast(Color) widget
			local component = state.activeSubid
			local value     = (mx-colorEl.layoutX) / colorEl.layoutWidth

			if mod == .C or mod == .CS {
				local steps = component == 1 ? 24 : 16
				value       = math.round(value*steps)/steps
			}

			value = math.clamp01(value)

			if begin  triggerBeginEvent(state, colorEl, "", component)
			if value ~= colorEl.color[component] {
				colorEl.color[component] = value
				triggerActionEvent(state, colorEl, "", component)
			}
			if end  triggerEndEvent(state, colorEl, "", component)

			if colorEl.linkMultiDrag and (state.activeMod == .S or state.activeMod == .CS) {
				for colorEl.linkMultiDrag {
					local other = cast(Color) state.elementsByName[it]

					if other ~= NULL and other ~= colorEl and other.type == Color and isElementVisible(other) {
						if begin  triggerBeginEvent(state, other, "", component)
						if other.color[component] ~= value {
							other.color[component] = value
							triggerActionEvent(state, other, "", component)
						}
						if end  triggerEndEvent(state, other, "", component)
					}
				}
			}

		case Direction:
			local r :: DIRECTION_RADIUS
			local direction = cast(Direction) widget
			local angle     = math.atan(my - (direction.layoutY + getScrollOffset(direction) + r), mx - (direction.layoutX + r))
			local multiDrag = direction.linkMultiDrag and (state.activeMod == .S or state.activeMod == .CS)

			if mod == .C or mod == .CS {
				local STEPS :: 16
				angle = math.round(angle * STEPS/math.TAU) / STEPS*math.TAU
			}

			if direction.linkOther and not multiDrag {
				local other = cast(Direction) state.elementsByName[direction.linkOther]

				if other ~= NULL and other ~= direction and other.type == Direction {
					-- Allow the angle to go beyond -180°..+180° and use the other widget as limiter instead.
					-- This makes it easy to cover the whole 360° between the two values.
					angle = direction.angle + math.deltaAngle(direction.angle, angle)
					angle = math.clamp(angle, other.angle-math.TAU, other.angle+math.TAU)
				}
			}

			if begin  triggerBeginEvent(state, direction, "", 0)
			if angle ~= direction.angle {
				direction.angle = angle
				triggerActionEvent(state, direction, "", 0)
			}
			if end  triggerEndEvent(state, direction, "", 0)

			if multiDrag {
				for direction.linkMultiDrag {
					local other = cast(Direction) state.elementsByName[it]

					if other ~= NULL and other ~= direction and other.type == Direction and isElementVisible(other) {
						if begin  triggerBeginEvent(state, other, "", 0)
						if other.angle ~= angle {
							other.angle = angle
							triggerActionEvent(state, other, "", 0)
						}
						if end  triggerEndEvent(state, other, "", 0)
					}
				}
			}

		case Scrollable:
			local scrollable = cast(Scrollable) widget
			local handlePos, handleLen, handlePosMax = getScrollbarHandle(scrollable, visual=false)

			local visibleH = scrollable.layoutHeight
			local paddedH  = visibleH - 2*SPACING

			scrollable.scrollTarget = -math.round( ((my + state.scrollbarHandleDragOffset) - scrollable.layoutY) / handlePosMax * (scrollable.contentHeight-paddedH) )
			limitScroll(scrollable)
			scrollable.scroll = scrollable.scrollTarget

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) widget
			local button  = buttons.buttons[state.activeSubid]

			if button.draggable {
				if state.activeDragging {
					triggerDragEvent(state, buttons, button.name, state.activeSubid, mx, my)

				} elseif math.distance(mx,my, state.activeStartMx,state.activeStartMy) > DRAG_RADIUS {
					state.activeDragging = true
					triggerDragBeginEvent(state, buttons, button.name, state.activeSubid)
				}
			}
	}

	-- Update tooltip.
	state.currentTooltip = ""

	if state.hoveredId and not state.activeId {
		widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget.type == Buttons or widget.type == Radio or widget.type == Tabs {
			local buttons        = cast(Buttons) widget
			state.currentTooltip = buttons.buttons[state.hoveredSubid].tooltip

			if buttons.vertical {
				state.tooltipX  = buttons.layoutX
				state.tooltipY1 = math.round(buttons.layoutY + (state.hoveredSubid-1) * buttons.buttonHeight)
				state.tooltipY2 = math.round(buttons.layoutY + (state.hoveredSubid  ) * buttons.buttonHeight)
			} else {
				state.tooltipX  = math.round(buttons.layoutX + (state.hoveredSubid-1) * buttons.buttonWidth)
				state.tooltipY1 = buttons.layoutY
				state.tooltipY2 = buttons.layoutY + buttons.layoutHeight
			}
		}

		if not state.currentTooltip {
			state.currentTooltip = widget.tooltip
			state.tooltipX       = widget.layoutX
			state.tooltipY1      = widget.layoutY
			state.tooltipY2      = widget.layoutY + widget.layoutHeight
		}

		if state.currentTooltip {
			local offset     = getScrollOffset(widget)
			state.tooltipY1 += offset
			state.tooltipY2 += offset
		}
	}

	if not state.currentTooltip {
		state.tooltipTime = 0
	} else {
		if state.tooltipTime == 0  state.tooltipTime = LT.getTime()
	}

	updateMouseCursor(state)
}

export onMouseReleased :: (state:State, mx,my:int, mbutton:int, presses:int) {
	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		if input.field.mousereleased!(mx, my, mbutton)  state.onMouseMoved!(mx, my, 0, 0)
	}

	-- LMB.
	if mbutton == 1 and state.activeId {
		local widget = cast(Widget) state.elementsById[state.activeId]

		if widget ~= NULL  if widget.type == {
			case Buttons:
				if state.hoveredId and not state.activeDragging {
					local buttons = cast(Buttons) widget
					triggerBeginEvent (state, buttons, buttons.buttons[state.activeSubid].name, state.activeSubid)
					triggerActionEvent(state, buttons, buttons.buttons[state.activeSubid].name, state.activeSubid, alsoEnd=true)
				}

			case Radio:
				if state.hoveredId and not state.activeDragging {
					local radio = cast(Radio) widget

					if triggerBeforeActionEvent(state, radio, radio.buttons[state.activeSubid].name, state.activeSubid) {
						-- void
					} elseif radio.index ~= state.hoveredSubid {
						triggerBeginEvent (state, radio, radio.buttons[state.activeSubid].name, state.activeSubid)
						radio.index = state.hoveredSubid
						triggerActionEvent(state, radio, radio.buttons[state.activeSubid].name, state.activeSubid, alsoEnd=true)
					}
				}

			case Tabs:
				if state.hoveredId and not state.activeDragging {
					local tabs = cast(Tabs) widget

					if triggerBeforeActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid) {
						-- void
					} elseif tabs.specialLastTab and state.hoveredSubid == #tabs.buttons {
						triggerBeginEvent (state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid)
						triggerActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, alsoEnd=true)
					} elseif tabs.index ~= state.hoveredSubid {
						triggerBeginEvent (state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid)
						tabs.index = state.hoveredSubid
						triggerActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, alsoEnd=true)
					}
				}

			case Checkbox:
				if state.hoveredId {
					local checkbox = cast(Checkbox) widget

					triggerBeginEvent(state, checkbox, "", 0)
					checkbox.checked = not checkbox.checked
					triggerActionEvent(state, checkbox, "", 0, alsoEnd=true)
				}

			case Slider: !through
			case Color:  !through
			case Direction:
				scheduleSaveWorkspace()

			case Section:
				if state.hoveredId {
					local section = cast(Section) widget

					if app.hiddenSections[section.name]
						app.hiddenSections[section.name] = NULL
					else
						app.hiddenSections[section.name] = true

					scheduleSaveWorkspace()
					state.layoutNeedsUpdate = true
				}
		}
	}

	-- MMB.
	if mbutton == 3 and not state.activeId and state.hoveredId {
		local widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget ~= NULL  if widget.type == {
			case Tabs:
				local tabs = cast(Tabs) widget

				if not (tabs.specialLastTab and state.hoveredSubid == #tabs.buttons) {
					triggerCloseEvent(state, tabs, tabs.buttons[state.hoveredSubid].name, state.hoveredSubid)
				}
		}
	}

	-- RMB.
	if mbutton == 2 and not state.activeId and state.hoveredId {
		local widget = cast(Widget) state.elementsById[state.hoveredId]
		local name   = ""

		if widget.type == {
			case Tabs:  !through
			case Radio: !through
			case Buttons: name = (cast(Buttons)widget).buttons[state.hoveredSubid].name
		}

		if widget ~= NULL and not triggerOptionEvent(state, widget, name, state.hoveredSubid) {
			if widget.type == {
				case Direction:
					local direction = cast(Direction) widget

					state.showContextMenuWithInput!(toString(direction.angle*360/math.TAU), {"Copy angle","Paste angle"},
						[state,direction] (i:int) {
							if i == {
								case 1:
									clipboardAngle    = direction.angle
									hasClipboardAngle = true

								case 2:
									if not hasClipboardAngle  return

									triggerBeginEvent(state, direction, "", 0)
									direction.angle = clipboardAngle
									triggerActionEvent(state, direction, "", 0, alsoEnd=true)
							}
						},
						[state,direction] (text:string) {
							commitValueFromInput(state, direction, text)
						}
					)

				case Slider:
					local slider = cast(Slider) widget

					state.showContextMenuWithInput!(toString(slider.value*slider.readoutMulti), {"Copy value","Paste value"--[[,"Reset value"@Incomplete]],"Reset min/max limits"},
						[state,slider] (i:int) {
							if i == {
								case 1:
									clipboardScalar    = slider.value
									hasClipboardScalar = true

								case 2:
									if not hasClipboardScalar  return

									triggerBeginEvent(state, slider, "", 0)
									slider.value = clipboardScalar
									triggerActionEvent(state, slider, "", 0, alsoEnd=true)

								case 3:
									forgetLimitMultiplier(slider)
							}
						},
						[state,slider] (text:string) {
							commitValueFromInput(state, slider, text)
						}
					)

				case Color:
					local COMPONENT_TITLES: Table(int, string) : {
						[1] = "hue",
						[2] = "saturation",
						[3] = "value strength",
						[4] = "opacity",
					}

					local colorEl   = cast(Color) widget
					local component = state.hoveredSubid
					local valueStr  = toString(colorEl.color[component] * (component == 1 ? 360 : 100))

					local items = {
						"Copy "..COMPONENT_TITLES[component],
						"Copy color",
						"Paste "..COMPONENT_TITLES[component],
						"Paste color",
					}

					state.showContextMenuWithInput!(valueStr, items,
						[state,colorEl,component] (i:int) {
							if i == {
								case 1:
									clipboardScalar    = colorEl.color[component]
									hasClipboardScalar = true

								case 2:
									for 1, 4  clipboardColor[it] = colorEl.color[it]
									hasClipboardColor = true

								case 3:
									if not hasClipboardScalar  return

									triggerBeginEvent(state, colorEl, "", component)
									colorEl.color[component] = clipboardScalar
									triggerActionEvent(state, colorEl, "", component, alsoEnd=true)

								case 4:
									if not hasClipboardColor  return

									for 1, 4 {
										triggerBeginEvent(state, colorEl, "", it)
										colorEl.color[it] = clipboardColor[it]
										triggerActionEvent(state, colorEl, "", it, alsoEnd=true)
									}
							}
						},
						[state,colorEl,component] (text:string) {
							commitValueFromInput(state, colorEl, component, text)
						}
					)
			}
		}
	}

	-- Release active ID.
	if state.activeId and mbutton == 1 {
		if state.elementsById[state.activeId] ~= NULL  state.onMouseMoved!(mx, my, 0, 0, end=true)

		if state.activeDragging {
			local widget = cast(Widget) state.elementsById[state.activeId]

			if widget.type == {
				case Tabs:  !through
				case Radio: !through
				case Buttons:
					local buttons = cast(Buttons) widget
					local button  = buttons.buttons[state.activeSubid]
					triggerDragEndEvent(state, buttons, button.name, state.activeSubid)

				case:
					log("Error: triggerDragEndEvent: Unhandled element type '%d'.", widget.type)
					triggerDragEndEvent(state, widget, "", state.activeSubid)
			}

			scheduleSaveWorkspace()
		}

		state.activeId       = 0
		state.activeSubid    = 0
		state.activeDragging = false

		LM.setGrabbed(false)
		LK.setKeyRepeat(true)

		state.onMouseMoved!(mx, my, 0, 0)
	}
}

export onMouseWheel :: (state:State, dx,dy:int) -> (handled:bool) {
	if state.activeId  return true
	if getModifierKey() ~= .NONE  return false

	updateLayoutIfNeeded(state)

	local mx, my = LM.getPosition()

	local found, el = state.getElementAt!(mx, my)
	while not (el == NULL or el.type == Scrollable) {
		el = el.parent
	}

	if el ~= NULL {
		local scrollable        = cast(Scrollable) el
		local maxDy             = math.max(scrollable.layoutHeight - 2 * (SCROLLABLE_PADDING + SPACING), 10)
		scrollable.scrollSource = scrollable.scroll
		scrollable.scrollTarget = scrollable.scrollTarget + math.clamp(50*dy, -maxDy, maxDy)
		limitScroll(scrollable)
		return true
	}

	return false
}

export onFocus :: (state:State, hasFocus:bool) {
	if not hasFocus  state.hideContextMenu!()
}



local calculateNaturalSize :: (state:State, el:Element) {
	for el  if it.active {
		calculateNaturalSize(state, it)
	}

	if el.type == {
		case Frame:
			local frame    = cast(Frame) el
			local contentW = 0
			local contentH = 0

			for frame  if it.active {
				contentW  = math.max(contentW, it.layoutWidth)
				contentH += it.layoutHeight + SPACING
			}

			frame.layoutWidth  = contentW + 2*SPACING
			frame.layoutHeight = contentH + SPACING

		case Scrollable:
			local scrollable = cast(Scrollable) el
			local contentH   = 0

			for scrollable  if it.active {
				contentH += it.layoutHeight + SPACING
			}

			scrollable.layoutWidth   = SCROLLBAR_WIDTH
			scrollable.contentHeight = contentH - SPACING + 2*SCROLLABLE_PADDING

			if scrollable.height > 0 {
				scrollable.layoutHeight = scrollable.height
			} else {
				scrollable.layoutHeight     = math.max(state.extraScrollableSpace + scrollable.height, 0)
				state.extraScrollableSpace -= scrollable.layoutHeight
			}

		case Section:
			local section = cast(Section) el

			if app.hiddenSections[section.name] {
				section.layoutWidth  = section.labelWidth + (section.icon16 ? 16 : 0)
				section.layoutHeight = math.max(fontNormal.getHeight!(), (section.icon16 ? 16 : 0))

			} else {
				local contentW = 0
				local contentH = 0

				if not app.hiddenSections[section.name] {
					for section  if it.active {
						contentW  = math.max(contentW, it.layoutWidth)
						contentH += it.layoutHeight + SPACING
					}
				}

				local sectionSideHeight = (section.label ? fontNormal.getHeight!() : 0) + (section.icon16 ? 16+SPACING : 0)

				section.layoutWidth  = section.labelWidth + contentW
				section.layoutHeight = math.max(contentH-SPACING, sectionSideHeight)
			}

		case Hbox:
			local hbox     = cast(Hbox) el
			local contentW = 0
			local contentH = 0

			for hbox  if it.active {
				contentW += it.layoutWidth + SPACING
				contentH  = math.max(contentH, it.layoutHeight)
			}

			hbox.layoutWidth  = contentW - SPACING
			hbox.layoutHeight = contentH

		case Vbox:
			local vbox     = cast(Vbox) el
			local contentW = 0
			local contentH = 0

			for vbox  if it.active {
				contentW  = math.max(contentW, it.layoutWidth)
				contentH += it.layoutHeight + SPACING
			}

			vbox.layoutWidth  = contentW
			vbox.layoutHeight = contentH - SPACING

		case Text:
			local textEl        = cast(Text) el
			local font          = textEl.size == 3 ? fontLarge : textEl.size == 1 ? fontSmall : fontNormal
			local fontH         = font.getHeight!()
			local lineCount     = textEl.textLines ? #textEl.textLines : 1 + countString(textEl.text, "\n")
			textEl.textHeight   = math.ceil(fontH + (lineCount-1) * fontH * font.getLineHeight!())
			textEl.layoutHeight = textEl.textHeight

			if textEl.textLines {
				local w = 0
				for textEl.textLines  w = math.max(w, font.getWidth!(it))
				textEl.layoutWidth = w + (textEl.size == 3 ? 1 : 0)
			} else {
				textEl.layoutWidth = font.getWidth!(textEl.text) + (textEl.size == 3 ? 1 : 0)
			}

		case Separator:
			local separator        = cast(Separator) el
			separator.layoutWidth  = 0
			separator.layoutHeight = separator.thick ? 5 : 1

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons    = cast(Buttons) el
			local buttonMaxW = 0
			local buttonMaxH = buttons.buttonMinHeight

			for buttons.buttons {
				local w: int = NULL
				local h: int = NULL

				it.labelWidth    = fontNormal.getWidth!(it.label)
				it.suffixWidth   = fontNormal.getWidth!(it.suffix)
				it.shortcutWidth = it.shortcut ? fontNormal.getWidth!(it.shortcut) + SPACING_LARGE : 0

				if it.system ~= NULL {
					w             = PARTICLE_PREVIEW_SIZE
					h             = PARTICLE_PREVIEW_SIZE
				} elseif (it.label or it.suffix or it.shortcut) and it.image {
					w, h          = guiImages[it.image].getDimensions!()
					it.imageScale = math.min(BUTTON_IMAGE_MAX_SIZE/w, BUTTON_IMAGE_MAX_SIZE/h, 1)
					w             = math.round(w*it.imageScale) + SPACING + it.labelWidth+it.suffixWidth+it.shortcutWidth
					h             = math.max(math.round(h*it.imageScale), fontNormal.getHeight!())
				} elseif it.image {
					w, h          = guiImages[it.image].getDimensions!()
					it.imageScale = math.min(BUTTON_IMAGE_MAX_SIZE/w, BUTTON_IMAGE_MAX_SIZE/h, 1)
					w             = math.round(w*it.imageScale)
					h             = math.round(h*it.imageScale)
				} else {
					w             = it.labelWidth + it.suffixWidth + it.shortcutWidth
					h             = fontNormal.getHeight!()
				}

				it.contentWidth = w

				buttonMaxW = math.max(buttonMaxW, w)
				buttonMaxH = math.max(buttonMaxH, h)
			}

			if buttons.vertical {
				buttons.layoutWidth  = buttonMaxW + 2*SPACING
				buttons.layoutHeight = #buttons.buttons * (buttonMaxH + 2*BUTTON_PADDING_Y)
			} else {
				buttons.layoutWidth  = #buttons.buttons * (buttonMaxW + 2*SPACING)
				buttons.layoutHeight = buttonMaxH + 2*BUTTON_PADDING_Y
			}

		case Checkbox:
			local checkbox        = cast(Checkbox) el
			checkbox.layoutWidth  = CHECKBOX_SIZE + SPACING + fontSmall.getWidth!(checkbox.label) + SPACING_LARGE
			checkbox.layoutHeight = math.max(CHECKBOX_SIZE, fontSmall.getHeight!())

		case InputText:
			local input = cast(InputText) el
			input.layoutWidth  = INPUT_MIN_WIDTH
			input.layoutHeight = fontNormal.getHeight!() + 2*SPACING

		case Slider:
			local slider        = cast(Slider) el
			slider.layoutWidth  = SLIDER_MIN_LENGTH
			slider.layoutHeight = SLIDER_MIN_WIDTH

		case Color:
			local colorEl        = cast(Color) el
			colorEl.layoutWidth  = SLIDER_MIN_LENGTH
			colorEl.layoutHeight = (colorEl.alpha ? 4 : 3) * SLIDER_MIN_WIDTH

		case ColorPreview:
			local preview        = cast(ColorPreview) el
			preview.layoutWidth  = COLOR_PREVIEW_WIDTH
			preview.layoutHeight = 0

		case Direction:
			local direction        = cast(Direction) el
			direction.layoutWidth  = 2*DIRECTION_RADIUS
			direction.layoutHeight = 2*DIRECTION_RADIUS

		case Canvas:
			local canvasEl        = cast(Canvas) el
			canvasEl.layoutWidth  = 10
			canvasEl.layoutHeight = 10

		case: errorf("%d", el.type)
	}

	if el.width                             el.layoutWidth  = el.width
	if el.height and el.type ~= Scrollable  el.layoutHeight = el.height

	el.layoutWidth  = math.max(el.layoutWidth,  el.minWidth)
	el.layoutHeight = math.max(el.layoutHeight, el.minHeight)
	if el.maxWidth  >= 0  el.layoutWidth  = math.min(el.layoutWidth,  el.maxWidth)
	if el.maxHeight >= 0  el.layoutHeight = math.min(el.layoutHeight, el.maxHeight)

	-- The following count as outside the element, even though they take space as if they were part of the element.
	-- el.layoutWidth += el.inset
	if el.type == Tabs  el.layoutHeight += TAB_BOTTOM_LINE_WIDTH
}

local positionAndFit :: (state:State, el:Element, x,y,w,h:int) {
	local positionAndFitChildrenV :: (state:State, el:Element, x,y,w,h:int) {
		for el  if it.active {
			positionAndFit(state, it, x+it.inset, y, w-it.inset, it.layoutHeight)
			y += it.layoutHeight + SPACING
		}
	}
	local positionAndFitChildrenH :: (state:State, el:Element, x,y,w,h:int) {
		for el  if it.active {
			x += it.inset
			positionAndFit(state, it, x, y, it.layoutWidth, h)
			x += it.layoutWidth + SPACING
		}
	}

	-- x += el.inset
	-- w -= el.inset
	if el.type == Tabs  h -= TAB_BOTTOM_LINE_WIDTH

	el.layoutX      = x
	el.layoutY      = y
	el.layoutWidth  = w
	el.layoutHeight = h

	if el.type == {
		case Frame:
			local frame = cast(Frame) el

			if !complete frame.layout == {
				case .DOCKED:
					x = 0
					y = 0
				case .FLOATING:
					x = frame.x >= 0 ? frame.x : (LG.getWidth()  - w) // 2
					y = frame.y >= 0 ? frame.y : (LG.getHeight() - h) // 2
			}

			frame.layoutX = x
			frame.layoutY = y

			x += SPACING
			y += SPACING
			w -= 2*SPACING

			positionAndFitChildrenV(state, frame, x, y, w, h)

		case Scrollable:
			local scrollable = cast(Scrollable) el

			y += SPACING + SCROLLABLE_PADDING
			w -= SCROLLBAR_WIDTH + SPACING

			positionAndFitChildrenV(state, scrollable, x, y, w, h)

		case Section:
			local section = cast(Section) el

			x += section.labelWidth
			w -= section.labelWidth

			if not app.hiddenSections[section.name]  positionAndFitChildrenV(state, section, x, y, w, h)

		case Hbox:
			local hbox         = cast(Hbox) el
			local dynamicSpace = w
			local weight       = .0
			local activeCount  = 0

			for hbox  if it.active {
				activeCount  += 1
				dynamicSpace -= it.inset

				if it.weight {
					weight += it.weight
				} else {
					dynamicSpace -= it.layoutWidth
				}
			}

			if weight {
				dynamicSpace -= (activeCount-1) * SPACING

				for hbox  if it.active and it.weight {
					it.layoutWidth  = math.max(math.round(dynamicSpace * it.weight / weight), 1)
					dynamicSpace   -= it.layoutWidth
					weight         -= it.weight
				}
			}

			positionAndFitChildrenH(state, hbox, x, y, w, h)

		case Vbox:
			local vbox         = cast(Vbox) el
			local dynamicSpace = h
			local weight       = .0
			local activeCount  = 0

			for vbox  if it.active {
				activeCount += 1
				if it.weight
					weight += it.weight
				else
					dynamicSpace -= it.layoutHeight
			}

			if weight {
				dynamicSpace -= (activeCount-1) * SPACING

				for vbox  if it.active and it.weight {
					it.layoutHeight  = math.round(dynamicSpace * it.weight / weight)
					dynamicSpace    -= it.layoutHeight
					weight          -= it.weight
				}
			}

			positionAndFitChildrenV(state, vbox, x, y, w, h)

		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) el
			if buttons.vertical {
				buttons.buttonWidth  = w
				buttons.buttonHeight = h / #buttons.buttons
			} else {
				buttons.buttonWidth  = w / #buttons.buttons
				buttons.buttonHeight = h
			}

		case Tabs:
			local tabs = cast(Tabs) el
			tabs.buttonWidth
				= tabs.specialLastTab
				? (w-SPECIAL_TAB_WIDTH) / (#tabs.buttons-1)
				: (w                  ) / (#tabs.buttons  )

		case Color:
			local colorEl       = cast(Color) el
			colorEl.sliderWidth = h / (colorEl.alpha ? 4 : 3)

		case InputText:
			local input = cast(InputText) el
			if input.field ~= NULL  input.field.setWidth!(w - 2*SPACING)
	}
}

local updateLayoutIfNeeded :: (state:State) {
	if not state.layoutNeedsUpdate  return
	state.layoutNeedsUpdate = false

	-- log("Updating layout.")

	local updateParents :: (el:Element, frame:Frame, parent:Element) {
		el.frame  = frame
		el.parent = parent
		for el  updateParents(it, frame, el)
	}
	for state.frames  updateParents(it, it, NULL)

	for state.frames  if it.active {
		state.extraScrollableSpace = 0
		calculateNaturalSize(state, it)

		do {
			-- We need to do calculateNaturalSize() twice to know how much scrollables can expand the frame.
			-- Note: If there are multiple scrollables with height<=0 then things may or may not work as expected!
			state.extraScrollableSpace = LG.getHeight() - it.layoutHeight -- layoutNeedsUpdate better be set if the window resizes!
			if it.layout == .FLOATING  state.extraScrollableSpace -= 2*SPACING_LARGE

			calculateNaturalSize(state, it)
		}

		positionAndFit(state, it, 0, 0, it.layoutWidth, it.layoutHeight)
	}

	for state.scrollables  limitScroll(it)

	local mx, my = LM.getPosition()
	if state.isOverGui!(mx, my)  state.onMouseMoved!(mx, my, 0, 0)
}



export update :: (state:State, dt:float) {
	local anyScrolling = false

	for state.scrollables {
		local targetReached: bool = NULL

		it.scroll, targetReached = math.moveTowards(
			it.scroll,
			it.scrollTarget,
			math.abs(it.scrollTarget - it.scrollSource) * dt / 0.05
		)
		if not targetReached  anyScrolling = true
	}

	if anyScrolling {
		local mx, my = LM.getPosition()
		state.onMouseMoved!(mx, my, 0, 0)
	}

	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		input.field.update!(dt)
	}

}



local drawElement :: (state:State, el:Element) {
	local drawChildren :: (state:State, el:Element) {
		for el {
			if it.active  drawElement(state, it)
		}
	}

	if el.labelLeft {
		local textY: int = NULL

		if el.labelLeftAlign == {
			case .TOP:    textY = el.layoutY
			case .BOTTOM: textY = el.layoutY + el.layoutHeight - fontSmall.getHeight!()
			case:         textY = el.layoutY + (el.layoutHeight - fontSmall.getHeight!()) // 2
		}

		LG.setFont(fontSmall)
		LG.setColor(1, 1, 1, TEXT_OPACITY)
		LG.print(el.labelLeft, el.layoutX-SPACING-fontSmall.getWidth!(el.labelLeft), textY)
		LG.setFont(fontNormal)
	}

	if el.type == {
		case Frame:
			local frame = cast(Frame) el

			local x = frame.layoutX
			local y = frame.layoutY
			local w = frame.layoutWidth
			local h = frame.layoutHeight

			if frame.layout == .FLOATING and frame.modal {
				local BORDER :: 10
				LG.setColor(.1, .1, .1, .9)
				LG.rectangle(LG.DrawMode.FILL, x-BORDER, y-BORDER, w+2*BORDER, h+2*BORDER, SPACING+BUTTON_RADIUS+BORDER)
			}

			if frame.style == .CONTEXT_MENU {
				LG.setColor(0, 0, 0, .6)
				drawBoxGradient(x, y, w, h)
			}

			if frame.style == .CONTEXT_MENU
				LG.setColor(.7, .7, .7)
			else
				LG.setColor(.2, .2, .2)

			if frame.style == .CONTEXT_MENU
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
			elseif frame.layout == .FLOATING
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h, SPACING+BUTTON_RADIUS)
			else
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h)

			if frame.style == .CONTEXT_MENU {
				LG.setColor(.1, .1, .1)
				LG.rectangle(LG.DrawMode.LINE, x+.5, y+.5, w-1, h-1)
			}

			LG.pushAll()
			intersectScissor(x, y, w, h)
			drawChildren(state, frame)
			LG.pop()

		case Scrollable:
			local scrollable = cast(Scrollable) el

			local x = scrollable.layoutX
			local y = scrollable.layoutY
			local w = scrollable.layoutWidth
			local h = scrollable.layoutHeight

			LG.pushAll()
			LG.translate(0, scrollable.scroll)
			intersectScissor(x-SPACING, y, w+SPACING, h)
			drawChildren(state, scrollable)
			LG.pop()

			-- Shadow.
			do {
				local shadowH = math.min((scrollable.scroll ? 30 : 10), math.round(.4*scrollable.layoutHeight))
				local iw, ih  = imageGradient.getDimensions!()
				local sx      = shadowH / ih
				local sy      = (w + SPACING - SCROLLBAR_WIDTH) / iw

				LG.setColor(0, 0, 0, (scrollable.scroll ? 1 : .3))
				LG.draw(imageGradient, x-SPACING, y+shadowH, -math.TAU/4, sx, sy)
			}

			-- Scrollbar.
			do {
				local handlePos, handleLen, handlePosMax = getScrollbarHandle(scrollable, visual=true)

				local barX = x + w - SCROLLBAR_WIDTH
				local barY = y + handlePos

				LG.setColor(0, 0, 0, .3)
				LG.rectangle(LG.DrawMode.FILL, barX, y, SCROLLBAR_WIDTH, h)

				if scrollable.id == state.activeId
					LG.setColor(1, 1, 1, .30)
				elseif scrollable.id == state.hoveredId
					LG.setColor(1, 1, 1, .45)
				else
					LG.setColor(1, 1, 1, .15)

				LG.rectangle(LG.DrawMode.FILL, barX+1, barY+1, SCROLLBAR_WIDTH-2, handleLen-2, SCROLLBAR_WIDTH//2-1)
			}

		case Section:
			local section = cast(Section) el
			local hidden  = app.hiddenSections[section.name]
			local font    = fontNormal--hidden ? fontSmall : fontNormal

			if section.id == state.hoveredId {
				local x = section.layoutX - SPACING
				local y = section.layoutY - BUTTON_PADDING_Y
				local w = font.getWidth!(section.label) + 2*SPACING
				local h = font.getHeight!() + 2*BUTTON_PADDING_Y
				LG.setColor(1, 1, 1, .45)
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h, BUTTON_RADIUS)
			}

			if section.icon16 {
				local x, y: int
				if hidden {
					x = section.layoutX + section.labelWidth
					y = section.layoutY
				} else {
					x = section.layoutX
					y = section.layoutY + section.layoutHeight - 16
				}
				LG.setColor(1, 1, 1, .15)
				LG.draw(imageIcons16, icon16Quads[section.icon16], x, y)
			}

			if section.label {
				LG.setFont(font)
				LG.setColor(1, 1, 1, TEXT_OPACITY)
				LG.print(section.label, section.layoutX, section.layoutY)
				LG.setFont(fontNormal)
			}

			if not hidden  drawChildren(state, section)

		case Hbox:
			local hbox = cast(Hbox) el
			drawChildren(state, hbox)

		case Vbox:
			local vbox = cast(Vbox) el
			drawChildren(state, vbox)

		case Text:
			local textEl = cast(Text) el
			local font   = textEl.size == 3 ? fontLarge : textEl.size == 1 ? fontSmall : fontNormal
			local textY  = textEl.layoutY + (textEl.layoutHeight - textEl.textHeight) // 2

			LG.pushAll()
			intersectScissor(textEl.layoutX, 0, textEl.layoutWidth, LG.getHeight())

			LG.setFont(font)
			LG.setColor(1, 1, 1, TEXT_OPACITY)

			if textEl.textLines {
				local lineDist = math.round(font.getHeight!() * font.getLineHeight!())
				for textEl.textLines {
					LG.print(it, textEl.layoutX, textY)
					textY += lineDist
				}
			} else {
				LG.print(textEl.text, textEl.layoutX, textY)
				if textEl.size == 3  LG.print(textEl.text, textEl.layoutX+1, textY)
			}

			LG.pop()

		case Separator:
			local separator = cast(Separator) el
			LG.setColor(0, 0, 0, (separator.thick ? .3 : .2))
			LG.rectangle(LG.DrawMode.FILL, separator.layoutX-SPACING, separator.layoutY, separator.layoutWidth+2*SPACING, separator.layoutHeight)

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) el
			local radio   = cast(Radio)   el
			local tabs    = cast(Tabs)    el

			local isRadio = el.type == Radio
			local isTabs  = el.type == Tabs

			local x = buttons.layoutX
			local y = buttons.layoutY
			local w = buttons.layoutWidth
			local h = buttons.layoutHeight

			local paddingX = isTabs ? 9 : SPACING

			local bx1:   []int : {}
			local bx2:   []int : {}
			local by1:   []int : {}
			local by2:   []int : {}
			local bw:    []int : {}
			local bh:    []int : {}
			local faded: []bool : {}

			-- Backgrounds.
			for buttons.buttons {
				if buttons.vertical {
					bx1[itIndex] = x
					bx2[itIndex] = x + w
					by1[itIndex] = math.round(y + buttons.buttonHeight*(itIndex-1))
					by2[itIndex] = math.round(y + buttons.buttonHeight*(itIndex  ))
					by2[itIndex] = math.min(by2[itIndex], y + h)
				} else {
					bx1[itIndex] = math.round(x + buttons.buttonWidth*(itIndex-1))
					bx2[itIndex] = math.round(x + buttons.buttonWidth*(itIndex  ))
					bx2[itIndex] = math.min(bx2[itIndex], x + w)
					by1[itIndex] = y
					by2[itIndex] = y + h
				}
				bw[itIndex]    = bx2[itIndex] - bx1[itIndex]
				bh[itIndex]    = by2[itIndex] - by1[itIndex]
				faded[itIndex] = false

				local showBg = true

				if not (buttons.id == state.hoveredId and itIndex == state.hoveredSubid) {
					faded[itIndex] = (isRadio or isTabs) and radio.index ~= itIndex
					if buttons.style ~= .NORMAL
						showBg = false
					elseif faded[itIndex]
						LG.setColor(1, 1, 1, .1)
					else
						LG.setColor(1, 1, 1, .3)
				} elseif not (buttons.id == state.activeId and itIndex == state.activeSubid) {
					LG.setColor(1, 1, 1, .45)
				} else {
					LG.setColor(0, 0, 0, .5)
				}

				if not showBg {
					-- void
				} elseif isTabs {
					local topInset = math.min(.3*bh[itIndex], bw[itIndex]/4)
					LG.polygon(LG.DrawMode.FILL,
						bx1[itIndex],          by2[itIndex],
						bx1[itIndex]+topInset, by1[itIndex],
						bx2[itIndex]-topInset, by1[itIndex],
						bx2[itIndex],          by2[itIndex]
					)
				} else {
					LG.rectangle(LG.DrawMode.FILL, bx1[itIndex]+1, by1[itIndex]+1, bw[itIndex]-2, bh[itIndex]-2, BUTTON_RADIUS)
				}
			}

			-- Tab bottom line.
			if isTabs {
				LG.setColor(1, 1, 1, .3)
				LG.rectangle(LG.DrawMode.FILL, tabs.frame.layoutX, y+h, tabs.frame.layoutWidth, TAB_BOTTOM_LINE_WIDTH) -- Assume we haven't translated on the x axis.
				-- LG.rectangle(LG.DrawMode.FILL, x-SPACING, y+h, w+2*SPACING, TAB_BOTTOM_LINE_WIDTH)
			}

			-- Images.
			LG.setColor(1, 1, 1)

			for buttons.buttons  if it.image {
				local image  = guiImages[it.image]
				local iw, ih = image.getDimensions!()

				local imageX: int = NULL

				if buttons.align == {
					case .LEFT:  imageX = bx1[itIndex] + paddingX
					case .RIGHT: imageX = bx1[itIndex] + math.max(math.round(bw[itIndex] - paddingX - it.contentWidth), paddingX)
					case:        imageX = bx1[itIndex] + math.max((bw[itIndex] - it.contentWidth) // 2,                 paddingX)
				}

				LG.draw(image,
					imageX,
					by1[itIndex] + bh[itIndex] // 2,
					0, it.imageScale, it.imageScale, 0, ih/2
				)
			}

			-- Particle previews.
			--
			-- @Cleanup: All this is a bit misplaced in the GUI. Maybe provide an onDraw
			-- event for elements so systems and projects can stay outside this file.
			-- (Update: We now have gui.Canvas! Except this is on a Button...)
			--
			local PREVIEW_SCALE :: 2.5
			local project = app.projects[app.currentProjectIndex]
			local scale   = PREVIEW_SCALE * PARTICLE_PREVIEW_SIZE / math.min(LG.getWidth() - MAIN_PANEL_WIDTH, LG.getHeight()) * project.zoom
			local r, g, b = hsvToRgb(project.bgColor)

			for buttons.buttons  if it.system ~= NULL {
				local system = it.system

				if system.visible {
					local emitterX, emitterY: float

					if project.movementPreset == .NONE {
						emitterX, emitterY = system.particles.getPosition!()
					}

					LG.pushAll()
					intersectScissor(
						bx1[itIndex] + (bw[itIndex] - PARTICLE_PREVIEW_SIZE) // 2,
						by1[itIndex] + (bh[itIndex] - PARTICLE_PREVIEW_SIZE) // 2 + getScrollOffset(buttons),
						PARTICLE_PREVIEW_SIZE,
						PARTICLE_PREVIEW_SIZE
					)

					LG.clear(r, g, b)
					if system.currentShader ~= NULL  LG.setShader(system.currentShader.shader)
					LG.setBlendMode(system.blendMode)
					LG.setColor(1, 1, 1)

					LG.draw(system.particles,
						bx1[itIndex] + bw[itIndex]/2 - emitterX*scale,
						by1[itIndex] + bh[itIndex]/2 - emitterY*scale,
						0, scale
					)

					LG.pop()
				}

				if system.title {
					local scissorX1 = bx1[itIndex] + (paddingX-1)
					local scissorX2 = bx2[itIndex] - (paddingX-1)

					if scissorX2 > scissorX1 {
						local textY = by1[itIndex] + (bh[itIndex] - fontNormal.getHeight!()) // 2
						local textX = bx1[itIndex] + math.max((bw[itIndex] - fontNormal.getWidth!(system.title)) // 2, paddingX)

						LG.pushAll()
						intersectScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
						LG.setColor(0, 0, 0, .7)
						LG.print(system.title, textX+1, textY+1)
						LG.setColor(1, 1, 1)
						LG.print(system.title, textX, textY)
						LG.pop()
					}
				}
			}

			-- Submenu icons.
			LG.setColor(0, 0, 0)

			for buttons.buttons  if it.submenuIcon {
				local iw, ih = guiImages.iconSubmenu.getDimensions!()
				LG.draw(guiImages.iconSubmenu, bx2[itIndex]-iw-1, by1[itIndex]+(bh[itIndex]-ih)//2)
			}

			-- Labels.
			for buttons.buttons  if it.label or it.suffix or it.shortcut {
				local scissorX1 = bx1[itIndex] + (paddingX-1)
				local scissorX2 = bx2[itIndex] - (paddingX-1)

				if scissorX2 > scissorX1 {
					local textY = by1[itIndex] + (bh[itIndex] - fontNormal.getHeight!()) // 2
					local textX: int = NULL

					if buttons.align == {
						case .LEFT:  textX = bx1[itIndex] + paddingX
						case .RIGHT: textX = bx1[itIndex] + math.max(math.round(bw[itIndex] - paddingX - it.contentWidth), paddingX)
						case:        textX = bx1[itIndex] + math.max((bw[itIndex] - it.contentWidth) // 2,                 paddingX)
					}

					if it.image {
						local iw  = guiImages[it.image].getWidth!()
						textX    += math.round(iw*it.imageScale + SPACING)
					}

					local grey, a: float
					if faded[itIndex]
						grey, a = 1, .8
					elseif buttons.style == .CONTEXT_MENU
						grey, a = 0, 1
					else
						grey, a = 1, 1

					LG.pushAll()
					intersectScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
					if it.label {
						LG.setColor(grey, grey, grey, TEXT_OPACITY*a)
						LG.print(it.label, textX, textY)
					}
					if it.suffix {
						LG.setColor(grey, grey, grey, TEXT_OPACITY*a*.6)
						LG.print(it.suffix, textX+it.labelWidth, textY)
					}
					if it.shortcut {
						LG.setColor(grey, grey, grey, TEXT_OPACITY*a)
						LG.print(it.shortcut, bx2[itIndex]-paddingX-it.shortcutWidth+SPACING_LARGE, textY)
					}
					LG.pop()
				}
			}

		case Checkbox:
			local checkbox = cast(Checkbox) el
			local y        = checkbox.layoutY + checkbox.layoutHeight // 2

			if checkbox.id ~= state.hoveredId {
				if checkbox.checked
					LG.setColor(1, 1, 1, .35)
				else
					LG.setColor(1, 1, 1, .25)
			} elseif checkbox.id ~= state.activeId {
				LG.setColor(1, 1, 1, .55)
			} else {
				LG.setColor(1, 1, 1, .45)
			}

			if checkbox.checked {
				LG.rectangle(LG.DrawMode.LINE, checkbox.layoutX+.5, y-CHECKBOX_SIZE//2+.5, CHECKBOX_SIZE-1, CHECKBOX_SIZE-1)
				LG.rectangle(LG.DrawMode.FILL, checkbox.layoutX+2,  y-CHECKBOX_SIZE//2+2,  CHECKBOX_SIZE-4, CHECKBOX_SIZE-4)
			} else {
				LG.rectangle(LG.DrawMode.LINE, checkbox.layoutX+.5, y-CHECKBOX_SIZE//2+.5, CHECKBOX_SIZE-1, CHECKBOX_SIZE-1)
			}

			LG.setFont(fontSmall)
			LG.setColor(1, 1, 1, TEXT_OPACITY)
			LG.print(checkbox.label, checkbox.layoutX+CHECKBOX_SIZE+SPACING, y-fontSmall.getHeight!()//2)
			LG.setFont(fontNormal)

		case InputText:
			local input = cast(InputText) el
			local field = input.field

			local focused = (input.id == state.focusId)

			local x = input.layoutX
			local y = input.layoutY
			local w = input.layoutWidth
			local h = input.layoutHeight

			local valueX = x + SPACING

			-- Background.
			LG.setColor(0, 0, 0, (input.style == .CONTEXT_MENU ? .8 : .5))
			LG.rectangle(LG.DrawMode.FILL, x, y, w, h, BUTTON_RADIUS)

			LG.pushAll()
			intersectScissor(x, 0, w, LG.getHeight())

			-- Selection.
			if focused {
				local x1, x2 = field.getSelectionOffset!()
				if x2 > x1 {
					LG.setColor(1, 1, 0, .5)
					LG.rectangle(LG.DrawMode.FILL, valueX+x1, y, x2-x1, h)
				}
				LG.setColor(1, 1, 1, math.lerp(.1, .9, math.cos01(field.getBlinkPhase!()*math.TAU/1.00)))
				LG.rectangle(LG.DrawMode.FILL, valueX+field.getCursorOffset!(), y, 1, h)
			}

			-- Value.
			local textOffset = focused ? field.getTextOffset!() : 0
			local text       = focused ? field.getText!() : input.value
			LG.setColor(1, 1, 1, TEXT_OPACITY)
			LG.print(text, valueX+textOffset, y+SPACING)

			-- Cursor.
			if focused {
				LG.setColor(1, 1, 1, math.lerp(.1, .9, math.cos01(field.getBlinkPhase!()*math.TAU/1.00)))
				LG.rectangle(LG.DrawMode.FILL, valueX+field.getCursorOffset!(), y, 1, h)
			}

			LG.pop()

			-- Hover/focus effect.
			if input.id == state.hoveredId or focused {
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
				LG.rectangle(LG.DrawMode.LINE, x-.5, y-.5, w+1, h+1, BUTTON_RADIUS)
			}

		case Slider:
			local slider  = cast(Slider) el
			local x1      = slider.layoutX +                      SLIDER_MIN_WIDTH // 2
			local x2      = slider.layoutX + slider.layoutWidth - SLIDER_MIN_WIDTH // 2
			local w       = x2 - x1
			local value01 = math.clamp01((slider.value - applyLimitMultiplier(slider, slider.min)) / (applyLimitMultiplier(slider, slider.max) - applyLimitMultiplier(slider, slider.min)))
			value01       = applyExponential(slider, value01, .5)
			local handleX = x1 + math.round(value01 * w)
			local y       = slider.layoutY + slider.layoutHeight // 2

			local highlight = shouldHighlight(state, slider)

			local showLimits = (
				(state.activeId or state.hoveredId)
				and slider.id == math.max(state.activeId, state.hoveredId)
				and ((state.activeId and state.activeMod == .A) or (not state.activeId and getModifierKey() == .A))
			)

			-- Line/background.
			LG.setColor(1, 1, 1, (highlight ? .2 : .1))
			LG.rectangle(LG.DrawMode.FILL, x1, y-1, w, 2)

			-- Guides.
			LG.setColor(1, 1, 1, .12)
			LG.rectangle(LG.DrawMode.FILL, x1, y-3, +1, 6)
			LG.rectangle(LG.DrawMode.FILL, x2, y-3, -1, 6)
			if w >= 50 {
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,1/4,.5)*w), y-3, 1, 6)
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,2/4,.5)*w), y-3, 1, 6)
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,3/4,.5)*w), y-3, 1, 6)
				if w >= 200 {
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,1/8,.5)*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,3/8,.5)*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,5/8,.5)*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,7/8,.5)*w), y-1, 1, 2)
				}
			}

			-- Handle.
			local grey = (highlight ? .8 : .65)
			LG.setColor(grey, grey, grey)
			LG.rectangle(LG.DrawMode.FILL, handleX-1, y-SLIDER_MIN_WIDTH/2, 2, SLIDER_MIN_WIDTH)

			-- Readout.
			local COLOR_TEXT:   love.Color: {1,1,1,.8*TEXT_OPACITY}
			local COLOR_SHADOW: love.Color: {0,0,0,.5*TEXT_OPACITY}

			if showLimits {
				local textMin = format("min "..slider.readout, applyLimitMultiplier(slider, slider.min) * slider.readoutMulti)
				local textMax = format("max "..slider.readout, applyLimitMultiplier(slider, slider.max) * slider.readoutMulti)
				local textX1  = x1 + 3
				local textX2  = x2 - 3 - fontSmall.getWidth!(textMax)
				local textY   = y  - fontSmall.getHeight!() // 2 - 1

				LG.setFont(fontSmall)
				LG.setColor(COLOR_SHADOW)
				LG.print(textMin, textX1+1, textY+1)
				LG.print(textMax, textX2+1, textY+1)
				LG.setColor(COLOR_TEXT)
				LG.print(textMin, textX1, textY)
				LG.print(textMax, textX2, textY)
				LG.setFont(fontNormal)

			} elseif app.showPanelNumbers {
				drawSliderReadout(x2, y-SLIDER_MIN_WIDTH//2, SLIDER_MIN_WIDTH, handleX, slider.value, slider.readoutMulti, slider.readout, slider.readoutZero, COLOR_TEXT, COLOR_SHADOW)
			}

		case Color:
			local drawSliderValue :: (sliderX,sliderY:int, sliderW,sliderH:int, value:float, readout:float, readoutFormat:string, highlight:bool) {
				local x = math.round(sliderX + value*(sliderW-4))
				local a = (highlight ? .9 : .7)

				if app.showPanelNumbers {
					local COLOR_TEXT:   love.Color: {1,1,1,1}
					local COLOR_SHADOW: love.Color: {0,0,0,1}
					drawSliderReadout(sliderX+sliderW, sliderY, sliderH, x, readout, 1, readoutFormat, "", COLOR_TEXT, COLOR_SHADOW)
				}

				LG.setColor(0, 0, 0, a)
				LG.rectangle(LG.DrawMode.FILL, x, sliderY, 4, sliderH)

				LG.setColor(1, 1, 1, a)
				LG.rectangle(LG.DrawMode.FILL, x+1, sliderY, 2, sliderH)
			}

			local colorEl    = cast(Color) el
			local components = (colorEl.alpha ? 3 : 4)
			local x          = colorEl.layoutX
			local y1         = colorEl.layoutY
			local y2         = y1 + math.round(1 * colorEl.sliderWidth)
			local y3         = y1 + math.round(2 * colorEl.sliderWidth)
			local y4         = y1 + math.round(3 * colorEl.sliderWidth)
			local y5         = y1 + colorEl.layoutHeight
			local w          = colorEl.layoutWidth

			local hue        = colorEl.color[1]
			local saturation = colorEl.color[2]
			local value      = colorEl.color[3]
			local a          = colorEl.color[4]

			local highlight  = shouldHighlight(state, colorEl) ? math.max(state.activeSubid, state.hoveredSubid) : 0

			local iw, ih     = imageRainbow.getDimensions!()
			local rainbowSx  = w / iw
			local rainbowSy  = (y2-y1) / ih
			LG.setColor(1, 1, 1)
			LG.draw(imageRainbow, x, y1, 0, rainbowSx, rainbowSy)
			drawSliderValue(x, y1, w, y2-y1, hue, hue*360, "%d°", (highlight == 1))

			local r, g, b    = hsvToRgb(hue, 1, 1)
			iw, ih           = imageGradient.getDimensions!()
			local gradientSx = w / iw
			local gradientSy = (y3-y2) / ih
			LG.setColor(.5, .5, .5)
			LG.rectangle(LG.DrawMode.FILL, x, y2, w, y2-y1)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, y2, 0, gradientSx, gradientSy)
			drawSliderValue(x, y2, w, y3-y2, saturation, saturation*100, "%d%%", (highlight == 2))

			r, g, b    = hsvToRgb(hue, saturation, 1)
			gradientSy = (y4-y3) / ih
			LG.setColor(0, 0, 0)
			LG.rectangle(LG.DrawMode.FILL, x, y3, w, y4-y3)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, y3, 0, gradientSx, gradientSy)
			drawSliderValue(x, y3, w, y4-y3, value, value*100, "%d%%", (highlight == 3))

			if colorEl.alpha {
				r, g, b    = hsvToRgb(hue, saturation, value)
				gradientSy = (y5-y4) / ih
				drawCheckerBox(x, y4, w, y5-y4)
				LG.setColor(r, g, b)
				LG.draw(imageGradient, x, y4, 0, gradientSx, gradientSy)
				drawSliderValue(x, y4, w, y5-y4, a, a*100, "%d%%", (highlight == 4))
			}

			if highlight {
				local hlIndex = math.max(state.hoveredSubid, state.activeSubid)
				local hlY1    = y1 + math.round((hlIndex-1) * colorEl.sliderWidth)
				local hlY2    = y1 + math.round((hlIndex  ) * colorEl.sliderWidth)
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY_STRONG)
				LG.rectangle(LG.DrawMode.LINE, x-.5, hlY1-.5, w+1, hlY2-hlY1+1)
			}

		case ColorPreview:
			local preview = cast(ColorPreview) el

			static shader: LG.Shader = NULL
			if shader == NULL  shader = LG.newShader("src/particleColorPreview.glsl")

			-- The shader only supports 8 colors, but we can change that if necessary.
			static colorsForShader: [][]float = { {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1} }

			local colorCount = 0

			for preview.linkColors {
				local colorEl = cast(Color) state.elementsByName[it]

				if colorEl ~= NULL and isElementVisible(colorEl) {
					colorCount  += 1
					local color  = colorsForShader[colorCount]

					color[1], color[2], color[3] = hsvToRgb(colorEl.color)
					color[4]                     = colorEl.alpha ? colorEl.color[4] : 1
				}
			}

			shader.send!("colors",     colorsForShader[1], unpack(colorsForShader, 2))
			shader.send!("colorCount", colorCount)

			drawCheckerBox(preview.layoutX, preview.layoutY, preview.layoutWidth, preview.layoutHeight)

			LG.setShader(shader)
			LG.setBlendMode(preview.blendMode)
			LG.draw(imagePixel, preview.layoutX, preview.layoutY, 0, preview.layoutWidth, preview.layoutHeight)
			LG.setBlendMode(.ALPHA)
			LG.setShader()

		case Direction:
			local direction = cast(Direction) el

			local r :: DIRECTION_RADIUS
			local x = direction.layoutX + r
			local y = direction.layoutY + r

			local angle = direction.angle

			local highlight = shouldHighlight(state, direction)

			-- Background.
			LG.setColor(0, 0, 0, .4)
			LG.circle(LG.DrawMode.FILL, x, y, r)

			-- Spread.
			if direction.linkSpread {
				local other = cast(Slider) state.elementsByName[direction.linkSpread]

				if other ~= NULL and other.type == Slider and other.value ~= 0 and isElementVisible(other) {
					LG.setColor(1, 1, 1, .25)
					LG.arc(LG.DrawMode.FILL, x, y, .8*r, angle-other.value/2, angle+other.value/2, 32)
				}

			} elseif direction.linkOther {
				local other = cast(Direction) state.elementsByName[direction.linkOther]

				if other ~= NULL and other.type == Direction and other.angle ~= angle and isElementVisible(other) {
					LG.setColor(1, 1, 1, .25)
					LG.arc(LG.DrawMode.FILL, x, y, .8*r, angle, other.angle, 32)
				}
			}

			-- Guides.
			LG.setColor(1, 1, 1, .08)
			LG.line(x-r+1, y, x+r-1, y)
			LG.line(x, y-r+1, x, y+r-1)
			LG.line(x-.3*r, y-.3*r, x+.3*r, y+.3*r)
			LG.line(x+.3*r, y-.3*r, x-.3*r, y+.3*r)

			-- Outline.
			if highlight {
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
				LG.circle(LG.DrawMode.LINE, x, y, r+.5)
			}

			-- Value.
			LG.setColor(1, 1, 1)
			LG.line(x, y, x+r*math.cos(angle), y+r*math.sin(angle))

			-- Readout.
			if app.showPanelNumbers {
				local text  = format("%d°", angle*360/math.TAU)
				local textX = x - fontSmall.getWidth!(text) // 2
				local textY = (angle % math.TAU < math.PI) ? direction.layoutY+5 : direction.layoutY+2*r-5-fontSmall.getHeight!()
				LG.setFont(fontSmall)
				LG.setColor(0, 0, 0, TEXT_OPACITY)
				LG.print(text, textX+1, textY+1)
				LG.setColor(1, 1, 1, TEXT_OPACITY)
				LG.print(text, textX, textY)
				LG.setFont(fontNormal)
			}

		case Canvas:
			local canvasEl = cast(Canvas) el

			local x = canvasEl.layoutX
			local y = canvasEl.layoutY
			local w = canvasEl.layoutWidth
			local h = canvasEl.layoutHeight

			LG.pushAll()
			LG.translate(x, y)
			LG.setColor(1, 1, 1)
			intersectScissor(x, y+getScrollOffset(canvasEl), w, h)
			triggerDrawEvent(state, canvasEl, w, h)
			LG.pop()

		case: errorf("%d", el.type)
	}

	!if DEV  if LK.isScancodeDown"`" {
		if el[1] == NULL {
			LG.setColor(0, 1, 0, .5)
		} else {
			LG.setColor(1, 0, 0, .35)
			LG.setColorMask(true, false, true, true)
		}
		LG.rectangle(LG.DrawMode.LINE, el.layoutX+.5, el.layoutY+.5, el.layoutWidth-1, el.layoutHeight-1)
		LG.setColorMask()
	}
}

export draw :: (state:State) {
	updateLayoutIfNeeded(state)

	local ww, wh   = LG.getDimensions()
	local topModal = state.getTopmostActiveModal!()

	for state.frames  if it.active {
		if it == topModal {
			LG.setColor(.2, .2, .2, .6)
			LG.rectangle(LG.DrawMode.FILL, 0, 0, ww, wh)
		}
		drawElement(state, it)
	}

	if state.currentTooltip {
		local a = math.clamp01(((LT.getTime() - state.tooltipTime) - .30) / 0.20)

		if a > 0 {
			local w, lines = fontNormal.getWrap!(state.currentTooltip, 100_000)
			local fontH    = fontNormal.getHeight!()

			w       += 2*SPACING
			local h  = fontH + math.ceil((#lines-1)*fontH*fontNormal.getLineHeight!()) + 2*BUTTON_PADDING_Y
			local x  = math.max(math.min(state.tooltipX, ww-w), 0)
			local y  = state.tooltipY1 - h - 1

			if y < 0  y = state.tooltipY2 + 1

			LG.setColor(0, 0, 0, .3*a)
			drawBoxGradient(x, y, w, h)
			LG.setColor(0, 0, 0, .8*a)
			LG.rectangle(LG.DrawMode.FILL, x-1, y-1, w+2, h+2, BUTTON_RADIUS)
			LG.setColor(.8, .8, .8, a)
			LG.rectangle(LG.DrawMode.FILL, x, y, w, h, 2)
			LG.setColor(0, 0, 0, a)
			LG.print(state.currentTooltip, x+SPACING, y+BUTTON_PADDING_Y)
		}
	}
}



export isInsideElement :: (state:State, x,y:int, el:Element) -> bool {
	if not el.active  return false

	updateLayoutIfNeeded(state)

	if el.type == {
		case Direction:
			local r :: DIRECTION_RADIUS
			return math.distance(x,y, el.layoutX+r,el.layoutY+r) <= r

		case Slider:
			return x >= el.layoutX and x < el.layoutX+el.layoutWidth and math.abs(y-(el.layoutY+el.layoutHeight/2)) <= SLIDER_MIN_WIDTH/2

		case Checkbox:
			return x >= el.layoutX and x < el.layoutX+el.layoutWidth and math.abs(y-(el.layoutY+el.layoutHeight/2)) <= CHECKBOX_SIZE/2

		case:
			return
				x >= el.layoutX and
				y >= el.layoutY and
				x <  el.layoutX+el.layoutWidth and
				y <  el.layoutY+el.layoutHeight
	}
}

export isOverGui :: (state:State, x,y:int) -> bool {
	for state.frames {
		if state.isInsideElement!(x, y, it)  return true
	}
	return false
}



export getElement :: (state:State, name:string, $T:Type) -> T {
	return cast(T) state.elementsByName[name]
}
export getElement :: (state:State, name:string) -> Element { -- @Compiler @Incomplete: Default values for baked arguments.
	return state.elementsByName[name]
}

export getElementAt :: (state:State, x,y:int) -> (found:bool, el:Element) {
	updateLayoutIfNeeded(state)

	for < state.frames  if it.active {
		local helper :: (state:State, el:Element, x,y:int) -> Element {
			if not state.isInsideElement!(x, y, el)  return NULL

			if el.type == Scrollable  y -= math.round((cast(Scrollable)el).scroll)

			if not (el.type == Section and app.hiddenSections[el.name]) {
				for < el {
					local subEl = helper(state, it, x, y)
					if subEl ~= NULL  return subEl
				}
			}

			return el
		}

		local el = helper(state, it, x, y)
		if el ~= NULL  return true, el

		if it.modal  return false, NULL
	}

	return false, NULL
}

export getWidgetAt :: (state:State, x,y:int) -> (found:bool, widget:Widget) {
	local found, widget = state.getElementAt!(x, y)
	if not found  return false, NULL

	if widget.type == {
		case Buttons:   return true, cast(Widget)widget
		case InputText: return true, cast(Widget)widget
		case Radio:     return true, cast(Widget)widget
		case Tabs:      return true, cast(Widget)widget
		case Checkbox:  return true, cast(Widget)widget
		case Slider:    return true, cast(Widget)widget
		case Color:     return true, cast(Widget)widget
		case Direction: return true, cast(Widget)widget

		case Scrollable:
			if x < widget.layoutX + widget.layoutWidth - SCROLLBAR_WIDTH  return false, NULL
			return true, cast(Widget)widget

		case Section:
			local section = cast(Section) widget
			if not section.name   return false, NULL
			if not section.label  return false, NULL
			if y >= widget.layoutY + fontNormal.getHeight!() + getScrollOffset(section)  return false, NULL
			if x >= widget.layoutX + fontNormal.getWidth!(section.label)                 return false, NULL
			return true, cast(Widget)widget

		case:
			return false, NULL
	}
}

export findParent :: (state:State, el:Element, name:string) -> (found:bool, parent:Element) {
	while true {
		el = el.parent
		if el      == NULL  return false, NULL
		if el.name == name  return true,  el
	}
}



export setActive :: (state:State, name:string, active:bool) -> (success:bool) {
	local el = state.elementsByName[name]
	if el == NULL {
		log("Error: No element '%s'.", name)
		return false
	}

	return state.setActive!(el, active)
}
export setActive :: (state:State, el:Element, active:bool) -> (success:bool) {
	if el.active == active  return true

	el.active               = active
	state.layoutNeedsUpdate = true

	if not active and state.focusId and (el.id == state.focusId or hasParent(state.elementsById[state.focusId], el)) {
		state.blurFocus!(abort=false)
	}

	if el.type == Frame {
		local frame    = cast(Frame) el
		local found, i = indexOf(state.frames, frame)
		assert(found)
		remove(state.frames, i)
		insert(state.frames, frame)
	}

	if active {
		local resetScroll :: (el:Element) {
			if el.type == Scrollable {
				local scrollable = cast(Scrollable) el
				scrollTo(scrollable, 0)
			}
			for el  resetScroll(it)
		}
		resetScroll(el)
	}

	if active
		triggerActiveEvent(state, el)
	else
		triggerInactiveEvent(state, el)

	return true
}

local hasParent :: (el:Element, parent:Element) -> bool {
	while el.parent ~= NULL {
		if el.parent == parent  return true
		el = el.parent
	}
	return false
}



local getScrollbarHandle :: (scrollable:Scrollable, visual:bool) -> (handlePos:int, handleLen:int, handlePosMax:int) {
	local contentH = scrollable.contentHeight
	local visibleH = scrollable.layoutHeight
	local paddedH  = visibleH - 2*SPACING

	local handleLen = math.clamp(
		math.round(visibleH * paddedH / contentH),
		SCROLLBAR_MIN_LENGTH,
		visibleH
	)

	local handlePos, handlePosMax = 0, 0
	if contentH > paddedH {
		local scroll = visual ? scrollable.scroll : scrollable.scrollTarget
		handlePosMax = visibleH - handleLen
		handlePos    = math.min(math.round(-scroll*handlePosMax/(contentH-paddedH)), handlePosMax)
	}

	return handlePos, handleLen, handlePosMax
}

local limitScroll :: (scrollable:Scrollable) {
	local limit             = math.max(scrollable.contentHeight - scrollable.layoutHeight + 2*SPACING, 0)
	scrollable.scrollTarget = math.clamp(scrollable.scrollTarget, -limit, 0)
	scrollable.scroll       = math.clamp(scrollable.scroll,       -limit, 0)
}

export getScrollOffset :: (state:State, el:Element) -> int {
	return getScrollOffset(el)
}

export getScrollOffset :: (el:Element) -> int {
	local offset = 0

	while el.parent ~= NULL {
		el = el.parent
		if el.type == Scrollable {
			offset += math.round((cast(Scrollable)el).scroll) -- Should we round here or when we return?
		}
	}

	return offset
}



export drawChecker :: (x,y,w,h:float, scale=1.0) {
	static quad: LG.Quad = NULL

	if quad == NULL {
		local iw, ih = imageChecker.getDimensions!()
		quad         = LG.newQuad(0, 0, 1, 1, iw, ih)
	}

	quad.setViewport!(0, 0, w/scale, h/scale)
	LG.draw(imageChecker, quad, x, y, 0, scale)
}

export drawCheckerBox :: (x,y,w,h:int) {
	LG.setColor(.15, .15, .15)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
	LG.setColor(.27, .27, .27)
	drawChecker(x, y, w, h)
}



export drawBoxGradient :: (x,y,w,h:int, bw=10) {
	static quad11: LG.Quad = NULL
	static quad12: LG.Quad = NULL
	static quad13: LG.Quad = NULL
	static quad21: LG.Quad = NULL
	static quad22: LG.Quad = NULL
	static quad23: LG.Quad = NULL
	static quad31: LG.Quad = NULL
	static quad32: LG.Quad = NULL
	static quad33: LG.Quad = NULL

	if quad11 == NULL {
		local iw, ih = imageBoxGradient.getDimensions!()

		quad11 = LG.newQuad(0,0, 1,1, 3,3)
		quad12 = LG.newQuad(1,0, 1,1, 3,3)
		quad13 = LG.newQuad(2,0, 1,1, 3,3)
		quad21 = LG.newQuad(0,1, 1,1, 3,3)
		quad22 = LG.newQuad(1,1, 1,1, 3,3)
		quad23 = LG.newQuad(2,1, 1,1, 3,3)
		quad31 = LG.newQuad(0,2, 1,1, 3,3)
		quad32 = LG.newQuad(1,2, 1,1, 3,3)
		quad33 = LG.newQuad(2,2, 1,1, 3,3)
	}

	LG.draw(imageBoxGradient, quad11, x-bw, y-bw, 0, bw, bw)
	LG.draw(imageBoxGradient, quad12, x,    y-bw, 0, w,  bw)
	LG.draw(imageBoxGradient, quad13, x+w,  y-bw, 0, bw, bw)
	LG.draw(imageBoxGradient, quad21, x-bw, y,    0, bw, h)
	LG.draw(imageBoxGradient, quad22, x,    y,    0, w,  h)
	LG.draw(imageBoxGradient, quad23, x+w,  y,    0, bw, h)
	LG.draw(imageBoxGradient, quad31, x-bw, y+h,  0, bw, bw)
	LG.draw(imageBoxGradient, quad32, x,    y+h,  0, w,  bw)
	LG.draw(imageBoxGradient, quad33, x+w,  y+h,  0, bw, bw)
}



local triggerRefreshEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onRefresh[el.name]
	if cb == NULL  return

	cb(el)
	state.layoutNeedsUpdate = true
}

local triggerActiveEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onActive[el.name]
	if cb == NULL  return

	cb(el)
}
local triggerInactiveEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onInactive[el.name]
	if cb == NULL  return

	cb(el)
}

local triggerDrawEvent :: (state:State, canvasEl:Canvas, cw,ch:int) {
	local cb = cast((canvasEl:Canvas, cw,ch:int)) state.onDraw[canvasEl.name]
	if cb == NULL  return

	cb(canvasEl, cw, ch)
}

local triggerSubmitEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onSubmit[el.name]
	if cb == NULL  return

	cb(el)
}

local triggerBeforeActionEvent :: (state:State, widget:Widget, name:string, subid:int) -> (ignore:bool) {
	local cb = cast((widget:Widget, i:int) -> (ignore:bool)) state.onBeforeAction[name ?: widget.name]
	if cb == NULL  return false

	return cb(widget, subid)
}
local triggerBeginEvent :: (state:State, widget:Widget, name:string, subid:int) {
	-- printf("GuiEvent: Begin  '%s'", (name ?: widget.name)) -- DEBUG
	local cb = cast((widget:Widget, i:int)) state.onBegin[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
}
local triggerActionEvent :: (state:State, widget:Widget, name:string, subid:int, alsoEnd=false) {
	-- printf("GuiEvent: Action '%s'", (name ?: widget.name)) -- DEBUG

	local cb = cast((widget:Widget, i:int)) state.onAction[name ?: widget.name]
	if cb ~= NULL  cb(widget, subid)

	if alsoEnd {
		triggerEndEvent(state, widget, name, subid)
		if cb ~= NULL  scheduleSaveWorkspace()
	}
}
local triggerEndEvent :: (state:State, widget:Widget, name:string, subid:int) {
	-- printf("GuiEvent: End    '%s'", (name ?: widget.name)) -- DEBUG
	local cb = cast((widget:Widget, i:int)) state.onEnd[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
	scheduleSaveWorkspace()
}

local triggerDoublePressEvent :: (state:State, widget:Widget, name:string, subid:int) -> (handled:bool) {
	local cb = cast((widget:Widget, i:int)) state.onDouble[name ?: widget.name]
	if cb == NULL  return false

	cb(widget, subid)
	scheduleSaveWorkspace()
	return true
}

local triggerOptionEvent :: (state:State, widget:Widget, name:string, subid:int) -> (handled:bool) {
	local cb = cast((widget:Widget, i:int)) state.onOption[name ?: widget.name]
	if cb == NULL  return false

	cb(widget, subid)
	return true
}

local triggerCloseEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, i:int)) state.onClose[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
	scheduleSaveWorkspace()
}

local triggerDragBeginEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, i:int)) state.onDragBegin[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
}
local triggerDragEvent :: (state:State, widget:Widget, name:string, subid:int, mx,my:int) {
	local cb = cast((widget:Widget, i:int, mx,my:int)) state.onDrag[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid, mx, my)
}
local triggerDragEndEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, i:int)) state.onDragEnd[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
}

local triggerMouseEnterEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, i:int)) state.onMouseEnter[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
}



export refresh :: (state:State, el:Element) {
	triggerRefreshEvent(state, el)
}
export refresh :: (state:State, name:string) {
	local el = state.elementsByName[name]
	if el == NULL {
		log("Error: No element '%s'.", name)
		return
	}

	triggerRefreshEvent(state, el)
}

export refreshRecursively :: (state:State, el:Element, onlyActive=true) {
	triggerRefreshEvent(state, el)
	for el  if not (onlyActive and not it.active) {
		state.refreshRecursively!(it, onlyActive)
	}
}
export refreshRecursively :: (state:State, name:string, onlyActive=true) {
	local el = state.elementsByName[name]
	if el == NULL {
		log("Error: No element '%s'.", name)
		return
	}

	triggerRefreshEvent(state, el)
	for el  if not (onlyActive and not it.active) {
		state.refreshRecursively!(it, onlyActive)
	}
}

export refreshAll :: (state:State, onlyActive=true) {
	for state.frames  if not (onlyActive and not it.active) {
		state.refreshRecursively!(it, onlyActive)
	}
}



export isElementVisible :: (el:Element) -> bool {
	while el.parent ~= NULL {
		if not el.active  return false
		el = el.parent
	}

	return el.active
}

export isElementVisible :: (state:State, el:Element) -> bool {
	return isElementVisible(el)
}

export isElementVisible :: (state:State, name:string) -> bool {
	local el = state.elementsByName[name]
	return el ~= NULL and isElementVisible(el)
}



export setFocus :: (state:State, name:string) {
	local input = cast(InputText) state.elementsByName[name]
	if input == NULL {
		log("Error: No element '%s'.", name)
		return
	}

	if input.type ~= InputText {
		log("Error: Element '%s' is not InputText.", name)
		return
	}

	state.setFocus!(input)
}
export setFocus :: (state:State, input:InputText) {
	if state.focusId == input.id  return

	state.blurFocus!(abort=false)
	state.focusId = input.id

	if input.field == NULL {
		input.field = InputField()
		input.field.setFont!(fontNormal)
		input.field.setWidth!(input.layoutWidth - 2*SPACING)
	}

	input.field.setText!(input.value)
	input.field.setScroll!(0)
}

export blurFocus :: (state:State, abort=false) {
	if not state.focusId  return

	local input = cast(InputText) state.elementsById[state.focusId]
	if input.field.getText!() == input.value {
		-- void
	} elseif abort {
		input.field.setText!(input.value)
	} else {
		triggerBeginEvent(state, input, "", 0)
		input.value = input.field.getText!()
		triggerActionEvent(state, input, "", 0, alsoEnd=true)
	}

	state.focusId = 0
	scheduleSaveWorkspace()
}



export getTopmostActiveModal :: (state:State) -> Frame {
	for < state.frames {
		if it.active and it.modal  return it
	}
	return NULL
}



export pressButton :: (state:State, buttonsElementName:string, i:int) {
	local buttons = cast(Buttons) state.elementsByName[buttonsElementName]
	if buttons == NULL {
		log("Error: No element '%s'.", buttonsElementName)
		return
	}

	if not (buttons.type == Buttons or buttons.type == Radio or buttons.type == Tabs) {
		log("Error: '%s' is not a buttons element.", buttonsElementName)
		return
	}

	local button = buttons.buttons[i]
	if button == NULL or true {
		log("Error: No button at index %d in '%s'.", i, buttonsElementName)
		return
	}

	triggerBeginEvent (state, buttons, button.name, i)
	triggerActionEvent(state, buttons, button.name, i, alsoEnd=true)
}



local limitMenuPosition :: (state:State, contextMenu:Frame) {
	updateLayoutIfNeeded(state)

	local x = contextMenu.layoutX
	local y = contextMenu.layoutY
	local w = contextMenu.layoutWidth
	local h = contextMenu.layoutHeight

	if x   > LG.getWidth()-w  state.layoutNeedsUpdate, contextMenu.x = true, math.max(LG.getWidth()-w, 0)
	if y+h > LG.getHeight()   state.layoutNeedsUpdate, contextMenu.y = true, y - h
}

export showMenu :: (state:State, x,y:int, items:[]MenuItem, cb:(choice:string, data:any)) {
	state.hideContextMenu!()

	local makeContextMenu :: (state:State, items:[]MenuItem, parentMenu:Frame, active=false) -> Frame {
		local buttons     = state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16 })
		local contextMenu = state.frame!({ parentFrame=parentMenu, minWidth=CONTEXT_MENU_MIN_WIDTH, layout=.FLOATING, style=.CONTEXT_MENU, active=active, buttons })
		insert(state.contextMenus, contextMenu)

		for items {
			if it.label == "-" {
				insert(contextMenu, state.separator!({ thick=false }))

				buttons = state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16 })
				insert(contextMenu, buttons)

			} else {
				insert(buttons.buttons, cast(Button){ value=it, label=it.label, shortcut=it.shortcut, submenuIcon=cast(bool)it.submenu })

				if it.submenu  it.submenuFrame = makeContextMenu(state, it.submenu, contextMenu)
			}
		}

		return contextMenu
	}

	local contextMenu = makeContextMenu(state, items, NULL, true)
	contextMenu.data  = cb
	contextMenu.x     = x
	contextMenu.y     = y

	for state.contextMenus  insert(state.frames, it)

	state.layoutNeedsUpdate = true
	limitMenuPosition(state, contextMenu)

	state.onMouseEnter.__contextMenuButtons = [state,cb] (buttons:Buttons, buttonIndex:int) {
		local button = buttons.buttons[buttonIndex]
		local item   = cast(MenuItem) button.value

		local frame                           = buttons.frame
		local menusToShow: Table(Frame, bool) = {[frame]=true}

		while frame.parentFrame ~= NULL {
			frame              = frame.parentFrame
			menusToShow[frame] = true
		}

		-- @UX: Don't hide (or show) submenus until after a delay (or click to show).
		for state.contextMenus  if it.active and not menusToShow[it] {
			it.active               = false
			state.layoutNeedsUpdate = true
		}

		if not item.submenu  return

		item.submenuFrame.active = true
		item.submenuFrame.x      = buttons.parent.layoutX + buttons.parent.layoutWidth - 3
		item.submenuFrame.y      = math.round(buttons.layoutY + (buttonIndex-1) * buttons.buttonHeight) - SPACING
		state.layoutNeedsUpdate  = true
		limitMenuPosition(state, item.submenuFrame)
	}

	state.onAction.__contextMenuButtons = [state,cb] (buttons:Buttons, buttonIndex:int) {
		local button = buttons.buttons[buttonIndex]
		local item   = cast(MenuItem) button.value

		if item.submenu  return

		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		cb(item.name, item.data)
		scheduleSaveWorkspace()
	}
}

export showContextMenu :: (state:State, items:[]string, cb:(choice:int)) {
	local mx, my = LM.getPosition()
	state.showContextMenu!(mx, my, items, cb)
}
export showContextMenu :: (state:State, x,y:int, items:[]string, cb:(choice:int)) {
	state.hideContextMenu!()

	local buttonList: []Button
	for items {
		local ok, label, shortcut = matchPattern(it, "^(.*)\t(.*)$")
		if ok
			insert(buttonList, cast(Button){ label=cast(string)label, shortcut=cast(string)shortcut })
		else
			insert(buttonList, cast(Button){ label=it })
	}

	local contextMenu = state.frame!({ data=cb, x=x, y=y, minWidth=CONTEXT_MENU_MIN_WIDTH, layout=.FLOATING, style=.CONTEXT_MENU,
		state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16,
			buttons = {unpack(buttonList)},
		}),
	})

	state.contextMenus = {contextMenu}
	insert(state.frames, contextMenu)

	state.layoutNeedsUpdate = true
	limitMenuPosition(state, contextMenu)

	state.onAction.__contextMenuButtons = [state,cb] (buttons:Buttons, buttonIndex:int) {
		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		cb(buttonIndex)
		scheduleSaveWorkspace()
	}
}

export showContextMenuWithInput :: (state:State, value:string, items:[]string, cb:(choice:int), cbInput:(text:string), inputTooltip="") {
	local mx, my = LM.getPosition()
	state.showContextMenuWithInput!(mx, my, value, items, cb, cbInput, inputTooltip)
}
export showContextMenuWithInput :: (state:State, x,y:int, value:string, items:[]string, cb:(choice:int), cbInput:(text:string), inputTooltip="") {
	state.hideContextMenu!()

	local buttonList: []Button
	for items {
		local ok, label, shortcut = matchPattern(it, "^(.*)\t(.*)$")
		if ok
			insert(buttonList, cast(Button){ label=cast(string)label, shortcut=cast(string)shortcut })
		else
			insert(buttonList, cast(Button){ label=it })
	}

	local input = state.inputText!({ name="__contextMenuInput", value=value, style=.CONTEXT_MENU, tooltip=inputTooltip })

	local contextMenu = state.frame!({ data=cb, x=x, y=y, minWidth=CONTEXT_MENU_MIN_WIDTH, layout=.FLOATING, style=.CONTEXT_MENU,
		input,
		state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16,
			buttons = {unpack(buttonList)},
		}),
	})

	state.contextMenus = {contextMenu}
	insert(state.frames, contextMenu)

	state.layoutNeedsUpdate = true
	limitMenuPosition(state, contextMenu)

	state.onAction.__contextMenuInput = [cbInput] (input:InputText) {
		cbInput(input.value)
		scheduleSaveWorkspace()
	}
	state.onSubmit.__contextMenuInput = [state,cb] (input:InputText) {
		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		cb(0)
		scheduleSaveWorkspace()
	}

	state.onAction.__contextMenuButtons = [state,cb] (buttons:Buttons, buttonIndex:int) {
		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		cb(buttonIndex)
		scheduleSaveWorkspace()
	}

	state.setFocus!(input)
	input.field.selectAll!()
}

export hideContextMenu :: (state:State, mayDeactivateSubmenu=false) -> (success:bool) {
	local contextMenus = state.contextMenus
	if not contextMenus  return false

	if mayDeactivateSubmenu {
		local activeCount = 0
		for contextMenus  if it.active  activeCount += 1

		if activeCount >= 2 {
			for < contextMenus  if it.active {
				it.active = false
				return true
			}
		}
	}

	for contextMenus  state.delete!(it)
	state.contextMenus = {}

	local mx, my = LM.getPosition()
	state.onMouseMoved!(mx, my, 0, 0)

	state.onAction    .__contextMenuButtons = nil
	state.onMouseEnter.__contextMenuButtons = nil

	local cb = cast((choice:int)) contextMenus[1].data
	if cb ~= NULL  cb(0)

	return true
}



export delete :: (state:State, el:Element) {
	updateLayoutIfNeeded(state) -- Needed for parents. @Speed

	if el.type == Frame {
		local frame    = cast(Frame) el
		local found, i = indexOf(state.frames, frame)
		if not found  return

		unregisterTree(state, frame)
		remove(state.frames, i)

	} else {
		local found, i = indexOf(el.parent, el)
		if not found  return

		unregisterTree(state, el)
		remove(el.parent, i)
	}
}



local shouldHighlight :: (state:State, el:$T) -> bool {
	if el.id == state.activeId or el.id == state.hoveredId  return true

	local mod = state.activeId ? state.activeMod : getModifierKey()
	if not (mod == .S or mod == .CS)  return false

	local other = cast(T) state.elementsById[state.activeId ?: state.hoveredId]
	if other      == NULL  return false
	if other.type ~= T     return false

	!if    T == Slider     return (indexOf(other.linkMultiDrag, el.name))
	elseif T == Direction  return (indexOf(other.linkMultiDrag, el.name))
	elseif T == Color      return (indexOf(other.linkMultiDrag, el.name))
}



local intersectScissor :: (x,y,w,h:int) {
	LG.intersectScissor(x, y, math.max(w, 0), math.max(h, 0))
}



local drawSliderReadout :: (rightX:int, topY:int, height:int, handleX:int, value:float, valueMultiplierForFormat:float, formatString:string, formatStringIfZero:string, colorText,colorShadow:love.Color) {
	if value == 0 and formatStringIfZero  formatString = formatStringIfZero

	if not formatString  return

	local text  = format(formatString, value * valueMultiplierForFormat)
	local textW = fontSmall.getWidth!(text)
	local textX = rightX - SPACING - textW
	local textY = topY + (height - fontNormal.getHeight!()) // 2

	local MIN_DIST_TO_HANDLE :: 5
	if textX < handleX+MIN_DIST_TO_HANDLE  textX = handleX-MIN_DIST_TO_HANDLE - textW

	LG.setFont(fontSmall)
	LG.setColor(colorShadow)
	LG.print(text, textX+1, textY+1)
	LG.setColor(colorText)
	LG.print(text, textX, textY)
	LG.setFont(fontNormal)
}



local applyLimitMultiplier :: (slider:Slider, value:float) -> float {
	value = (value - slider.limitCenter) * getLimitMultiplier(slider) + slider.limitCenter
	if slider.isInt  value = math.round(value)
	return value
}

local getLimitMultiplier :: (slider:Slider) -> float {
	local project = app.projects[app.currentProjectIndex] -- @Cleanup: Remove project stuff from GUI.
	local limit   = project.guiLimits[slider.limitName]
	return limit ~= NULL ? limit : 1
}

local setLimitMultiplier :: (slider:Slider, limitMultiplier:float) {
	if not slider.limitName  return

	local project = app.projects[app.currentProjectIndex] -- @Cleanup: Remove project stuff from GUI.
	project.guiLimits[slider.limitName] = limitMultiplier

	-- Note: We're not calling scheduleSaveWorkspace() here - that's the caller's responsibility!
}

local forgetLimitMultiplier :: (slider:Slider) {
	if not slider.limitName  return

	local project = app.projects[app.currentProjectIndex] -- @Cleanup: Remove project stuff from GUI.
	project.guiLimits[slider.limitName] = NULL

	-- Note: We're not calling scheduleSaveWorkspace() here - that's the caller's responsibility!
}



local applyExponential :: (slider:Slider, value01:float, exponent:float) -> float {
	if not slider.exponential  return value01

	local zero01      = slider.min / (slider.min - slider.max)
	local rangeOnSide = (value01 < zero01) ? zero01 : 1-zero01

	value01 = math.powKeepSign((value01 - zero01) / rangeOnSide, exponent) * rangeOnSide + zero01

	return value01
}



local commitValueFromInput :: (state:State, slider:Slider, text:string) {
	local ok, n = stringToFloat(text)
	if not ok  return

	n = n / slider.readoutMulti

	if slider.isInt  n = math.round(n)

	if n < 0 and slider.min == 0 and slider.limitCenter == 0 {
		n = 0
	}

	if n == slider.value  return

	triggerBeginEvent(state, slider, "", 0)
	slider.value = n
	triggerActionEvent(state, slider, "", 0, alsoEnd=true)
}

local commitValueFromInput :: (state:State, direction:Direction, text:string) {
	local ok, angle = stringToFloat(text)
	if not ok  return

	angle = angle / 360 * math.TAU

	if angle == direction.angle  return

	triggerBeginEvent(state, direction, "", 0)
	direction.angle = angle
	triggerActionEvent(state, direction, "", 0, alsoEnd=true)
}

local commitValueFromInput :: (state:State, colorEl:Color, component:int, text:string) {
	local ok, value = stringToFloat(text)
	if not ok  return

	value = value / (component == 1 ? 360 : 100)
	value = math.clamp01(value)

	if value == colorEl.color[component]  return

	triggerBeginEvent(state, colorEl, "", component)
	colorEl.color[component] = value
	triggerActionEvent(state, colorEl, "", component, alsoEnd=true)
}



export scrollTo :: (scrollable:Scrollable, scroll:int) {
	scrollable.scroll       = scroll
	scrollable.scrollSource = scroll
	scrollable.scrollTarget = scroll
}

export scrollTo :: (state:State, scrollable:Scrollable, scroll:int) {
	scrollTo(scrollable, scroll)
}


