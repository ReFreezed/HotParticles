--[[============================================================
--=
--=  Retained-mode GUI
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	State

	Buttons, Radio, Tabs
	Canvas
	Checkbox
	Direction
	Frame
	Hbox, Vbox
	InputText
	Scrollable
	Section
	Separator
	Slider, Color, ColorPreview
	Text

	delete
	draw
	drawChecker, drawCheckerBox
	getElement, getElementAt, getWidgetAt, findParent
	getTopmostActiveModal
	isElementVisible
	isInsideElement, isOverGui
	onKeyPressed, onKeyReleased, onTextInput
	onMousePressed, onMouseMoved, onMouseReleased, onMouseWheel
	pressButton
	refresh, refreshRecursively, refreshAll
	setActive
	showContextMenu, hideContextMenu

--============================================================]]



export SPACING       :: 3
export SPACING_LARGE :: 10

local BUTTON_RADIUS    :: 3
local BUTTON_PADDING_Y :: 2

local SCROLLABLE_PADDING   :: 5 -- Vertical.
local SCROLLBAR_WIDTH      :: 8
local SCROLLBAR_MIN_LENGTH :: 30

local SECTION_LABEL_WIDTH :: 100

local SLIDER_MIN_WIDTH    :: 12
local SLIDER_MIN_LENGTH   :: 70
local COLOR_PREVIEW_WIDTH :: 24

local INPUT_MIN_WIDTH :: 40

local CHECKBOX_SIZE :: 14 -- @Temp until we have an image.

local DIRECTION_RADIUS :: 25

local BUTTON_IMAGE_MAX_SIZE :: 20 -- Also the size of particle previews.
local SPECIAL_TAB_WIDTH     :: 32

local TAB_BOTTOM_LINE_WIDTH :: 2

local HOVER_OUTLINE_OPACITY        :: .3
local HOVER_OUTLINE_OPACITY_STRONG :: .7

local DRAG_RADIUS :: 8 -- Distance moved before dragging starts for real.

local CONTEXT_MENU_MIN_WIDTH :: 150



export clipboardScalar = 0.0
export clipboardAngle  = 0.0
export clipboardColor: []float = {0,0,0,0}
export hasClipboardScalar = false
export hasClipboardAngle  = false
export hasClipboardColor  = false



export State :: struct {
	frames:      []Frame,
	scrollables: []Scrollable,

	elementsById:   struct { !key: int,    !value: Element },
	elementsByName: struct { !key: string, !value: Element },

	nextId = 1,

	hoveredId    = 0,
	hoveredSubid = 0,

	activeId       = 0,
	activeSubid    = 0,
	activeMod      = ModifierKey.NONE,
	activeStartMx  = 0,
	activeStartMy  = 0,
	activeDragging = false, -- For the drag event - not for sliders etc.!

	focusId = 0, -- Keyboard focus.

	currentTooltip = "",
	tooltipTime    = 0.00,
	tooltipX       = 0,
	tooltipY1      = 0, -- Primary.
	tooltipY2      = 0, -- Fallback.

	layoutNeedsUpdate = true,

	extraScrollableSpace = 0,

	contextMenu: Frame = NULL,

	scrollbarHandleDragOffset = 0,

	onRefresh:  struct { !key:string, !value:any--[[ (el:Element) ]] },
	onActive:   struct { !key:string, !value:any--[[ (el:Element) ]] },
	onInactive: struct { !key:string, !value:any--[[ (el:Element) ]] },
	onSubmit:   struct { !key:string, !value:any--[[ (widget:Widget) ]] },
	onAction:   struct { !key:string, !value:any--[[ (widget:Widget, i:int) ]] },
	onDouble:   struct { !key:string, !value:any--[[ (widget:Widget, i:int) ]] },
	onOption:   struct { !key:string, !value:any--[[ (widget:Widget, i:int) ]] },
	onClose:    struct { !key:string, !value:any--[[ (widget:Widget, i:int) ]] },
	onDrag:     struct { !key:string, !value:any--[[ (widget:Widget, i:int, mx,my:int) ]] },
	onDraw:     struct { !key:string, !value:any--[[ (canvas:Canvas, cw,ch:int) ]] },

	buttons      :: (state:State, el:Buttons)      -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	canvas       :: (state:State, el:Canvas)       -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	checkbox     :: (state:State, el:Checkbox)     -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	color        :: (state:State, el:Color)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	colorPreview :: (state:State, el:ColorPreview) -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	direction    :: (state:State, el:Direction)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	frame        :: (state:State, el:Frame)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	hbox         :: (state:State, el:Hbox)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	inputText    :: (state:State, el:InputText)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	radio        :: (state:State, el:Radio)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	scrollable   :: (state:State, el:Scrollable)   -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	section      :: (state:State, el:Section)      -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	separator    :: (state:State, el:Separator)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	slider       :: (state:State, el:Slider)       -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	tabs         :: (state:State, el:Tabs)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	text         :: (state:State, el:Text)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	vbox         :: (state:State, el:Vbox)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
}

local register :: (state:State, el:Element, T:Type) -> Element {
	el.type = T
	el.id   = state.nextId

	state.elementsById[el.id] = el
	if el.name  state.elementsByName[el.name] = el

	if T == Scrollable  insert(state.scrollables, cast(Scrollable)el)

	state.nextId += 1
	return el
}

local unregisterTree :: (state:State, el:Element) {
	state.elementsById[el.id] = NULL
	if el.name  state.elementsByName[el.name] = NULL

	for el  unregisterTree(state, it)
}



export Style :: enum { NORMAL, CONTEXT_MENU, LIST }

export Element :: struct {
	active    = true,
	name      = "",
	label     = "",
	labelLeft = "",
	tooltip   = "",
	weight    = .0,
	inset     = 0,
	width     = 0, -- Zero means automatic.
	height    = 0, -- Zero means automatic. For scrollables, non-positive means distance from the bottom of the screen.
	minWidth  = 0,
	minHeight = 0,
	maxWidth  = -1, -- Negative means no limit.
	maxHeight = -1, -- Negative means no limit.
	style     = Style.NORMAL,
	data: any,

	type: Type = NULL,
	id:   int  = NULL,

	frame:  Frame   = NULL,
	parent: Element = NULL,
	!value: Element, -- Children.

	layoutX: int,
	layoutY: int,
	layoutHeight: int,
	layoutWidth:  int,
}

export Widget :: struct {
	using Element,
}



export Layout :: enum { DOCKED, FLOATING }

export Frame :: struct {
	using Element,

	layout = Layout.DOCKED,
	modal  = false,
	temp   = false,
	x      = -1, -- Negative means centered. Only used if floating.
	y      = -1, -- Negative means centered. Only used if floating.
}



export Scrollable :: struct {
	using Widget,

	-- ...

	contentHeight: int,

	scroll       = 0.0,
	scrollSource = 0.0,
	scrollTarget = 0,
}

export Section :: struct {
	using Element,
}

local Box :: struct {
	-- expandChildren = true,

	using Element,
}
export Hbox :: struct {
	using Box,
}
export Vbox :: struct {
	using Box,
}



export Text :: struct {
	using Element,

	text  = "",
	large = false,
}

export Separator :: struct {
	using Element,

	thick = false,
}



export Button :: struct {
	name    = "", -- Inherited from parent if empty.
	label   = "",
	suffix  = "", -- Appears faded after the label.
	image   = "",
	tooltip = "",
	value: any,
	draggable = false,
	system: System = NULL,

	imageScale = 1.0,

	labelWidth  = 0,
	suffixWidth = 0,
}

export Alignment :: enum { CENTER, LEFT, RIGHT }

export Buttons :: struct {
	using Widget,

	buttons: []Button,
	align           = Alignment.CENTER,
	vertical        = false,
	buttonMinHeight = 0,

	buttonWidth:  float, -- Round when necessary!
	buttonHeight: float, -- Round when necessary!
}

export Radio :: struct {
	using Buttons,

	index = 1,
}

export Tabs :: struct {
	using Radio,

	specialLastTab = false,
}



export Checkbox :: struct {
	using Widget,

	checked = false,
}



export Slider :: struct {
	using Widget,

	value = 0.0,
	min   = 0.0,
	max   = 1.0,
	steps = 16,
	linkMultiDrag: []string,

	readoutMulti = 1.0,
	readout      = "",
	readoutZero  = "",
}

export Color :: struct {
	using Widget,

	alpha = true,
	color: []float = {0,0,1,1}, -- {r,g,b,a}
	linkMultiDrag: []string,

	sliderWidth = 0.0, -- Round when necessary!
}



export ColorPreview :: struct {
	using Widget,

	linkColors: []string,
	blendMode = LG.BlendMode.ALPHA,
}



export Direction :: struct {
	using Widget,

	angle      = 0.0,
	linkOther  = "",
	linkSpread = "",
	linkMultiDrag: []string,
}



export InputText :: struct {
	using Widget,

	value = "",

	field: InputField = NULL,
}



export Canvas :: struct {
	using Widget,
}



export onKeyPressed :: (state:State, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (handled:bool) {
	-- Modifier keys while pressing a mouse button.
	if state.activeId {
		if key == "lctrl" or key == "rctrl" or key == "lshift" or key == "rshift" or key == "lalt" or key == "ralt" {
			local mx, my = LM.getPosition()
			onMouseMoved(state, mx, my, 0, 0)
		}
		return true
	}

	if key == "escape" and state.contextMenu ~= NULL {
		hideContextMenu(state)
		return true
	}

	-- Key events for inputs.
	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		if key == "escape" {
			blurFocus(state, abort=true)
		} elseif key == "return" or key == "kpenter" {
			blurFocus(state, abort=false)
			triggerSubmitEvent(state, input)
		} else {
			input.field.keypressed!(key, scancode, isRepeat)
		}
		return true
	}

	local widget = cast(Widget) state.elementsById[state.hoveredId]
	local mod    = getModifierKey()

	-- Key events for other widgets.
	if widget ~= NULL  if widget.type == {
		case Direction:
			local direction = cast(Direction) widget
			if (mod == ModifierKey.NONE or mod == ModifierKey.S or mod == ModifierKey.C) and (key == "left" or key == "right") {
				local delta     = math.TAU * ((mod == ModifierKey.S) ? 22.5/360 : (mod == ModifierKey.C) ? 1/360 : 5/360)
				direction.angle = ((key == "left" ? direction.angle-delta : direction.angle+delta) + math.PI) % math.TAU - math.PI
				triggerActionEvent(state, direction, "", 0, save=true)
				return true
			}

		case Slider:
			local slider = cast(Slider) widget
			if (mod == ModifierKey.NONE or mod == ModifierKey.S or mod == ModifierKey.C) and (key == "left" or key == "right") {
				local delta  = (slider.max-slider.min) / ((mod == ModifierKey.S) ? 16 : (mod == ModifierKey.C) ? 1024 : 128)
				slider.value = math.clamp((key == "left" ? slider.value-delta : slider.value+delta), slider.min, slider.max)
				triggerActionEvent(state, slider, "", 0, save=true)
				return true
			}

		case Color:
			local colorEl = cast(Color) widget
			if (mod == ModifierKey.NONE or mod == ModifierKey.S or mod == ModifierKey.C) and (key == "left" or key == "right") {
				local component          = state.hoveredSubid

				local delta
					= component == 1
					? ((mod == ModifierKey.S) ? 30  : (mod == ModifierKey.C) ? 1  : 6) / 360
					: ((mod == ModifierKey.S) ? 7.5 : (mod == ModifierKey.C) ? .5 : 2) / 100

				colorEl.color[component] = math.clamp01(key == "left" ? colorEl.color[component]-delta : colorEl.color[component]+delta)
				triggerActionEvent(state, colorEl, "", component, save=true)
				return true
			}
	}

	return false
}

export onKeyReleased :: (state:State, key:LK.KeyConstant, scancode:LK.Scancode) {
	if state.activeId and (key == "lctrl" or key == "rctrl" or key == "lshift" or key == "rshift" or key == "lalt" or key == "ralt") {
		local mx, my = LM.getPosition()
		onMouseMoved(state, mx, my, 0, 0)
	}
}

export onTextInput :: (state:State, text:string) -> (handled:bool) {
	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		input.field.textinput!(text)
		return true
	}

	return false
}

export onMousePressed :: (state:State, mx,my:int, mbutton:int, presses:int) -> (handled:bool) {
	updateLayoutIfNeeded(state)

	if state.focusId {
		if state.hoveredId == state.focusId {
			local input = cast(InputText) state.elementsById[state.focusId]
			input.field.mousepressed!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input)), mbutton, presses)
		} else {
			blurFocus(state, abort=false)
		}
	}

	for < state.frames  if isInsideElement(state, mx, my, it) {
		if (mbutton == 1 or mbutton == 2) and state.hoveredId and not state.focusId {
			local input = cast(InputText) state.elementsById[state.hoveredId]
			if input.type == InputText {
				setFocus(state, input)
				input.field.mousepressed!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input)), mbutton, presses)
			}
		}

		if mbutton == 1 and state.hoveredId {
			local el      = state.elementsById[state.hoveredId]
			local buttons = cast(Buttons) el

			if el.type == Buttons and (buttons.style == Style.CONTEXT_MENU or buttons.style == Style.LIST) {
				local handled = false
				if presses % 2 == 0 {
					handled = triggerDoublePressEvent(state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid, save=true)
				}
				if not handled {
					triggerActionEvent(state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid, save=true)
				}

			} else {
				state.activeId      = state.hoveredId
				state.activeSubid   = state.hoveredSubid
				state.activeMod     = getModifierKey()
				state.activeStartMx = mx
				state.activeStartMy = my

				LM.setGrabbed(true)
				LK.setKeyRepeat(false)

				if el.type == Scrollable {
					local scrollable           = cast(Scrollable) el
					local handlePos, handleLen = getScrollbarHandle(scrollable, visual=false)

					if my >= scrollable.layoutY+handlePos and my < scrollable.layoutY+handlePos+handleLen {
						state.scrollbarHandleDragOffset = - (my - scrollable.layoutY - handlePos)
					} else {
						state.scrollbarHandleDragOffset = - (handleLen // 2)
					}
				}

				onMouseMoved(state, mx, my, 0, 0)
			}
		}

		if it ~= state.contextMenu  hideContextMenu(state)
		return true
	}

	hideContextMenu(state)
	return state.activeId > 0 or getTopmostActiveModal(state) ~= NULL
}

export onMouseMoved :: (state:State, mx,my:int, dx,dy:int) {
	updateLayoutIfNeeded(state)

	local updateMouseCursor :: (state:State) {
		if state.hoveredId and (state.focusId == state.hoveredId or state.elementsById[state.hoveredId].type == InputText)
			LM.setCursor(LM.getSystemCursor(LM.CursorType.I_BEAM))
		else
			LM.setCursor()
	}

	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		if input.field.mousemoved!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input))) {
			updateMouseCursor(state)
			return
		}
	}

	-- Update hovered ID.
	local widget = cast(Widget) state.elementsById[state.activeId]
	if not (
		widget ~= NULL
		and (widget.type == Buttons or widget.type == Radio or widget.type == Tabs)
		and (cast(Buttons)widget).buttons[state.activeSubid].draggable
	) {
		local found, ^widget = getWidgetAt(state, mx, my)

		state.hoveredId    = 0
		state.hoveredSubid = 0

		if found {
			if not state.activeId or widget.id == state.activeId {
				state.hoveredId = widget.id
			}

			local hoveredSubid = 0

			if state.hoveredId  if widget.type == {
				case Tabs:  !through
				case Radio: !through
				case Buttons:
					local buttons = cast(Buttons) widget
					if buttons.vertical
						hoveredSubid = math.clamp(math.floor(1 + (my-buttons.layoutY-getScrollOffset(buttons)) / buttons.buttonHeight), 1, #buttons.buttons)
					else
						hoveredSubid = math.clamp(math.floor(1 + (mx-buttons.layoutX                         ) / buttons.buttonWidth ), 1, #buttons.buttons)

				case Color:
					local colorEl = cast(Color) widget
					local iFloat  = 1 + (my - (colorEl.layoutY + getScrollOffset(colorEl))) / SLIDER_MIN_WIDTH
					hoveredSubid  = math.clamp(math.floor(iFloat), 1, (colorEl.alpha ? 4 : 3))
			}

			if not state.activeId or hoveredSubid == state.activeSubid {
				state.hoveredSubid = hoveredSubid
			} else {
				state.hoveredId = 0
			}
		}
	}

	-- Drag active widget.
	widget = cast(Widget) state.elementsById[state.activeId]

	local mod = getModifierKey()

	if widget ~= NULL  if widget.type == {
		case Slider:
			local slider = cast(Slider) widget
			local x1     = slider.layoutX +                      SLIDER_MIN_WIDTH // 2
			local x2     = slider.layoutX + slider.layoutWidth - SLIDER_MIN_WIDTH // 2
			local value  = (mx-x1) / (x2-x1)

			if mod == ModifierKey.C or mod == ModifierKey.CS {
				value = math.round(value * slider.steps) / slider.steps
			}

			value = math.lerp(slider.min, slider.max, math.clamp01(value))

			if value ~= slider.value {
				slider.value = value
				triggerActionEvent(state, slider, "", 0)
			}

			if slider.linkMultiDrag and (state.activeMod == ModifierKey.S or state.activeMod == ModifierKey.CS) {
				for slider.linkMultiDrag {
					local other = cast(Slider) state.elementsByName[it]

					if other ~= NULL and other ~= slider and other.type == Slider and other.value ~= value and isElementVisible(other) {
						other.value = value
						triggerActionEvent(state, other, "", 0)
					}
				}
			}

		case Color:
			local colorEl   = cast(Color) widget
			local component = state.activeSubid
			local value     = (mx-colorEl.layoutX) / colorEl.layoutWidth

			if mod == ModifierKey.C or mod == ModifierKey.CS {
				local steps = component == 1 ? 24 : 16
				value       = math.round(value*steps)/steps
			}

			value = math.clamp01(value)

			if value ~= colorEl.color[component] {
				colorEl.color[component] = value
				triggerActionEvent(state, colorEl, "", component)
			}

			if colorEl.linkMultiDrag and (state.activeMod == ModifierKey.S or state.activeMod == ModifierKey.CS) {
				for colorEl.linkMultiDrag {
					local other = cast(Color) state.elementsByName[it]

					if other ~= NULL and other ~= colorEl and other.type == Color and other.color[component] ~= value and isElementVisible(other) {
						other.color[component] = value
						triggerActionEvent(state, other, "", component)
					}
				}
			}

		case Direction:
			local r :: DIRECTION_RADIUS
			local direction = cast(Direction) widget
			local angle     = math.atan(my - (direction.layoutY + getScrollOffset(direction) + r), mx - (direction.layoutX + r))

			if mod == ModifierKey.C or mod == ModifierKey.CS {
				local STEPS :: 16
				angle = math.round(angle * STEPS/math.TAU) / STEPS*math.TAU
			}

			if angle ~= direction.angle {
				direction.angle = angle
				triggerActionEvent(state, direction, "", 0)
			}

			if direction.linkMultiDrag and (state.activeMod == ModifierKey.S or state.activeMod == ModifierKey.CS) {
				for direction.linkMultiDrag {
					local other = cast(Direction) state.elementsByName[it]

					if other ~= NULL and other ~= direction and other.type == Direction and other.angle ~= angle and isElementVisible(other) {
						other.angle = angle
						triggerActionEvent(state, other, "", 0)
					}
				}
			}

		case Scrollable:
			local scrollable = cast(Scrollable) widget
			local handlePos, handleLen, handlePosMax = getScrollbarHandle(scrollable, visual=false)

			local visibleH = scrollable.layoutHeight
			local paddedH  = visibleH - 2*SPACING

			scrollable.scrollTarget = -math.round( ((my + state.scrollbarHandleDragOffset) - scrollable.layoutY) / handlePosMax * (scrollable.contentHeight-paddedH) )
			limitScroll(scrollable)
			scrollable.scroll = scrollable.scrollTarget

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) widget

			if buttons.buttons[state.activeSubid].draggable {
				if state.activeDragging {
					triggerDragEvent(state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid, mx, my)

				} elseif math.distance(mx,my, state.activeStartMx,state.activeStartMy) > DRAG_RADIUS {
					state.activeDragging = true
				}
			}
	}

	-- Update tooltip.
	state.currentTooltip = ""

	if state.hoveredId and not state.activeId {
		widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget.type == Buttons or widget.type == Radio or widget.type == Tabs {
			local buttons        = cast(Buttons) widget
			state.currentTooltip = buttons.buttons[state.hoveredSubid].tooltip

			if buttons.vertical {
				state.tooltipX  = buttons.layoutX
				state.tooltipY1 = math.round(buttons.layoutY + (state.hoveredSubid-1) * buttons.buttonHeight)
				state.tooltipY2 = math.round(buttons.layoutY + (state.hoveredSubid  ) * buttons.buttonHeight)
			} else {
				state.tooltipX  = math.round(buttons.layoutX + (state.hoveredSubid-1) * buttons.buttonWidth)
				state.tooltipY1 = buttons.layoutY
				state.tooltipY2 = buttons.layoutY + buttons.layoutHeight
			}
		}

		if not state.currentTooltip {
			state.currentTooltip = widget.tooltip
			state.tooltipX       = widget.layoutX
			state.tooltipY1      = widget.layoutY
			state.tooltipY2      = widget.layoutY + widget.layoutHeight
		}

		if state.currentTooltip {
			local offset     = getScrollOffset(widget)
			state.tooltipY1 += offset
			state.tooltipY2 += offset
		}
	}

	if not state.currentTooltip {
		state.tooltipTime = 0
	} else {
		if state.tooltipTime == 0  state.tooltipTime = LT.getTime()
	}

	updateMouseCursor(state)
}

export onMouseReleased :: (state:State, mx,my:int, mbutton:int, presses:int) {
	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		if input.field.mousereleased!(mx, my, mbutton)
			onMouseMoved(state, mx, my, 0, 0)
	}

	-- LMB.
	if mbutton == 1 and state.activeId {
		local widget = cast(Widget) state.elementsById[state.activeId]

		if widget ~= NULL  if widget.type == {
			case Buttons:
				if state.hoveredId and not state.activeDragging {
					local buttons = cast(Buttons) widget
					triggerActionEvent(state, buttons, buttons.buttons[state.activeSubid].name, state.activeSubid, save=true)
				}

			case Radio:
				if state.hoveredId and not state.activeDragging {
					local radio = cast(Radio) widget

					if radio.index ~= state.hoveredSubid {
						radio.index = state.hoveredSubid
						triggerActionEvent(state, radio, radio.buttons[state.activeSubid].name, state.activeSubid, save=true)
					}
				}

			case Tabs:
				if state.hoveredId and not state.activeDragging {
					local tabs = cast(Tabs) widget

					if tabs.specialLastTab and state.hoveredSubid == #tabs.buttons {
						triggerActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, save=true)
					} elseif tabs.index ~= state.hoveredSubid {
						tabs.index = state.hoveredSubid
						triggerActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, save=true)
					}
				}

			case Checkbox:
				if state.hoveredId {
					local checkbox   = cast(Checkbox) widget
					checkbox.checked = not checkbox.checked

					triggerActionEvent(state, checkbox, "", 0, save=true)
				}

			case Slider: !through
			case Color:  !through
			case Direction:
				scheduleSaveWorkspace()
		}
	}

	-- MMB.
	if mbutton == 3 and not state.activeId and state.hoveredId {
		local widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget ~= NULL  if widget.type == {
			case Tabs:
				local tabs = cast(Tabs) widget

				if not (tabs.specialLastTab and state.hoveredSubid == #tabs.buttons) {
					triggerCloseEvent(state, tabs, tabs.buttons[state.hoveredSubid].name, state.hoveredSubid, save=true)
				}
		}
	}

	-- RMB.
	if mbutton == 2 and not state.activeId and state.hoveredId {
		local widget = cast(Widget) state.elementsById[state.hoveredId]
		local name   = ""

		if widget.type == {
			case Tabs:  !through
			case Radio: !through
			case Buttons: name = (cast(Buttons)widget).buttons[state.hoveredSubid].name
		}

		if widget ~= NULL and not triggerOptionEvent(state, widget, name, state.hoveredSubid) {
			if widget.type == {
				case Direction:
					local direction = cast(Direction) widget

					showContextMenu(guiState, {"Copy angle","Paste angle"}, [state,direction] (i:int) {
						if i == {
							case 1:
								clipboardAngle    = direction.angle
								hasClipboardAngle = true
							case 2:
								if hasClipboardAngle {
									direction.angle = clipboardAngle
									triggerActionEvent(state, direction, "", 0)
								}
						}
					})

				case Slider:
					local slider = cast(Slider) widget

					showContextMenu(guiState, {"Copy value","Paste value"}, [state,slider] (i:int) {
						if i == {
							case 1:
								clipboardScalar    = slider.value
								hasClipboardScalar = true
							case 2:
								if hasClipboardScalar {
									slider.value = clipboardScalar
									triggerActionEvent(state, slider, "", 0)
								}
						}
					})

				case Color:
					local COMPONENT_TITLES: Table(int, string) : {
						[1] = "hue",
						[2] = "saturation",
						[3] = "value strength",
						[4] = "opacity",
					}

					local colorEl   = cast(Color) widget
					local component = state.hoveredSubid

					local items = {
						"Copy "..COMPONENT_TITLES[component],
						"Copy color",
						"Paste "..COMPONENT_TITLES[component],
						"Paste color",
					}

					showContextMenu(guiState, items, [state,colorEl,component] (i:int) {
						if i == {
							case 1:
								clipboardScalar    = colorEl.color[component]
								hasClipboardScalar = true
							case 2:
								for 1, 4  clipboardColor[it] = colorEl.color[it]
								hasClipboardColor = true
							case 3:
								if hasClipboardScalar {
									colorEl.color[component] = clipboardScalar
									triggerActionEvent(state, colorEl, "", component)
								}
							case 4:
								if hasClipboardColor  for 1, 4 {
									colorEl.color[it] = clipboardColor[it]
									triggerActionEvent(state, colorEl, "", it)
								}
						}
					})
			}
		}
	}

	-- Release active ID.
	if state.activeId and mbutton == 1 {
		if state.activeDragging  scheduleSaveWorkspace()

		state.activeId       = 0
		state.activeSubid    = 0
		state.activeDragging = false

		LM.setGrabbed(false)
		LK.setKeyRepeat(true)

		onMouseMoved(state, mx, my, 0, 0)
	}
}

export onMouseWheel :: (state:State, dx,dy:int) -> (handled:bool) {
	if state.activeId  return true
	if getModifierKey() ~= ModifierKey.NONE  return false

	updateLayoutIfNeeded(state)

	local mx, my = LM.getPosition()

	local found, el = getElementAt(state, mx, my)
	while not (el == NULL or el.type == Scrollable) {
		el = el.parent
	}

	if el ~= NULL {
		local scrollable        = cast(Scrollable) el
		scrollable.scrollSource = scrollable.scroll
		scrollable.scrollTarget = scrollable.scrollTarget + 50*dy
		limitScroll(scrollable)
		return true
	}

	return false
}



local calculateNaturalSize :: (state:State, el:Element) {
	for el  if it.active {
		calculateNaturalSize(state, it)
	}

	if el.type == {
		case Frame:
			local frame    = cast(Frame) el
			local contentW = 0
			local contentH = 0

			for frame  if it.active {
				contentW  = math.max(contentW, it.layoutWidth)
				contentH += it.layoutHeight + SPACING
			}

			frame.layoutWidth  = contentW + 2*SPACING
			frame.layoutHeight = contentH + SPACING

		case Scrollable:
			local scrollable = cast(Scrollable) el
			local contentH   = 0

			for scrollable  if it.active {
				contentH += it.layoutHeight + SPACING
			}

			scrollable.layoutWidth   = SCROLLBAR_WIDTH
			scrollable.contentHeight = contentH - SPACING + 2*SCROLLABLE_PADDING

			if scrollable.height > 0 {
				scrollable.layoutHeight = scrollable.height
			} else {
				scrollable.layoutHeight     = math.max(state.extraScrollableSpace + scrollable.height, 0)
				state.extraScrollableSpace -= scrollable.layoutHeight
			}

		case Section:
			local section  = cast(Section) el
			local contentW = 0
			local contentH = 0

			for section  if it.active {
				contentW  = math.max(contentW, it.layoutWidth)
				contentH += it.layoutHeight + SPACING
			}

			section.layoutWidth  = SECTION_LABEL_WIDTH + contentW
			section.layoutHeight = contentH - SPACING

		case Hbox:
			local hbox     = cast(Hbox) el
			local contentW = 0
			local contentH = 0

			for hbox  if it.active {
				contentW += it.layoutWidth + SPACING
				contentH  = math.max(contentH, it.layoutHeight)
			}

			hbox.layoutWidth  = contentW - SPACING
			hbox.layoutHeight = contentH

		case Vbox:
			local vbox     = cast(Vbox) el
			local contentW = 0
			local contentH = 0

			for vbox  if it.active {
				contentW  = math.max(contentW, it.layoutWidth)
				contentH += it.layoutHeight + SPACING
			}

			vbox.layoutWidth  = contentW
			vbox.layoutHeight = contentH - SPACING

		case Text:
			local textEl        = cast(Text) el
			local font          = textEl.large ? fontLarge : fontNormal
			textEl.layoutWidth  = font.getWidth!(textEl.text)
			textEl.layoutHeight = font.getHeight!()

		case Separator:
			local separator        = cast(Separator) el
			separator.layoutWidth  = 0
			separator.layoutHeight = separator.thick ? 5 : 1

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons    = cast(Buttons) el
			local buttonMaxW = 0
			local buttonMaxH = buttons.buttonMinHeight

			for buttons.buttons {
				local w: int = NULL
				local h: int = NULL

				it.labelWidth  = fontNormal.getWidth!(it.label)
				it.suffixWidth = fontNormal.getWidth!(it.suffix)

				if it.system ~= NULL {
					w             = BUTTON_IMAGE_MAX_SIZE
					h             = BUTTON_IMAGE_MAX_SIZE
				} elseif (it.label or it.suffix) and it.image {
					w, h          = guiImages[it.image].getDimensions!()
					it.imageScale = math.min(BUTTON_IMAGE_MAX_SIZE/w, BUTTON_IMAGE_MAX_SIZE/h, 1)
					w             = math.round(w*it.imageScale) + SPACING + it.labelWidth+it.suffixWidth
					h             = math.max(math.round(h*it.imageScale), fontNormal.getHeight!())
				} elseif it.image {
					w, h          = guiImages[it.image].getDimensions!()
					it.imageScale = math.min(BUTTON_IMAGE_MAX_SIZE/w, BUTTON_IMAGE_MAX_SIZE/h, 1)
					w             = math.round(w*it.imageScale)
					h             = math.round(h*it.imageScale)
				} else {
					w             = it.labelWidth + it.suffixWidth
					h             = fontNormal.getHeight!()
				}

				buttonMaxW = math.max(buttonMaxW, w)
				buttonMaxH = math.max(buttonMaxH, h)
			}

			if buttons.vertical {
				buttons.layoutWidth  = buttonMaxW + 2*SPACING
				buttons.layoutHeight = #buttons.buttons * (buttonMaxH + 2*BUTTON_PADDING_Y)
			} else {
				buttons.layoutWidth  = #buttons.buttons * (buttonMaxW + 2*SPACING)
				buttons.layoutHeight = buttonMaxH + 2*BUTTON_PADDING_Y
			}

		case Checkbox:
			local checkbox        = cast(Checkbox) el
			checkbox.layoutWidth  = CHECKBOX_SIZE + SPACING + fontSmall.getWidth!(checkbox.label) + SPACING_LARGE
			checkbox.layoutHeight = math.max(CHECKBOX_SIZE, fontSmall.getHeight!())

		case InputText:
			local input = cast(InputText) el
			input.layoutWidth  = INPUT_MIN_WIDTH
			input.layoutHeight = fontNormal.getHeight!() + 2*SPACING

		case Slider:
			local slider        = cast(Slider) el
			slider.layoutWidth  = SLIDER_MIN_LENGTH
			slider.layoutHeight = SLIDER_MIN_WIDTH

		case Color:
			local colorEl        = cast(Color) el
			colorEl.layoutWidth  = SLIDER_MIN_LENGTH
			colorEl.layoutHeight = (colorEl.alpha ? 4 : 3) * SLIDER_MIN_WIDTH

		case ColorPreview:
			local preview        = cast(ColorPreview) el
			preview.layoutWidth  = COLOR_PREVIEW_WIDTH
			preview.layoutHeight = 0

		case Direction:
			local direction        = cast(Direction) el
			direction.layoutWidth  = 2*DIRECTION_RADIUS
			direction.layoutHeight = 2*DIRECTION_RADIUS

		case Canvas:
			local canvasEl        = cast(Canvas) el
			canvasEl.layoutWidth  = 10
			canvasEl.layoutHeight = 10

		case: errorf("%d", el.type)
	}

	if el.width                             el.layoutWidth  = el.width
	if el.height and el.type ~= Scrollable  el.layoutHeight = el.height

	el.layoutWidth  = math.max(el.layoutWidth,  el.minWidth)
	el.layoutHeight = math.max(el.layoutHeight, el.minHeight)
	if el.maxWidth  >= 0  el.layoutWidth  = math.min(el.layoutWidth,  el.maxWidth)
	if el.maxHeight >= 0  el.layoutHeight = math.min(el.layoutHeight, el.maxHeight)

	-- The following count as outside the element, even though they take space as if they were part of the element.
	-- el.layoutWidth += el.inset
	if el.type == Tabs  el.layoutHeight += TAB_BOTTOM_LINE_WIDTH
}

local positionAndFit :: (state:State, el:Element, x,y,w,h:int) {
	local positionAndFitChildrenV :: (state:State, el:Element, x,y,w,h:int) {
		for el  if it.active {
			positionAndFit(state, it, x+it.inset, y, w-it.inset, it.layoutHeight)
			y += it.layoutHeight + SPACING
		}
	}
	local positionAndFitChildrenH :: (state:State, el:Element, x,y,w,h:int) {
		for el  if it.active {
			x += it.inset
			positionAndFit(state, it, x, y, it.layoutWidth, h)
			x += it.layoutWidth + SPACING
		}
	}

	-- x += el.inset
	-- w -= el.inset
	if el.type == Tabs  h -= TAB_BOTTOM_LINE_WIDTH

	el.layoutX      = x
	el.layoutY      = y
	el.layoutWidth  = w
	el.layoutHeight = h

	if el.type == {
		case Frame:
			local frame = cast(Frame) el

			if !complete frame.layout == {
				case Layout.DOCKED:
					x = 0
					y = 0
				case Layout.FLOATING:
					x = frame.x >= 0 ? frame.x : (LG.getWidth()  - w) // 2
					y = frame.y >= 0 ? frame.y : (LG.getHeight() - h) // 2
			}

			frame.layoutX = x
			frame.layoutY = y

			x += SPACING
			y += SPACING
			w -= 2*SPACING

			positionAndFitChildrenV(state, frame, x, y, w, h)

		case Scrollable:
			local scrollable = cast(Scrollable) el

			y += SPACING + SCROLLABLE_PADDING
			w -= SCROLLBAR_WIDTH + SPACING

			positionAndFitChildrenV(state, scrollable, x, y, w, h)

		case Section:
			local section = cast(Section) el

			x += SECTION_LABEL_WIDTH
			w -= SECTION_LABEL_WIDTH

			positionAndFitChildrenV(state, section, x, y, w, h)

		case Hbox:
			local hbox         = cast(Hbox) el
			local dynamicSpace = w
			local weight       = .0
			local activeCount  = 0

			for hbox  if it.active {
				activeCount  += 1
				dynamicSpace -= it.inset

				if it.weight {
					weight += it.weight
				} else {
					dynamicSpace -= it.layoutWidth
				}
			}

			if weight {
				dynamicSpace -= (activeCount-1) * SPACING

				for hbox  if it.active and it.weight {
					it.layoutWidth  = math.max(math.round(dynamicSpace * it.weight / weight), 1)
					dynamicSpace   -= it.layoutWidth
					weight         -= it.weight
				}
			}

			positionAndFitChildrenH(state, hbox, x, y, w, h)

		case Vbox:
			local vbox         = cast(Vbox) el
			local dynamicSpace = h
			local weight       = .0
			local activeCount  = 0

			for vbox  if it.active {
				activeCount += 1
				if it.weight
					weight += it.weight
				else
					dynamicSpace -= it.layoutHeight
			}

			if weight {
				dynamicSpace -= (activeCount-1) * SPACING

				for vbox  if it.active and it.weight {
					it.layoutHeight  = math.round(dynamicSpace * it.weight / weight)
					dynamicSpace    -= it.layoutHeight
					weight          -= it.weight
				}
			}

			positionAndFitChildrenV(state, vbox, x, y, w, h)

		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) el
			if buttons.vertical {
				buttons.buttonWidth  = w
				buttons.buttonHeight = h / #buttons.buttons
			} else {
				buttons.buttonWidth  = w / #buttons.buttons
				buttons.buttonHeight = h
			}

		case Tabs:
			local tabs = cast(Tabs) el
			tabs.buttonWidth
				= tabs.specialLastTab
				? (w-SPECIAL_TAB_WIDTH) / (#tabs.buttons-1)
				: (w                  ) / (#tabs.buttons  )

		case Color:
			local colorEl       = cast(Color) el
			colorEl.sliderWidth = h / (colorEl.alpha ? 4 : 3)

		case InputText:
			local input = cast(InputText) el
			if input.field ~= NULL  input.field.setWidth!(w)
	}
}

local updateLayoutIfNeeded :: (state:State) {
	if not state.layoutNeedsUpdate  return
	state.layoutNeedsUpdate = false

	-- print("Updating layout.")

	local updateParents :: (el:Element, frame:Frame, parent:Element) {
		el.frame  = frame
		el.parent = parent
		for el  updateParents(it, frame, el)
	}
	for state.frames  updateParents(it, it, NULL)

	for state.frames  if it.active {
		state.extraScrollableSpace = 0
		calculateNaturalSize(state, it)

		-- We need to do calculateNaturalSize() twice to know how much scrollables can expand the frame.
		-- Note: If there are multiple scrollables with height<=0 then things may or may not work as expected!
		state.extraScrollableSpace = LG.getHeight() - (it.layoutY + it.layoutHeight) -- layoutNeedsUpdate better be set if the window resizes!
		calculateNaturalSize(state, it)

		positionAndFit(state, it, 0, 0, it.layoutWidth, it.layoutHeight)
	}

	for state.scrollables  limitScroll(it)

	local mx, my = LM.getPosition()
	if isOverGui(state, mx, my)  onMouseMoved(state, mx, my, 0, 0)
}



local update :: (state:State, dt:float) {
	local anyScrolling = false

	for state.scrollables {
		local targetReached: bool = NULL

		it.scroll, targetReached = math.moveTowards(
			it.scroll,
			it.scrollTarget,
			math.abs(it.scrollTarget - it.scrollSource) * dt / 0.05
		)
		if not targetReached  anyScrolling = true
	}

	if anyScrolling {
		local mx, my = LM.getPosition()
		onMouseMoved(state, mx, my, 0, 0)
	}

	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		input.field.update!(dt)
	}

}



local drawElement :: (state:State, el:Element) {
	local drawChildren :: (state:State, el:Element) {
		for el {
			if it.active  drawElement(state, it)
		}
	}

	if el.labelLeft {
		LG.setFont(fontSmall)
		LG.setColor(1, 1, 1)
		LG.print(
			el.labelLeft,
			el.layoutX - SPACING - fontSmall.getWidth!(el.labelLeft),
			el.layoutY + (el.layoutHeight - fontSmall.getHeight!()) // 2
		)
		LG.setFont(fontNormal)
	}

	if el.type == {
		case Frame:
			local frame = cast(Frame) el

			local x = frame.layoutX
			local y = frame.layoutY
			local w = frame.layoutWidth
			local h = frame.layoutHeight

			if frame.layout == Layout.FLOATING and frame.modal {
				local BORDER :: 10
				LG.setColor(.1, .1, .1, .9)
				LG.rectangle(LG.DrawMode.FILL, x-BORDER, y-BORDER, w+2*BORDER, h+2*BORDER, SPACING+BUTTON_RADIUS+BORDER)
			}

			if frame.style == Style.CONTEXT_MENU
				LG.setColor(.7, .7, .7)
			else
				LG.setColor(.2, .2, .2)

			if frame.style == Style.CONTEXT_MENU
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
			elseif frame.layout == Layout.FLOATING
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h, SPACING+BUTTON_RADIUS)
			else
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h)

			if frame.style == Style.CONTEXT_MENU {
				LG.setColor(.1, .1, .1)
				LG.rectangle(LG.DrawMode.LINE, x+.5, y+.5, w-1, h-1)
			}

			LG.pushAll()
			intersectScissor(x, y, w, h)
			drawChildren(state, frame)
			LG.pop()

		case Scrollable:
			local scrollable = cast(Scrollable) el

			local x = scrollable.layoutX
			local y = scrollable.layoutY
			local w = scrollable.layoutWidth
			local h = scrollable.layoutHeight

			LG.pushAll()
			LG.translate(0, scrollable.scroll)
			intersectScissor(x-SPACING, y, w+SPACING, h)
			drawChildren(state, scrollable)
			LG.pop()

			-- Shadow.
			do {
				local shadowH = scrollable.scroll ? 30 : 10
				local iw, ih  = imageGradient.getDimensions!()
				local sx      = shadowH / ih
				local sy      = (w + SPACING - SCROLLBAR_WIDTH) / iw

				LG.setColor(0, 0, 0, (scrollable.scroll ? 1 : .3))
				LG.draw(imageGradient, x-SPACING, y+shadowH, -math.TAU/4, sx, sy)
			}

			-- Scrollbar.
			do {
				local handlePos, handleLen, handlePosMax = getScrollbarHandle(scrollable, visual=true)

				local barX = x + w - SCROLLBAR_WIDTH
				local barY = y + handlePos

				LG.setColor(0, 0, 0, .3)
				LG.rectangle(LG.DrawMode.FILL, barX, y, SCROLLBAR_WIDTH, h)

				if scrollable.id == state.activeId
					LG.setColor(1, 1, 1, .30)
				elseif scrollable.id == state.hoveredId
					LG.setColor(1, 1, 1, .45)
				else
					LG.setColor(1, 1, 1, .15)

				LG.rectangle(LG.DrawMode.FILL, barX+1, barY+1, SCROLLBAR_WIDTH-2, handleLen-2, SCROLLBAR_WIDTH//2-1)
			}

		case Section:
			local section = cast(Section) el

			if section.label {
				LG.setColor(1, 1, 1)
				LG.print(section.label, section.layoutX, section.layoutY)
			}

			drawChildren(state, section)

		case Hbox:
			local hbox = cast(Hbox) el
			drawChildren(state, hbox)

		case Vbox:
			local vbox = cast(Vbox) el
			drawChildren(state, vbox)

		case Text:
			local textEl = cast(Text) el
			LG.setFont(textEl.large ? fontLarge : fontNormal)
			LG.setColor(1, 1, 1)
			LG.print(textEl.text, textEl.layoutX, textEl.layoutY)
			LG.setFont(fontNormal)

		case Separator:
			local separator = cast(Separator) el
			LG.setColor(0, 0, 0, (separator.thick ? .3 : .2))
			LG.rectangle(LG.DrawMode.FILL, separator.layoutX-SPACING, separator.layoutY, separator.layoutWidth+2*SPACING, separator.layoutHeight)

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) el
			local radio   = cast(Radio)   el
			local tabs    = cast(Tabs)    el

			local isRadio = el.type == Radio
			local isTabs  = el.type == Tabs

			local x = buttons.layoutX
			local y = buttons.layoutY
			local w = buttons.layoutWidth
			local h = buttons.layoutHeight

			local paddingX = isTabs ? 9 : SPACING

			local bx1:   []int : {}
			local bx2:   []int : {}
			local by1:   []int : {}
			local by2:   []int : {}
			local bw:    []int : {}
			local bh:    []int : {}
			local faded: []bool : {}

			-- Backgrounds.
			for buttons.buttons {
				if buttons.vertical {
					bx1[itIndex] = x
					bx2[itIndex] = x + w
					by1[itIndex] = math.round(y + buttons.buttonHeight*(itIndex-1))
					by2[itIndex] = math.round(y + buttons.buttonHeight*(itIndex  ))
					by2[itIndex] = math.min(by2[itIndex], y + h)
				} else {
					bx1[itIndex] = math.round(x + buttons.buttonWidth*(itIndex-1))
					bx2[itIndex] = math.round(x + buttons.buttonWidth*(itIndex  ))
					bx2[itIndex] = math.min(bx2[itIndex], x + w)
					by1[itIndex] = y
					by2[itIndex] = y + h
				}
				bw[itIndex]    = bx2[itIndex] - bx1[itIndex]
				bh[itIndex]    = by2[itIndex] - by1[itIndex]
				faded[itIndex] = false

				local showBg = true

				if not (buttons.id == state.hoveredId and itIndex == state.hoveredSubid) {
					faded[itIndex] = (isRadio or isTabs) and radio.index ~= itIndex
					if buttons.style ~= Style.NORMAL
						showBg = false
					elseif faded[itIndex]
						LG.setColor(1, 1, 1, .1)
					else
						LG.setColor(1, 1, 1, .3)
				} elseif not (buttons.id == state.activeId and itIndex == state.activeSubid) {
					LG.setColor(1, 1, 1, .45)
				} else {
					LG.setColor(0, 0, 0, .5)
				}

				if not showBg {
					-- void
				} elseif isTabs {
					local topInset = math.min(.5*bh[itIndex], bw[itIndex]/4)
					LG.polygon(LG.DrawMode.FILL,
						bx1[itIndex],          by2[itIndex],
						bx1[itIndex]+topInset, by1[itIndex],
						bx2[itIndex]-topInset, by1[itIndex],
						bx2[itIndex],          by2[itIndex]
					)
				} else {
					LG.rectangle(LG.DrawMode.FILL, bx1[itIndex]+1, by1[itIndex]+1, bw[itIndex]-2, bh[itIndex]-2, BUTTON_RADIUS)
				}
			}

			-- Tab bottom line.
			if isTabs {
				LG.setColor(1, 1, 1, .3)
				LG.rectangle(LG.DrawMode.FILL, tabs.frame.layoutX, y+h, tabs.frame.layoutWidth, TAB_BOTTOM_LINE_WIDTH) -- Assume we haven't translated on the x axis.
				-- LG.rectangle(LG.DrawMode.FILL, x-SPACING, y+h, w+2*SPACING, TAB_BOTTOM_LINE_WIDTH)
			}

			-- Images.
			LG.setColor(1, 1, 1)

			for buttons.buttons  if it.image {
				local image  = guiImages[it.image]
				local iw, ih = image.getDimensions!()

				if it.label or it.suffix {
					LG.draw(image,
						bx1[itIndex] + paddingX,
						by1[itIndex] + bh[itIndex] // 2,
						0, it.imageScale, it.imageScale, 0, ih/2
					)
				} else {
					LG.draw(image,
						bx1[itIndex] + bw[itIndex] // 2,
						by1[itIndex] + bh[itIndex] // 2,
						0, it.imageScale, it.imageScale, iw/2, ih/2
					)
				}
			}

			-- Particle previews.
			-- @Cleanup: All this is a bit misplaced in the GUI. Maybe provide an onDraw event for elements so systems and projects can stay outside this file. (Update: We now have gui.Canvas!)
			local PREVIEW_SCALE :: 2.5
			local project = app.projects[app.currentProjectIndex]
			local scale   = PREVIEW_SCALE * BUTTON_IMAGE_MAX_SIZE / math.min(LG.getWidth() - MAIN_PANEL_WIDTH, LG.getHeight()) * project.zoom
			local r, g, b = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)

			LG.setColor(1, 1, 1)

			for buttons.buttons  if it.system ~= NULL and it.system.visible {
				local system = it.system
				local emitterX, emitterY: float

				if project.movementPreset == Movement.NONE {
					emitterX, emitterY = system.particles.getPosition!()
				}

				LG.pushAll()
				intersectScissor(
					bx1[itIndex] + (bw[itIndex] - BUTTON_IMAGE_MAX_SIZE) // 2,
					by1[itIndex] + (bh[itIndex] - BUTTON_IMAGE_MAX_SIZE) // 2 + getScrollOffset(buttons),
					BUTTON_IMAGE_MAX_SIZE,
					BUTTON_IMAGE_MAX_SIZE
				)

				LG.clear(r, g, b)
				LG.setBlendMode(system.blendMode)

				LG.draw(system.particles,
					bx1[itIndex] + bw[itIndex]/2 - emitterX*scale,
					by1[itIndex] + bh[itIndex]/2 - emitterY*scale,
					0, scale
				)

				LG.pop()
			}

			-- Labels.
			for buttons.buttons  if it.label or it.suffix {
				local scissorX1 = bx1[itIndex] + (paddingX-1)
				local scissorX2 = bx2[itIndex] - (paddingX-1)

				if scissorX2 > scissorX1 {
					local textY = by1[itIndex] + (bh[itIndex] - fontNormal.getHeight!()) // 2
					local textX: int = NULL

					if it.image {
						local iw = guiImages[it.image].getWidth!()
						textX    = math.ceil(bx1[itIndex] + paddingX + iw*it.imageScale + SPACING)
					} else {
						using Alignment
						if buttons.align == {
							case LEFT:   textX = bx1[itIndex] + paddingX
							case RIGHT:  textX = bx1[itIndex] + math.max(math.round(bw[itIndex] - paddingX - (it.labelWidth+it.suffixWidth)), paddingX)
							case CENTER: textX = bx1[itIndex] + math.max((bw[itIndex] - (it.labelWidth+it.suffixWidth)) // 2,                 paddingX)
						}
					}

					local grey, a: float
					if faded[itIndex]
						grey, a = 1, .8
					elseif buttons.style == Style.CONTEXT_MENU
						grey, a = 0, 1
					else
						grey, a = 1, 1

					LG.pushAll()
					intersectScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
					if it.label {
						LG.setColor(grey, grey, grey, a)
						LG.print(it.label, textX, textY)
					}
					if it.suffix {
						LG.setColor(grey, grey, grey, a*.6)
						LG.print(it.suffix, textX+it.labelWidth, textY)
					}
					LG.pop()
				}
			}

		case Checkbox:
			local checkbox = cast(Checkbox) el
			local y        = checkbox.layoutY + checkbox.layoutHeight // 2

			if checkbox.id ~= state.hoveredId {
				if checkbox.checked
					LG.setColor(1, 1, 1, .35)
				else
					LG.setColor(1, 1, 1, .25)
			} elseif checkbox.id ~= state.activeId {
				LG.setColor(1, 1, 1, .55)
			} else {
				LG.setColor(1, 1, 1, .45)
			}

			if checkbox.checked {
				LG.rectangle(LG.DrawMode.LINE, checkbox.layoutX+.5, y-CHECKBOX_SIZE//2+.5, CHECKBOX_SIZE-1, CHECKBOX_SIZE-1)
				LG.rectangle(LG.DrawMode.FILL, checkbox.layoutX+2,  y-CHECKBOX_SIZE//2+2,  CHECKBOX_SIZE-4, CHECKBOX_SIZE-4)
			} else {
				LG.rectangle(LG.DrawMode.LINE, checkbox.layoutX+.5, y-CHECKBOX_SIZE//2+.5, CHECKBOX_SIZE-1, CHECKBOX_SIZE-1)
			}

			LG.setFont(fontSmall)
			LG.setColor(1, 1, 1)
			LG.print(checkbox.label, checkbox.layoutX+CHECKBOX_SIZE+SPACING, y-fontSmall.getHeight!()//2)
			LG.setFont(fontNormal)

		case InputText:
			local input = cast(InputText) el
			local field = input.field

			local focused = (input.id == state.focusId)

			local x = input.layoutX
			local y = input.layoutY
			local w = input.layoutWidth
			local h = input.layoutHeight

			local valueX = x + SPACING

			-- Background.
			LG.setColor(0, 0, 0, .5)
			LG.rectangle(LG.DrawMode.FILL, x, y, w, h, BUTTON_RADIUS)

			LG.pushAll()
			intersectScissor(x, 0, w, LG.getHeight())

			-- Selection.
			if focused {
				local x1, x2 = field.getSelectionOffset!()
				if x2 > x1 {
					LG.setColor(1, 1, 0, .5)
					LG.rectangle(LG.DrawMode.FILL, valueX+x1, y, x2-x1, h)
				}
				LG.setColor(1, 1, 1, math.lerp(.1, .9, math.cos01(field.getBlinkPhase!()*math.TAU/1.00)))
				LG.rectangle(LG.DrawMode.FILL, valueX+field.getCursorOffset!(), y, 1, h)
			}

			-- Value.
			local textOffset = focused ? field.getTextOffset!() : 0
			local text       = focused ? field.getText!() : input.value
			LG.setColor(1, 1, 1)
			LG.print(text, valueX+textOffset, y+SPACING)

			-- Cursor.
			if focused {
				LG.setColor(1, 1, 1, math.lerp(.1, .9, math.cos01(field.getBlinkPhase!()*math.TAU/1.00)))
				LG.rectangle(LG.DrawMode.FILL, valueX+field.getCursorOffset!(), y, 1, h)
			}

			LG.pop()

			-- Hover/focus effect.
			if input.id == state.hoveredId or focused {
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
				LG.rectangle(LG.DrawMode.LINE, x-.5, y-.5, w+1, h+1, BUTTON_RADIUS)
			}

		case Slider:
			local slider  = cast(Slider) el
			local x1      = slider.layoutX +                      SLIDER_MIN_WIDTH // 2
			local x2      = slider.layoutX + slider.layoutWidth - SLIDER_MIN_WIDTH // 2
			local w       = x2-x1
			local value01 = (slider.value-slider.min) / (slider.max-slider.min)
			local handleX = x1 + math.round(value01 * w)
			local y       = slider.layoutY + slider.layoutHeight // 2

			local highlight = shouldHighlight(state, slider)

			-- Line/background.
			LG.setColor(1, 1, 1, (highlight ? .2 : .1))
			LG.rectangle(LG.DrawMode.FILL, x1, y-1, w, 2)

			-- Guides.
			LG.setColor(1, 1, 1, .1)
			LG.rectangle(LG.DrawMode.FILL, x1, y-3, +1, 6)
			LG.rectangle(LG.DrawMode.FILL, x2, y-3, -1, 6)
			if w >= 50 {
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+1/4*w), y-3, 1, 6)
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+2/4*w), y-3, 1, 6)
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+3/4*w), y-3, 1, 6)
				if w >= 200 {
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+1/8*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+3/8*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+5/8*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+7/8*w), y-1, 1, 2)
				}
			}

			-- Handle.
			local grey = (highlight ? .8 : .65)
			LG.setColor(grey, grey, grey)
			LG.rectangle(LG.DrawMode.FILL, handleX-1, y-SLIDER_MIN_WIDTH/2, 2, SLIDER_MIN_WIDTH)
			-- LG.circle(LG.DrawMode.FILL, handleX, y, 3, 16)

			-- Readout.
			if app.showPanelNumbers {
				local COLOR_TEXT:   love.Color: {1,1,1,.8}
				local COLOR_SHADOW: love.Color: {0,0,0,.5}
				drawSliderReadout(x2, y-SLIDER_MIN_WIDTH//2, SLIDER_MIN_WIDTH, handleX, slider.value, slider.readoutMulti, slider.readout, slider.readoutZero, COLOR_TEXT, COLOR_SHADOW)
			}

		case Color:
			local drawSliderValue :: (sliderX,sliderY:int, sliderW,sliderH:int, value:float, readout:float, readoutFormat:string, highlight:bool) {
				local x = math.round(sliderX + value*(sliderW-4))
				local a = (highlight ? .9 : .7)

				if app.showPanelNumbers {
					local COLOR_TEXT:   love.Color: {1,1,1,1}
					local COLOR_SHADOW: love.Color: {0,0,0,1}
					drawSliderReadout(sliderX+sliderW, sliderY, sliderH, x, readout, 1, readoutFormat, "", COLOR_TEXT, COLOR_SHADOW)
				}

				LG.setColor(0, 0, 0, a)
				LG.rectangle(LG.DrawMode.FILL, x, sliderY, 4, sliderH)

				LG.setColor(1, 1, 1, a)
				LG.rectangle(LG.DrawMode.FILL, x+1, sliderY, 2, sliderH)
			}

			local colorEl    = cast(Color) el
			local components = (colorEl.alpha ? 3 : 4)
			local x          = colorEl.layoutX
			local y1         = colorEl.layoutY
			local y2         = y1 + math.round(1 * colorEl.sliderWidth)
			local y3         = y1 + math.round(2 * colorEl.sliderWidth)
			local y4         = y1 + math.round(3 * colorEl.sliderWidth)
			local y5         = y1 + colorEl.layoutHeight
			local w          = colorEl.layoutWidth

			local hue        = colorEl.color[1]
			local saturation = colorEl.color[2]
			local value      = colorEl.color[3]
			local a          = colorEl.color[4]

			local highlight  = shouldHighlight(state, colorEl) ? math.max(state.activeSubid, state.hoveredSubid) : 0

			local iw, ih     = imageRainbow.getDimensions!()
			local rainbowSx  = w / iw
			local rainbowSy  = (y2-y1) / ih
			LG.setColor(1, 1, 1)
			LG.draw(imageRainbow, x, y1, 0, rainbowSx, rainbowSy)
			drawSliderValue(x, y1, w, y2-y1, hue, hue*360, "%d°", (highlight == 1))

			local r, g, b    = hsvToRgb(hue, 1, 1)
			iw, ih           = imageGradient.getDimensions!()
			local gradientSx = w / iw
			local gradientSy = (y3-y2) / ih
			LG.setColor(.5, .5, .5)
			LG.rectangle(LG.DrawMode.FILL, x, y2, w, y2-y1)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, y2, 0, gradientSx, gradientSy)
			drawSliderValue(x, y2, w, y3-y2, saturation, saturation*100, "%d%%", (highlight == 2))

			r, g, b    = hsvToRgb(hue, saturation, 1)
			gradientSy = (y4-y3) / ih
			LG.setColor(0, 0, 0)
			LG.rectangle(LG.DrawMode.FILL, x, y3, w, y4-y3)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, y3, 0, gradientSx, gradientSy)
			drawSliderValue(x, y3, w, y4-y3, value, value*100, "%d%%", (highlight == 3))

			if colorEl.alpha {
				r, g, b    = hsvToRgb(hue, saturation, value)
				gradientSy = (y5-y4) / ih
				drawCheckerBox(x, y4, w, y5-y4)
				LG.setColor(r, g, b)
				LG.draw(imageGradient, x, y4, 0, gradientSx, gradientSy)
				drawSliderValue(x, y4, w, y5-y4, a, a*100, "%d%%", (highlight == 4))
			}

			if highlight {
				local hlIndex = math.max(state.hoveredSubid, state.activeSubid)
				local hlY1    = y1 + math.round((hlIndex-1) * colorEl.sliderWidth)
				local hlY2    = y1 + math.round((hlIndex  ) * colorEl.sliderWidth)
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY_STRONG)
				LG.rectangle(LG.DrawMode.LINE, x-.5, hlY1-.5, w+1, hlY2-hlY1+1)
			}

		case ColorPreview:
			local preview = cast(ColorPreview) el

			static shader: LG.Shader = NULL
			if shader == NULL  shader = LG.newShader("src/particleColorPreview.glsl")

			-- The shader only supports 8 colors, but we can change that if necessary.
			static colorsForShader: [][]float = { {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1} }

			local colorCount = 0

			for preview.linkColors {
				local colorEl = cast(Color) state.elementsByName[it]

				if colorEl ~= NULL and isElementVisible(colorEl) {
					colorCount  += 1
					local color  = colorsForShader[colorCount]

					color[1], color[2], color[3] = hsvToRgb(colorEl.color[1], colorEl.color[2], colorEl.color[3])
					color[4]                     = colorEl.alpha ? colorEl.color[4] : 1
				}
			}

			shader.send!("colors",     colorsForShader[1], unpack(colorsForShader, 2))
			shader.send!("colorCount", colorCount)

			drawCheckerBox(preview.layoutX, preview.layoutY, preview.layoutWidth, preview.layoutHeight)

			LG.setShader(shader)
			LG.setBlendMode(preview.blendMode)
			LG.draw(imagePixel, preview.layoutX, preview.layoutY, 0, preview.layoutWidth, preview.layoutHeight)
			LG.setBlendMode(LG.BlendMode.ALPHA)
			LG.setShader()

		case Direction:
			local direction = cast(Direction) el

			local r :: DIRECTION_RADIUS
			local x = direction.layoutX + r
			local y = direction.layoutY + r

			local angle = direction.angle

			local highlight = shouldHighlight(state, direction)

			-- Background.
			LG.setColor(0, 0, 0, .4)
			LG.circle(LG.DrawMode.FILL, x, y, r)

			-- Spread.
			if direction.linkSpread {
				local other = cast(Slider) state.elementsByName[direction.linkSpread]

				if other ~= NULL and other.type == Slider and other.value ~= 0 and isElementVisible(other) {
					LG.setColor(1, 1, 1, .25)
					LG.arc(LG.DrawMode.FILL, x, y, .8*r, angle-other.value/2, angle+other.value/2, 32)
				}

			} elseif direction.linkOther {
				local other = cast(Direction) state.elementsByName[direction.linkOther]

				if other ~= NULL and other.type == Direction and other.angle ~= angle and isElementVisible(other) {
					LG.setColor(1, 1, 1, .25)
					LG.arc(LG.DrawMode.FILL, x, y, .8*r, angle, other.angle, 32)
				}
			}

			-- Guides.
			LG.setColor(1, 1, 1, .08)
			LG.line(x-r+1, y, x+r-1, y)
			LG.line(x, y-r+1, x, y+r-1)
			LG.line(x-.3*r, y-.3*r, x+.3*r, y+.3*r)
			LG.line(x+.3*r, y-.3*r, x-.3*r, y+.3*r)

			-- Outline.
			if highlight {
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
				LG.circle(LG.DrawMode.LINE, x, y, r+.5)
			}

			-- Value.
			LG.setColor(1, 1, 1)
			LG.line(x, y, x+r*math.cos(angle), y+r*math.sin(angle))

			-- Readout.
			if app.showPanelNumbers {
				local text  = format("%d°", angle*360/math.TAU)
				local textX = x - fontSmall.getWidth!(text) // 2
				local textY = (angle % math.TAU < math.PI) ? direction.layoutY+5 : direction.layoutY+2*r-5-fontSmall.getHeight!()
				LG.setFont(fontSmall)
				LG.setColor(0, 0, 0)
				LG.print(text, textX+1, textY+1)
				LG.setColor(1, 1, 1)
				LG.print(text, textX, textY)
				LG.setFont(fontNormal)
			}

		case Canvas:
			local canvasEl = cast(Canvas) el

			local x = canvasEl.layoutX
			local y = canvasEl.layoutY
			local w = canvasEl.layoutWidth
			local h = canvasEl.layoutHeight

			LG.pushAll()
			LG.translate(x, y)
			LG.setColor(1, 1, 1)
			intersectScissor(x, y+getScrollOffset(canvasEl), w, h)
			triggerDrawEvent(state, canvasEl, w, h)
			LG.pop()

		case: errorf("%d", el.type)
	}

	!if DEV  if LK.isScancodeDown"`" {
		if el[1] == NULL {
			LG.setColor(0, 1, 0, .5)
		} else {
			LG.setColor(1, 0, 0, .35)
			LG.setColorMask(true, false, true, true)
		}
		LG.rectangle(LG.DrawMode.LINE, el.layoutX+.5, el.layoutY+.5, el.layoutWidth-1, el.layoutHeight-1)
		LG.setColorMask()
	}
}

export draw :: (state:State) {
	updateLayoutIfNeeded(state)

	local ww, wh   = LG.getDimensions()
	local topModal = getTopmostActiveModal(state)

	for state.frames  if it.active {
		if it == topModal {
			LG.setColor(.2, .2, .2, .6)
			LG.rectangle(LG.DrawMode.FILL, 0, 0, ww, wh)
		}
		drawElement(state, it)
	}

	if state.currentTooltip {
		local a = math.clamp01(((LT.getTime() - state.tooltipTime) - .30) / 0.20)

		if a > 0 {
			local w = fontNormal.getWidth!(state.currentTooltip) + 2*SPACING
			local h = fontNormal.getHeight!() + 2*BUTTON_PADDING_Y
			local x = math.min(state.tooltipX, ww-w)
			local y = state.tooltipY1 - h - 1

			if y < 0  y = state.tooltipY2 + 1

			LG.setColor(0, 0, 0, .8*a)
			LG.rectangle(LG.DrawMode.FILL, x-1, y-1, w+2, h+2, BUTTON_RADIUS)
			LG.setColor(.8, .8, .8, a)
			LG.rectangle(LG.DrawMode.FILL, x, y, w, h, 2)
			LG.setColor(0, 0, 0, a)
			LG.print(state.currentTooltip, x+SPACING, y+BUTTON_PADDING_Y)
		}
	}
}



export isInsideElement :: (state:State, x,y:int, el:gui.Element) -> bool {
	if not el.active  return false

	updateLayoutIfNeeded(state)

	if el.type == {
		case Direction:
			local r :: DIRECTION_RADIUS
			return math.distance(x,y, el.layoutX+r,el.layoutY+r) <= r

		case Slider:
			return x >= el.layoutX and x < el.layoutX+el.layoutWidth and math.abs(y-(el.layoutY+el.layoutHeight/2)) <= SLIDER_MIN_WIDTH/2

		case Checkbox:
			return x >= el.layoutX and x < el.layoutX+el.layoutWidth and math.abs(y-(el.layoutY+el.layoutHeight/2)) <= CHECKBOX_SIZE/2

		case:
			return
				x >= el.layoutX and
				y >= el.layoutY and
				x <  el.layoutX+el.layoutWidth and
				y <  el.layoutY+el.layoutHeight
	}
}

export isOverGui :: (state:State, x,y:int) -> bool {
	for state.frames {
		if isInsideElement(state, x, y, it)  return true
	}
	return false
}



export getElement :: (state:State, name:string, $T:Type) -> T {
	return cast(T) state.elementsByName[name]
}
export getElement :: (state:State, name:string) -> Element { -- @Compiler @Incomplete: Default values for baked arguments.
	return state.elementsByName[name]
}

export getElementAt :: (state:State, x,y:int) -> (found:bool, el:Element) {
	updateLayoutIfNeeded(state)

	for < state.frames  if it.active {
		local helper :: (state:State, el:Element, x,y:int) -> Element {
			if not isInsideElement(state, x, y, el)  return NULL

			if el.type == Scrollable  y -= math.round((cast(Scrollable)el).scroll)

			for < el {
				local subEl = helper(state, it, x, y)
				if subEl ~= NULL  return subEl
			}

			return el
		}

		local el = helper(state, it, x, y)
		if el ~= NULL  return true, el

		if it.modal  return false, NULL
	}

	return false, NULL
}

export getWidgetAt :: (state:State, x,y:int) -> (found:bool, widget:Widget) {
	local found, widget = getElementAt(state, x, y)
	if not found  return false, NULL

	if widget.type == {
		case Buttons:   return true, cast(Widget)widget
		case InputText: return true, cast(Widget)widget
		case Radio:     return true, cast(Widget)widget
		case Tabs:      return true, cast(Widget)widget
		case Checkbox:  return true, cast(Widget)widget
		case Slider:    return true, cast(Widget)widget
		case Color:     return true, cast(Widget)widget
		case Direction: return true, cast(Widget)widget

		case Scrollable:
			if x < widget.layoutX + widget.layoutWidth - SCROLLBAR_WIDTH  return false, NULL
			return true, cast(Widget)widget

		case:
			return false, NULL
	}
}

export findParent :: (state:State, el:Element, name:string) -> (found:bool, parent:Element) {
	while true {
		el = el.parent
		if el      == NULL  return false, NULL
		if el.name == name  return true,  el
	}
}



export setActive :: (state:State, name:string, active:bool) -> (success:bool) {
	local el = state.elementsByName[name]
	if el == NULL {
		printf("Error: No element '%s'.", name)
		return false
	}

	return setActive(state, el, active)
}
export setActive :: (state:State, el:Element, active:bool) -> (success:bool) {
	if el.active == active  return true

	el.active               = active
	state.layoutNeedsUpdate = true

	if not active and state.focusId and (el.id == state.focusId or hasParent(state.elementsById[state.focusId], el)) {
		blurFocus(state, abort=false)
	}

	if el.type == Frame {
		local frame    = cast(Frame) el
		local found, i = indexOf(state.frames, frame)
		assert(found)
		remove(state.frames, i)
		insert(state.frames, frame)
	}

	if active
		triggerActiveEvent(state, el)
	else
		triggerInactiveEvent(state, el)

	return true
}

local hasParent :: (el:Element, parent:Element) -> bool {
	while el.parent ~= NULL {
		if el.parent == parent  return true
		el = el.parent
	}
	return false
}



local getScrollbarHandle :: (scrollable:Scrollable, visual:bool) -> (handlePos:int, handleLen:int, handlePosMax:int) {
	local contentH = scrollable.contentHeight
	local visibleH = scrollable.layoutHeight
	local paddedH  = visibleH - 2*SPACING

	local handleLen = math.clamp(
		math.round(visibleH * paddedH / contentH),
		SCROLLBAR_MIN_LENGTH,
		visibleH
	)

	local handlePos, handlePosMax = 0, 0
	if contentH > paddedH {
		local scroll = visual ? scrollable.scroll : scrollable.scrollTarget
		handlePosMax = visibleH - handleLen
		handlePos    = math.min(math.round(-scroll*handlePosMax/(contentH-paddedH)), handlePosMax)
	}

	return handlePos, handleLen, handlePosMax
}

local limitScroll :: (scrollable:Scrollable) {
	local limit             = math.max(scrollable.contentHeight - scrollable.layoutHeight + 2*SPACING, 0)
	scrollable.scrollTarget = math.clamp(scrollable.scrollTarget, -limit, 0)
	scrollable.scroll       = math.clamp(scrollable.scroll,       -limit, 0)
}

export getScrollOffset :: (el:Element) -> int {
	local offset = 0

	while el.parent ~= NULL {
		el = el.parent
		if el.type == Scrollable {
			offset += math.round((cast(Scrollable)el).scroll) -- Should we round here or when we return?
		}
	}

	return offset
}



export drawChecker :: (x,y,w,h:float, scale=1.0) {
	static quad: LG.Quad = NULL

	if quad == NULL {
		local iw, ih = imageChecker.getDimensions!()
		quad         = LG.newQuad(0, 0, 1, 1, iw, ih)
	}

	quad.setViewport!(0, 0, w/scale, h/scale)
	LG.draw(imageChecker, quad, x, y, 0, scale)
}

export drawCheckerBox :: (x,y,w,h:int) {
	LG.setColor(.15, .15, .15)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
	LG.setColor(.27, .27, .27)
	drawChecker(x, y, w, h)
}



local triggerRefreshEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onRefresh[el.name]
	if cb == NULL  return

	cb(el)
	state.layoutNeedsUpdate = true
}

local triggerActiveEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onActive[el.name]
	if cb == NULL  return

	cb(el)
}
local triggerInactiveEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onInactive[el.name]
	if cb == NULL  return

	cb(el)
}

local triggerDrawEvent :: (state:State, canvasEl:Canvas, cw,ch:int) {
	local cb = cast((canvasEl:Canvas, cw,ch:int)) state.onDraw[canvasEl.name]
	if cb == NULL  return

	cb(canvasEl, cw, ch)
}

local triggerSubmitEvent :: (state:State, widget:Widget) {
	local cb = cast((widget:Widget)) state.onSubmit[widget.name]
	if cb == NULL  return

	cb(widget)
}

local triggerActionEvent :: (state:State, widget:Widget, name:string, subid:int, save=false) {
	local cb = cast((widget:Widget, i:int)) state.onAction[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
	if save  scheduleSaveWorkspace()
}
local triggerDoublePressEvent :: (state:State, widget:Widget, name:string, subid:int, save=false) -> (handled:bool) {
	local cb = cast((widget:Widget, i:int)) state.onDouble[name ?: widget.name]
	if cb == NULL  return false

	cb(widget, subid)
	if save  scheduleSaveWorkspace()
	return true
}
local triggerOptionEvent :: (state:State, widget:Widget, name:string, subid:int, save=false) -> (handled:bool) {
	local cb = cast((widget:Widget, i:int)) state.onOption[name ?: widget.name]
	if cb == NULL  return false

	cb(widget, subid)
	if save  scheduleSaveWorkspace()
	return true
}
local triggerCloseEvent :: (state:State, widget:Widget, name:string, subid:int, save=false) {
	local cb = cast((widget:Widget, i:int)) state.onClose[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
	if save  scheduleSaveWorkspace()
}
local triggerDragEvent :: (state:State, widget:Widget, name:string, subid:int, mx,my:int) {
	local cb = cast((widget:Widget, i:int, mx,my:int)) state.onDrag[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid, mx, my)
}



export refresh :: (state:State, el:Element) {
	triggerRefreshEvent(state, el)
}
export refresh :: (state:State, name:string) {
	local el = state.elementsByName[name]
	if el == NULL {
		printf("Error: No element '%s'.", name)
		return
	}

	triggerRefreshEvent(state, el)
}

export refreshRecursively :: (state:State, el:Element, onlyActive=true) {
	triggerRefreshEvent(state, el)
	for el  if not (onlyActive and not it.active) {
		refreshRecursively(state, it, onlyActive)
	}
}
export refreshRecursively :: (state:State, name:string, onlyActive=true) {
	local el = state.elementsByName[name]
	if el == NULL {
		printf("Error: No element '%s'.", name)
		return
	}

	triggerRefreshEvent(state, el)
	for el  if not (onlyActive and not it.active) {
		refreshRecursively(state, it, onlyActive)
	}
}

export refreshAll :: (state:State, onlyActive=true) {
	for state.frames  if not (onlyActive and not it.active) {
		refreshRecursively(state, it, onlyActive)
	}
}



export isElementVisible :: (el:Element) -> bool {
	while el.parent ~= NULL {
		if not el.active  return false
		el = el.parent
	}

	return el.active
}



export setFocus :: (state:State, name:string) {
	local input = cast(InputText) state.elementsByName[name]
	if input == NULL {
		printf("Error: No element '%s'.", name)
		return
	}

	if input.type ~= InputText {
		printf("Error: Element '%s' is not InputText.", name)
		return
	}

	setFocus(state, input)
}
export setFocus :: (state:State, input:InputText) {
	if state.focusId == input.id  return

	blurFocus(state, abort=false)
	state.focusId = input.id

	if input.field == NULL {
		input.field = InputField()
		input.field.setFont!(fontNormal)
		input.field.setWidth!(input.layoutWidth - 2*SPACING)
	}

	input.field.setText!(input.value)
}

export blurFocus :: (state:State, abort=false) {
	if state.focusId == 0  return

	local input = cast(InputText) state.elementsById[state.focusId]
	if abort {
		input.field.setText!(input.value)
	} else {
		input.value = input.field.getText!()
		triggerActionEvent(state, input, "", 0, save=true)
	}

	state.focusId = 0
}



export getTopmostActiveModal :: (state:State) -> Frame {
	for < state.frames {
		if it.active and it.modal  return it
	}
	return NULL
}



export pressButton :: (state:State, buttonsElementName:string, i:int) {
	local buttons = cast(Buttons) state.elementsByName[buttonsElementName]
	if buttons == NULL {
		printf("Error: No element '%s'.", buttonsElementName)
		return
	}

	if not (buttons.type == Buttons or buttons.type == Radio or buttons.type == Tabs) {
		printf("Error: '%s' is not a buttons element.", buttonsElementName)
		return
	}

	local button = buttons.buttons[i]
	if button == NULL or true {
		printf("Error: No button at index %d in '%s'.", i, buttonsElementName)
		return
	}

	triggerActionEvent(state, buttons, button.name, i, save=true)
}



export showContextMenu :: (state:State, items:[]string, cb:(i:int)) {
	local mx, my = LM.getPosition()
	showContextMenu(state, mx, my, items, cb)
}
export showContextMenu :: (state:State, x,y:int, items:[]string, cb:(i:int)) {
	hideContextMenu(state)

	local buttonList: []Button
	for items  insert(buttonList, cast(Button){ label=it })

	local contextMenu = state.frame!({ data=cb, x=x, y=y, minWidth=CONTEXT_MENU_MIN_WIDTH, layout=Layout.FLOATING, style=Style.CONTEXT_MENU,
		guiState.buttons!({ name="__contextMenuButtons", vertical=true, align=Alignment.LEFT, style=Style.CONTEXT_MENU, buttonMinHeight=16,
			buttons = {unpack(buttonList)},
		}),
	})

	state.contextMenu = contextMenu
	insert(state.frames, contextMenu)

	state.layoutNeedsUpdate = true
	updateLayoutIfNeeded(state)

	x       = contextMenu.layoutX
	y       = contextMenu.layoutY
	local w = contextMenu.layoutWidth
	local h = contextMenu.layoutHeight

	if x   > LG.getWidth()-w  state.layoutNeedsUpdate, contextMenu.x = true, math.max(LG.getWidth()-w, 0)
	if y+h > LG.getHeight()   state.layoutNeedsUpdate, contextMenu.y = true, y - h

	state.onAction.__contextMenuButtons = [state,cb] (buttons:Buttons, i:int) {
		state.contextMenu.data = NULL
		hideContextMenu(state)
		cb(i)
		scheduleSaveWorkspace()
	}
}

export hideContextMenu :: (state:State) -> (success:bool) {
	local contextMenu = state.contextMenu
	if contextMenu == NULL  return false

	delete(state, contextMenu)
	state.contextMenu = NULL

	local cb = cast((i:int)) contextMenu.data
	if cb ~= NULL  cb(0)

	return true
}



export delete :: (state:State, el:Element) {
	updateLayoutIfNeeded(state) -- Needed for parents. @Speed

	if el.type == Frame {
		local frame    = cast(Frame) el
		local found, i = indexOf(state.frames, frame)
		if not found  return

		unregisterTree(state, frame)
		remove(state.frames, i)

	} else {
		local found, i = indexOf(el.parent, el)
		if not found  return

		unregisterTree(state, el)
		remove(el.parent, i)
	}
}



local shouldHighlight :: (state:State, el:$T) -> bool {
	if el.id == state.activeId or el.id == state.hoveredId  return true

	local mod = state.activeId ? state.activeMod : getModifierKey()
	if not (mod == ModifierKey.S or mod == ModifierKey.CS)  return false

	local other = cast(T) state.elementsById[state.activeId ?: state.hoveredId]
	if other      == NULL  return false
	if other.type ~= T     return false

	!if    T == Slider     return (indexOf(other.linkMultiDrag, el.name))
	elseif T == Direction  return (indexOf(other.linkMultiDrag, el.name))
	elseif T == Color      return (indexOf(other.linkMultiDrag, el.name))
}



local intersectScissor :: (x,y,w,h:int) {
	LG.intersectScissor(x, y, math.max(w, 0), math.max(h, 0))
}



local drawSliderReadout :: (rightX:int, topY:int, height:int, handleX:int, value:float, valueMultiplierForFormat:float, formatString:string, formatStringIfZero:string, colorText,colorShadow:love.Color) {
	if value == 0 and formatStringIfZero  formatString = formatStringIfZero

	if not formatString  return

	local text  = format(formatString, value * valueMultiplierForFormat)
	local textW = fontSmall.getWidth!(text)
	local textX = rightX - SPACING - textW
	local textY = topY + (height - fontNormal.getHeight!()) // 2

	local MIN_DIST_TO_HANDLE :: 5
	if textX < handleX+MIN_DIST_TO_HANDLE  textX = handleX-MIN_DIST_TO_HANDLE - textW

	LG.setFont(fontSmall)
	LG.setColor(colorShadow)
	LG.print(text, textX+1, textY+1)
	LG.setColor(colorText)
	LG.print(text, textX, textY)
	LG.setFont(fontNormal)
}


