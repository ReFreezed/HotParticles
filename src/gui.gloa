--[[============================================================
--=
--=  Retained-mode GUI
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	State

	Buttons, Radio, Tabs
	Canvas
	Checkbox
	Direction
	Frame
	Hbox, Vbox
	InputText
	Scrollable
	Section
	Separator
	Slider, Color, ColorPreview
	Text

	cancelMouseActions
	delete
	draw
	drawBoxGradient
	drawChecker, drawCheckerBox
	drawColorGradient
	getElement, getElementAt, getWidgetAt, findParent
	getTopmostActiveModal
	getVisibleAreaInLocalSpace
	isElementVisible
	isInsideElement, isOverGui
	onKeyPressed, onKeyReleased, onTextInput
	onMousePressed, onMouseMoved, onMouseReleased, onMouseWheel
	pressButton
	refresh, refreshRecursively, refreshAll
	scrollTo, scrollIntoView
	setActive
	setFocus, blurFocus
	showMenu, showContextMenu, showContextMenuWithInput, hideContextMenu
	update
	updateLayout

--============================================================]]



export SPACING       :: 3
export SPACING_LARGE :: 10

local BUTTON_RADIUS    :: 2
local BUTTON_PADDING_Y :: 2

export SCROLLABLE_PADDING   :: 5 -- Vertical.
export SCROLLBAR_WIDTH      :: 8
export SCROLLBAR_MIN_LENGTH :: 16

local SECTION_DEFAULT_LABEL_WIDTH :: 104

local SLIDER_MIN_THICKNESS :: 12
local SLIDER_MIN_LENGTH    :: 70
local COLOR_PREVIEW_WIDTH  :: 24

local INPUT_MIN_WIDTH :: 40

local CHECKBOX_SIZE :: 14 -- @Temp until we have an image.

local DIRECTION_RADIUS :: 25

local BUTTON_IMAGE_MAX_SIZE :: 18
local PARTICLE_PREVIEW_SIZE :: 30
local SPECIAL_TAB_WIDTH     :: 32

local TAB_BOTTOM_LINE_WIDTH :: 2

local DRAG_RADIUS :: 8 -- Distance moved before dragging starts for real.

local CONTEXT_MENU_MIN_WIDTH :: 150

export TEXT_OPACITY                 :: .85
local  HOVER_OUTLINE_OPACITY        :: .3
local  HOVER_OUTLINE_OPACITY_STRONG :: .7
local  DISABLED_OPACITY             :: .4

local COLOR_FOCUS: love.Color : {1,.5,0,.6}



export clipboardScalar = 0.0
export clipboardAngle  = 0.0
export clipboardColor: []float = {0,0,0,0} -- {h,s,v,a}
export hasClipboardScalar = false
export hasClipboardAngle  = false
export hasClipboardColor  = false



export State :: struct {
	frames:      []Frame,
	scrollables: []Scrollable,

	elementsById:   struct { !key: int,    !value: Element },
	elementsByName: struct { !key: string, !value: Element },

	nextId = 1,

	hoveredId    = 0,
	hoveredSubid = 0,

	activeId       = 0,
	activeSubid    = 0,
	activeMod      = ModifierKey.NONE,
	activeStartMx  = 0,
	activeStartMy  = 0,
	activeDragging = false, -- For the drag event - not for sliders etc.!

	focusId = 0, -- Keyboard focus.

	currentTooltip = "",
	tooltipTime    = 0.00,
	tooltipX       = 0,
	tooltipY1      = 0, -- Primary.
	tooltipY2      = 0, -- Fallback.

	layoutNeedsUpdate = true,

	extraScrollableSpace = 0,

	contextMenus: []Frame,

	scrollbarHandleDragOffset = 0,

	onRefresh:          struct { !key:string, !value:any--[[ (el:Element) ]] },
	onActive:           struct { !key:string, !value:any--[[ (el:Element) ]] },
	onInactive:         struct { !key:string, !value:any--[[ (el:Element) ]] },
	onSubmit:           struct { !key:string, !value:any--[[ (el:Element) ]] },
	onDrawBackground:   struct { !key:string, !value:any--[[ (el:Element, w,h:int) ]] },
	onDraw:             struct { !key:string, !value:any--[[ (el:Element, w,h:int) ]] }, -- Usually used for canvases.
	onDrawForeground:   struct { !key:string, !value:any--[[ (el:Element, w,h:int) ]] },
	onBeforeAction:     struct { !key:string, !value:any--[[ (widget:Widget, subid:int) -> (ignore:bool) ]] }, -- Only used for Radio and Tabs.
	onBegin:            struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onAction:           struct { !key:string, !value:any--[[ (widget:Widget, subid:int, source:ActionSource) ]] },
	onEnd:              struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onDouble:           struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onOption:           struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onClose:            struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onDragBegin:        struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onDrag:             struct { !key:string, !value:any--[[ (widget:Widget, subid:int, mx,my:int) ]] },
	onDragEnd:          struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onMouseEnter:       struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] },
	onToggle:           struct { !key:string, !value:any--[[ (widget:Widget, subid:int) ]] }, -- For disable/enable. (Not for checkboxes!)
	onBeforeKeyPressed: struct { !key:string, !value:(input:InputText, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (ignore:bool) },
	onBeforeTextInput:  struct { !key:string, !value:(input:InputText, text:string) -> (ignore:bool) },

	buttons      :: (state:State, el:Buttons)      -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	canvas       :: (state:State, el:Canvas)       -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	checkbox     :: (state:State, el:Checkbox)     -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	color        :: (state:State, el:Color)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	colorPreview :: (state:State, el:ColorPreview) -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	direction    :: (state:State, el:Direction)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	frame        :: (state:State, el:Frame)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	hbox         :: (state:State, el:Hbox)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	inputText    :: (state:State, el:InputText)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	radio        :: (state:State, el:Radio)        -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	scrollable   :: (state:State, el:Scrollable)   -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	section      :: (state:State, el:Section)      -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	separator    :: (state:State, el:Separator)    -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	slider       :: (state:State, el:Slider)       -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	tabs         :: (state:State, el:Tabs)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	text         :: (state:State, el:Text)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },
	vbox         :: (state:State, el:Vbox)         -> type_of(el) { return cast(type_of(el)) register(state, el, type_of(el)) },

	-- @Cleanup: Use !self here instead of _*, maybe.  (@Compiler: We get redeclaration error because !self.getElement etc. isn't a simple identifier.)
	blurFocus :: _blurFocus,
	cancelMouseActions :: _cancelMouseActions,
	delete :: _delete,
	draw :: _draw,
	exists :: _exists,
	findParent :: _findParent,
	getButtonLayout :: _getButtonLayout,
	getElement :: _getElement,
	getElementAt :: _getElementAt,
	getScrollOffset :: _getScrollOffset,
	getTopmostActiveModal :: _getTopmostActiveModal,
	getVisibleAreaInLocalSpace :: _getVisibleAreaInLocalSpace,
	getWidgetAt :: _getWidgetAt,
	hideContextMenu :: _hideContextMenu,
	isElementVisible :: _isElementVisible,
	isInsideElement :: _isInsideElement,
	isOverGui :: _isOverGui,
	onFocus :: _onFocus,
	onKeyPressed :: _onKeyPressed,
	onKeyReleased :: _onKeyReleased,
	onMouseMoved :: _onMouseMoved,
	onMousePressed :: _onMousePressed,
	onMouseReleased :: _onMouseReleased,
	onMouseWheel :: _onMouseWheel,
	onTextInput :: _onTextInput,
	pressButton :: _pressButton,
	refresh :: _refresh,
	refreshAll :: _refreshAll,
	refreshRecursively :: _refreshRecursively,
	scrollIntoView :: _scrollIntoView,
	scrollTo :: _scrollTo,
	setActive :: _setActive,
	setFocus :: _setFocus,
	showContextMenu :: _showContextMenu,
	showContextMenuWithInput :: _showContextMenuWithInput,
	showMenu :: _showMenu,
	showTextPrompt :: _showTextPrompt,
	update :: _update,
	updateLayout :: _updateLayout,
}

local _blurFocus :: blurFocus
local _cancelMouseActions :: cancelMouseActions
local _delete :: delete
local _draw :: draw
local _exists :: exists
local _findParent :: findParent
local _getButtonLayout :: getButtonLayout
local _getElement :: getElement
local _getElementAt :: getElementAt
local _getScrollOffset :: getScrollOffset
local _getTopmostActiveModal :: getTopmostActiveModal
local _getVisibleAreaInLocalSpace :: getVisibleAreaInLocalSpace
local _getWidgetAt :: getWidgetAt
local _hideContextMenu :: hideContextMenu
local _isElementVisible :: isElementVisible
local _isInsideElement :: isInsideElement
local _isOverGui :: isOverGui
local _onFocus :: onFocus
local _onKeyPressed :: onKeyPressed
local _onKeyReleased :: onKeyReleased
local _onMouseMoved :: onMouseMoved
local _onMousePressed :: onMousePressed
local _onMouseReleased :: onMouseReleased
local _onMouseWheel :: onMouseWheel
local _onTextInput :: onTextInput
local _pressButton :: pressButton
local _refresh :: refresh
local _refreshAll :: refreshAll
local _refreshRecursively :: refreshRecursively
local _scrollIntoView :: scrollIntoView
local _scrollTo :: scrollTo
local _setActive :: setActive
local _setFocus :: setFocus
local _showContextMenu :: showContextMenu
local _showContextMenuWithInput :: showContextMenuWithInput
local _showMenu :: showMenu
local _showTextPrompt :: showTextPrompt
local _update :: update
local _updateLayout :: updateLayout



local register :: (state:State, el:Element, T:Type) -> Element {
	el.type = T
	el.id   = state.nextId
	state.nextId += 1

	state.elementsById[el.id] = el
	if el.name  state.elementsByName[el.name] = el

	if T == Scrollable  insert(state.scrollables, cast(Scrollable)el)

	return el
}

local unregisterTree :: (state:State, el:Element, updateInteractions:bool) {
	if updateInteractions { -- @Hack!
		if state.focusId  == el.id  state.blurFocus!(abort=false)
		if state.activeId == el.id  state.cancelMouseActions!()

		if state.hoveredId == el.id {
			state.hoveredId    = 0
			state.hoveredSubid = 0
		}
	}

	state.elementsById[el.id] = NULL
	if el.name  state.elementsByName[el.name] = NULL

	if el.type == Scrollable {
		local found, i = indexOf(state.scrollables, cast(Scrollable) el)
		assert(found)
		remove(state.scrollables, i)
	}

	for el  unregisterTree(state, it, updateInteractions)
}



export Style :: enum string { NORMAL, CONTEXT_MENU, LIST }

export Element :: struct {
	active         = true,
	name           = "",
	label          = "",
	labelLeft      = "",
	labelLeftAlign = Alignment.CENTER,
	tooltip        = "",
	weight         = .0,
	inset          = 0,
	width          = 0, -- Zero means automatic.
	height         = 0, -- Zero means automatic. For scrollables, non-positive means distance from the bottom of the screen.
	minWidth       = 0,
	minHeight      = 0,
	maxWidth       = -1, -- Negative means no limit.
	maxHeight      = -1, -- Negative means no limit.
	style          = Style.NORMAL,
	enabled        = true, -- Only for Widgets.  @Cleanup: Move to Widget (but we must add a way to know if an element is a Widget).
	data:     any,
	dataTemp: any,

	type: Type = NULL,
	id:   int  = NULL,

	frame:  Frame   = NULL,
	parent: Element = NULL,
	!value: Element, -- Children.

	layoutX: int,
	layoutY: int,
	layoutHeight: int,
	layoutWidth:  int,
}

export Widget :: struct {
	using Element,

	canDisable = false,
}



export Layout :: enum string { DOCKED, FLOATING }

export Frame :: struct {
	using Element,

	layout = Layout.DOCKED,
	modal  = false,
	temp   = false,
	x      = -1, -- Negative means centered. Only used if floating.
	y      = -1, -- Negative means centered. Only used if floating.

	parentFrame: Frame = NULL,
}



export Scrollable :: struct {
	using Widget,

	-- ...

	contentHeight: int,

	scroll       = 0.0,
	scrollSource = 0.0,
	scrollTarget = 0,
}

export Section :: struct {
	using Widget,

	icon16     = "",
	labelWidth = SECTION_DEFAULT_LABEL_WIDTH,
}

local Box :: struct {
	-- expandChildren = true,

	using Element,
}
export Hbox :: struct {
	using Box,
}
export Vbox :: struct {
	using Box,
}



export Text :: struct {
	using Element,

	text = "",
	textLines: []string,
	size = 2, -- 1=small, 2=normal, 3=large

	textHeight = 0,
}

export Separator :: struct {
	using Element,

	thick = false,
}



export Button :: struct {
	name     = "", -- Inherited from parent if empty.
	label    = "",
	suffix   = "", -- Appears faded after the label.
	shortcut = "", -- Appears on the right side. Requires the parent's Buttons.align to be LEFT to work properly.
	image    = "",
	tooltip  = "",
	enabled  = true,
	value: any,
	draggable   = false,
	submenuIcon = false,
	selected    = false, -- Used if Buttons.allowFocus is set.
	system: System = NULL,

	imageScale = 1.0,

	labelWidth    = 0,
	suffixWidth   = 0,
	shortcutWidth = 0,
	contentWidth  = 0,
}

export Alignment :: enum string { CENTER, LEFT, RIGHT, TOP, BOTTOM }

export Buttons :: struct {
	using Widget,

	buttons: []Button,
	align              = Alignment.CENTER,
	vertical           = false,
	allowFocus         = false,
	selectMultiple     = false, -- Used if Buttons.allowFocus is set.
	buttonMinHeight    = 0,
	buttonPaddingRight = 0,

	buttonWidth:  float, -- Round when necessary!
	buttonHeight: float, -- Round when necessary!
}

export Radio :: struct {
	using Buttons,

	index = 1,
}

export Tabs :: struct {
	using Radio,

	specialLastTab = false,
}



export Checkbox :: struct {
	using Widget,

	checked = false,
}



export Slider :: struct {
	using Widget,

	-- Settings:
	value        = 0.0,
	defaultValue = 0.0,

	min = 0.0,
	max = 1.0,

	steps = 32,

	limitName   = "",
	limitCenter = 0.0,

	linkMultiDrag: []string,

	readoutMulti = 1.0,
	readout      = "",
	readoutZero  = "",

	isInt       = false,
	exponential = false,
	--
}

export Color :: struct {
	using Widget,

	alpha = true,
	color: []float = {0,0,1,1}, -- {h,s,v,a}
	linkMultiDrag: []string,

	sliderWidth = 0.0, -- Round when necessary!
}



export ColorPreview :: struct {
	using Widget,

	linkColors: []string,
	blendMode = LG.BlendMode.ALPHA,
}



export Direction :: struct {
	using Widget,

	angle      = 0.0,
	linkOther  = "",
	linkSpread = "",
	linkMultiDrag: []string,
}



export InputText :: struct {
	using Widget,

	value       = "",
	placeholder = "",

	field: InputField = NULL,
}



export Canvas :: struct {
	using Widget,
}



export MenuItem :: struct {
	name     = "",
	label    = "",
	shortcut = "",
	height   = 16,
	data:    any,
	submenu: []MenuItem,

	submenuFrame = Frame.NULL,
}



export onKeyPressed :: (state:State, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (handled:bool) {
	-- Modifier keys.
	if (state.activeId or state.hoveredId) and (key == lctrl or key == rctrl or key == "lshift" or key == "rshift" or key == "lalt" or key == "ralt") {
		local mx, my = LM.getPosition()
		state.onMouseMoved!(mx, my, 0, 0)
	}
	if state.activeId  return true

	--   escape other  situation
	-- ----------------------------------------------
	--   pass   pass   nothing
	-- * blur   input  normal input focused
	-- * close  eat    normal input focused + context menu
	--   close  eat    context menu
	-- * blur   input  context menu + inner input focused

	-- Key events for inputs (which may be in a context menu) or other focusables.
	if state.focusId {
		local widget = cast(Widget) state.elementsById[state.focusId]

		if key == "escape" {
			state.blurFocus!(abort=true)

		} elseif widget.type == InputText {
			local input = cast(InputText) widget

			-- Input outside context menu.
			if state.contextMenus and not indexOf(state.contextMenus, input.frame) {
				if key == "escape"  state.hideContextMenu!(mayDeactivateSubmenu=true)
				return true
			}

			if triggerBeforeKeyPressedEvent(state, input, "", key, scancode, isRepeat) {
				-- void
			} elseif key == "return" or key == "kpenter" {
				state.blurFocus!(abort=false)
				triggerSubmitEvent(state, input)
			} else {
				input.field.keypressed!(key, scancode, isRepeat)
			}

		} elseif widget.type == Buttons {
			local buttons = cast(Buttons) widget

			if key == "return" or key == "kpenter" {
				local found, i = indexWith(buttons.buttons, "selected", true)
				if found  triggerDoublePressEvent(state, buttons, buttons.buttons[i].name, i) -- @Cleanup: Rename double-press events to something better, or use the submit event.

			} elseif key == "down" or key == "up" {
				if not buttons.buttons  return true

				local dir      = (key == "down") ? 1 : -1
				local found, i = indexWith(buttons.buttons, "selected", true)

				i = found
					? math.clamp(i+dir, 1, #buttons.buttons)--((i-1+dir) % #buttons.buttons + 1)
					: 1--(dir < 0 ? #buttons.buttons : 1)

				local anyChange = false

				for buttons.buttons {
					local isSelected = (itIndex == i)

					if it.selected ~= isSelected {
						it.selected = isSelected
						anyChange   = true
					}
				}
				state.scrollIntoView!(buttons, i)

				if not anyChange  return true

				triggerBeginEvent (state, buttons, buttons.buttons[i].name, i)
				triggerActionEvent(state, buttons, buttons.buttons[i].name, i, .KEYBOARD, alsoEnd=true)

			} elseif key == "pageup" or key == "pagedown" {
				if not buttons.buttons  return true

				local dir          = (key == "pagedown") ? 1 : -1
				local x, y, w, h   = state.getVisibleAreaInLocalSpace!(buttons)
				local visibleCount = math.max(math.floor(h/buttons.buttonHeight), 1)
				local step         = math.max(visibleCount-1, 1)
				local found, i     = indexWith(buttons.buttons, "selected", true)

				i = found
					? math.clamp(i+step*dir, 1, #buttons.buttons)
					: 1

				local anyChange = false

				for buttons.buttons {
					local isSelected = (itIndex == i)

					if it.selected ~= isSelected {
						it.selected = isSelected
						anyChange   = true
					}
				}
				state.scrollIntoView!(buttons, i)

				if not anyChange  return true

				triggerBeginEvent (state, buttons, buttons.buttons[i].name, i)
				triggerActionEvent(state, buttons, buttons.buttons[i].name, i, .KEYBOARD, alsoEnd=true)

			} elseif key == "end" or key == "home" {
				if not buttons.buttons  return true

				local iTarget  = (key == "end") ? #buttons.buttons : 1
				local found, i = indexWith(buttons.buttons, "selected", true)

				if found and i == iTarget  return true -- @Incomplete: Don't return if the target button is selected, but there are also others selected.

				for buttons.buttons  it.selected = (itIndex == iTarget)
				state.scrollIntoView!(buttons, iTarget)

				triggerBeginEvent (state, buttons, buttons.buttons[iTarget].name, iTarget)
				triggerActionEvent(state, buttons, buttons.buttons[iTarget].name, iTarget, .KEYBOARD, alsoEnd=true)
			}
		}

		return true
	}

	-- Context menu.
	if state.contextMenus {
		if key == "escape"  state.hideContextMenu!(mayDeactivateSubmenu=true)
		return true
	}

	-- Submit modals.
	if key == "return" or key == "kpenter" {
		local topModal = state.getTopmostActiveModal!()

		if topModal ~= NULL {
			triggerSubmitEvent(state, topModal)
			return true
		}
	}

	-- Key events for other widgets.
	local widget = cast(Widget) state.elementsById[state.hoveredId]
	local mod    = getModifierKey()

	if widget ~= NULL  if widget.type == {
		case Direction:
			local direction = cast(Direction) widget

			if (mod == .NONE or mod == .S or mod == .C) and (key == "left" or key == "right") {
				local delta = math.TAU * ((mod == .S) ? 22.5/360 : (mod == .C) ? 1/360 : 5/360)

				triggerBeginEvent(state, direction, "", 0, alsoEnsureEnabled=true)
				direction.angle = ((key == "left" ? direction.angle-delta : direction.angle+delta) + math.PI) % math.TAU - math.PI
				triggerActionEvent(state, direction, "", 0, .KEYBOARD, alsoEnd=true)

				return true
			}

		case Slider:
			local slider = cast(Slider) widget

			if (mod == .NONE or mod == .S or mod == .C) and (key == "left" or key == "right") {
				local delta = (
					slider.isInt
					? ((mod == .S) ? 20 : (mod == .C) ? 1 : 5)
					: (
						(slider.max - slider.min)
						* getLimitMultiplier(slider)
						/ ((mod == .S) ? 16 : (mod == .C) ? 1024 : 128)
					)
				)

				triggerBeginEvent(state, slider, "", 0, alsoEnsureEnabled=true)
				slider.value = math.clamp(
					slider.value + delta * (key == "left" ? -1 : 1),
					applyLimitMultiplier(slider, slider.min),
					applyLimitMultiplier(slider, slider.max)
				)
				triggerActionEvent(state, slider, "", 0, .KEYBOARD, alsoEnd=true)

				return true
			}

		case Color:
			local colorEl = cast(Color) widget

			if (mod == .NONE or mod == .S or mod == .C) and (key == "left" or key == "right") {
				local component = state.hoveredSubid

				local delta = (
					component == 1
					? ((mod == .S) ? 30  : (mod == .C) ? 1  : 6) / 360
					: ((mod == .S) ? 7.5 : (mod == .C) ? .5 : 2) / 100
				)

				triggerBeginEvent(state, colorEl, "", component, alsoEnsureEnabled=true)
				colorEl.color[component] = math.clamp01(key == "left" ? colorEl.color[component]-delta : colorEl.color[component]+delta)
				triggerActionEvent(state, colorEl, "", component, .KEYBOARD, alsoEnd=true)

				return true
			}
	}

	return false
}

export onKeyReleased :: (state:State, key:LK.KeyConstant, scancode:LK.Scancode) {
	if (state.activeId or state.hoveredId) and (key == lctrl or key == rctrl or key == "lshift" or key == "rshift" or key == "lalt" or key == "ralt") {
		local mx, my = LM.getPosition()
		state.onMouseMoved!(mx, my, 0, 0)
	}
}

export onTextInput :: (state:State, text:string) -> (handled:bool) {
	if state.focusId {
		local widget = cast(Widget) state.elementsById[state.focusId]

		if widget.type == InputText {
			local input = cast(InputText) widget

			-- Input outside context menu.
			if state.contextMenus and not indexOf(state.contextMenus, input.frame) {
				return true
			}

			if triggerBeforeTextInputEvent(state, input, "", text) {
				-- void
			} else {
				input.field.textinput!(text)
			}
			return true
		}
	}

	return false
}

export onMousePressed :: (state:State, mx,my:int, mbutton:int, presses:int) -> (handled:bool) {
	updateLayoutIfNeeded(state)

	if not state.focusId {
		-- void

	} elseif state.hoveredId == state.focusId {
		local widget = cast(Widget) state.elementsById[state.focusId]

		if widget.type == InputText {
			local input = cast(InputText) widget
			input.field.mousepressed!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input)), mbutton, presses)
		}

	} else {
		state.blurFocus!(abort=false)
	}

	for < frame: state.frames  if state.isInsideElement!(mx, my, frame) {
		-- Focus inputs.
		if (mbutton == 1 or mbutton == 2) and state.hoveredId and not state.focusId {
			local widget = cast(Widget) state.elementsById[state.hoveredId]

			if widget.type == InputText {
				local input = cast(InputText) widget
				state.setFocus!(input)
				input.field.mousepressed!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input)), mbutton, presses)

			} elseif widget.type == Buttons and (cast(Buttons)widget).allowFocus {
				local buttons = cast(Buttons) widget
				state.setFocus!(buttons)
			}
		}

		-- Handle press on widget.
		if mbutton == 1 and state.hoveredId {
			local el      = state.elementsById[state.hoveredId]
			local buttons = cast(Buttons) el
			local slider  = cast(Slider)  el

			local mayDoublePress = (presses % 2 == 0)

			if el.type == Buttons and buttons.allowFocus {
				if buttons.selectMultiple and LK.isDown(lctrl,rctrl) {
					local button    = buttons.buttons[state.hoveredSubid]
					button.selected = not button.selected
					mayDoublePress  = false
					-- @Incomplete: Maybe don't trigger action event like normal when deselecting?
				} else {
					for buttons.buttons {
						it.selected = (itIndex == state.hoveredSubid)
					}
				}
			}

			-- Buttons which allow double press.
			if el.type == Buttons and (buttons.style == .CONTEXT_MENU or buttons.style == .LIST) {
				local handled = false
				if mayDoublePress {
					handled = triggerDoublePressEvent(state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid)
				}
				if not handled {
					triggerBeginEvent (state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid, alsoEnsureEnabled=true)
					triggerActionEvent(state, buttons, buttons.buttons[state.hoveredSubid].name, state.hoveredSubid, .MOUSE, alsoEnd=true)
				}

			-- Double press on sliders.
			} elseif el.type == Slider and mayDoublePress and triggerDoublePressEvent(state, slider, "", 0) {
				-- void

			-- Press that activates.
			} else {
				state.activeId      = state.hoveredId
				state.activeSubid   = state.hoveredSubid
				state.activeMod     = getModifierKey()
				state.activeStartMx = mx
				state.activeStartMy = my

				LM.setGrabbed(true)
				LK.setKeyRepeat(false)

				if el.type == Scrollable {
					local scrollable           = cast(Scrollable) el
					local handlePos, handleLen = getScrollbarHandle(scrollable, visual=false)

					if my >= scrollable.layoutY+handlePos and my < scrollable.layoutY+handlePos+handleLen {
						state.scrollbarHandleDragOffset = - (my - scrollable.layoutY - handlePos)
					} else {
						state.scrollbarHandleDragOffset = - (handleLen // 2)
					}

				}

				state.onMouseMoved!(mx, my, 0, 0, begin=true)
			}
		}

		-- A press elsewhere in the frame close menus, unless the frame is a menu itself.
		if state.contextMenus and not indexOf(state.contextMenus, frame) {
			state.hideContextMenu!()
		}

		return true -- We only match the first frame under the mouse cursor.
	}

	-- A press outside any frame close menus.
	state.hideContextMenu!()

	return state.activeId > 0 or state.getTopmostActiveModal!() ~= NULL
}

export onMouseMoved :: (state:State, mx,my:int, dx,dy:int, begin=false, end=false) {
	updateLayoutIfNeeded(state)

	local updateMouseCursor :: (state:State) {
		using currentCursor

		if state.hoveredId and state.elementsById[state.hoveredId].type == InputText {
			currentCursor = I_BEAM

		} elseif (
			(state.activeId or state.hoveredId)
			and state.elementsById[math.max(state.activeId, state.hoveredId)].type == Slider
			and (cast(Slider) state.elementsById[math.max(state.activeId, state.hoveredId)]).limitName
			and (state.activeId ? state.activeMod : getModifierKey()) == .A
		) {
			currentCursor = SIZE_VERTICAL

		} else {
			currentCursor = ARROW
		}

		LM.setCursor(LM.getSystemCursor(currentCursor))
	}

	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]

		if input.type == InputText and input.field.mousemoved!(mx-(input.layoutX+SPACING), my-(input.layoutY+getScrollOffset(input))) {
			updateMouseCursor(state)
			return
		}
	}

	-- Update hovered ID.
	local lastHoveredId    = state.hoveredId
	local lastHoveredSubid = state.hoveredSubid

	local widget = cast(Widget) state.elementsById[state.activeId]
	if not (
		widget ~= NULL
		and (widget.type == Buttons or widget.type == Radio or widget.type == Tabs)
		and (cast(Buttons)widget).buttons[state.activeSubid].draggable
	) {
		local found, ^widget = state.getWidgetAt!(mx, my)

		state.hoveredId    = 0
		state.hoveredSubid = 0

		if found {
			if not state.activeId or widget.id == state.activeId {
				state.hoveredId = widget.id
			}

			local hoveredSubid = 0

			if state.hoveredId  if widget.type == {
				case Tabs:  !through
				case Radio: !through
				case Buttons:
					local buttons = cast(Buttons) widget

					if buttons.vertical
						hoveredSubid = math.clamp(math.floor(1 + (my-buttons.layoutY-getScrollOffset(buttons)) / buttons.buttonHeight), 1, #buttons.buttons)
					else
						hoveredSubid = math.clamp(math.floor(1 + (mx-buttons.layoutX                         ) / buttons.buttonWidth ), 1, #buttons.buttons)

					if not (buttons.buttons and buttons.buttons[hoveredSubid].enabled) {
						state.hoveredId = 0
					}

				case Color:
					local colorEl = cast(Color) widget
					local iFloat  = 1 + (my - (colorEl.layoutY + getScrollOffset(colorEl))) / SLIDER_MIN_THICKNESS
					hoveredSubid  = math.clamp(math.floor(iFloat), 1, (colorEl.alpha ? 4 : 3))
			}

			if not state.activeId or hoveredSubid == state.activeSubid {
				state.hoveredSubid = hoveredSubid
			} else {
				state.hoveredId = 0
			}
		}
	}

	if state.hoveredId and not (state.hoveredId == lastHoveredId and state.hoveredSubid == lastHoveredSubid) {
		widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget.type == {
			case Tabs:  !through
			case Radio: !through
			case Buttons:
				local buttons = cast(Buttons) widget
				local button  = buttons.buttons[state.hoveredSubid]
				triggerMouseEnterEvent(state, buttons, button.name, state.hoveredSubid)
		}
	}

	-- Drag active widget.
	widget = cast(Widget) state.elementsById[state.activeId]

	local mod = getModifierKey()

	if widget ~= NULL  if widget.type == {
		case Slider:
			local slider = cast(Slider) widget

			if state.activeMod == .A {
				-- Change limits.
				if dy {
					local limitMultiplier = math.clamp(getLimitMultiplier(slider) * 0.99 ^ dy, 1e-7, 1e+7)
					setLimitMultiplier(slider, limitMultiplier)
				}

			} else {
				local x1      = slider.layoutX +                      SLIDER_MIN_THICKNESS // 2 + 2
				local x2      = slider.layoutX + slider.layoutWidth - SLIDER_MIN_THICKNESS // 2 - 2
				local value01 = (mx-x1) / (x2-x1)
				value01       = applyExponential(slider, value01, 2)

				local min = applyLimitMultiplier(slider, slider.min)
				local max = applyLimitMultiplier(slider, slider.max)

				-- Snap value to something sensible.
				if mod == .C or mod == .CS {
					local getSnap :: (max:float, stepsCirca:int) -> float {
						-- Not sure if this makes any sense... Math is hard, yo!
						local snapBad = max / stepsCirca * .55 -- 11/16 -- !run math.sqrt(.5)
						local snap    = 1.0

						while snap > snapBad  snap /= 2
						while snap < snapBad  snap *= 2

						return snap
					}

					local range = max - min
					local snap  = getSnap(range, slider.steps)
					local value = min + value01 * range
					value       = math.round(value / snap) * snap
					value01     = (value - min) / range
				}

				-- Get final value.
				local value = math.lerp(min, max, math.clamp01(value01))

				if slider.isInt  value = math.round(value)

				-- Update stored value.
				if begin  triggerBeginEvent(state, slider, "", 0, alsoEnsureEnabled=true)
				if value ~= slider.value {
					slider.value = value
					triggerActionEvent(state, slider, "", 0, .MOUSE)
				}
				if end  triggerEndEvent(state, slider, "", 0)

				-- Update linked sliders.
				if state.activeMod == .S or state.activeMod == .CS {
					for slider.linkMultiDrag {
						local other = cast(Slider) state.elementsByName[it]

						if other ~= NULL and other ~= slider and other.type == Slider and isElementVisible(other) {
							if begin  triggerBeginEvent(state, other, "", 0, alsoEnsureEnabled=true)
							if other.value ~= value {
								other.value = value
								triggerActionEvent(state, other, "", 0, .MOUSE)
							}
							if end  triggerEndEvent(state, other, "", 0)
						}
					}
				}
			}

		case Color:
			local colorEl   = cast(Color) widget
			local component = state.activeSubid
			local value     = (mx-(colorEl.layoutX+2)) / (colorEl.layoutWidth-2*2)

			if mod == .C or mod == .CS {
				local steps = component == 1 ? 24 : 16
				value       = math.round(value*steps)/steps
			}

			value = math.clamp01(value)

			if begin  triggerBeginEvent(state, colorEl, "", component, alsoEnsureEnabled=true)
			if value ~= colorEl.color[component] {
				colorEl.color[component] = value
				triggerActionEvent(state, colorEl, "", component, .MOUSE)
			}
			if end  triggerEndEvent(state, colorEl, "", component)

			if colorEl.linkMultiDrag and (state.activeMod == .S or state.activeMod == .CS) {
				for colorEl.linkMultiDrag {
					local other = cast(Color) state.elementsByName[it]

					if other ~= NULL and other ~= colorEl and other.type == Color and isElementVisible(other) {
						if begin  triggerBeginEvent(state, other, "", component, alsoEnsureEnabled=true)
						if other.color[component] ~= value {
							other.color[component] = value
							triggerActionEvent(state, other, "", component, .MOUSE)
						}
						if end  triggerEndEvent(state, other, "", component)
					}
				}
			}

		case Direction:
			local r :: DIRECTION_RADIUS
			local direction = cast(Direction) widget
			local angle     = math.atan(my - (direction.layoutY + getScrollOffset(direction) + r), mx - (direction.layoutX + r))
			local multiDrag = direction.linkMultiDrag and (state.activeMod == .S or state.activeMod == .CS)

			if mod == .C or mod == .CS {
				local STEPS :: 16
				angle = math.round(angle * STEPS/math.TAU) / STEPS*math.TAU
			}

			if direction.linkOther and not multiDrag {
				local other = cast(Direction) state.elementsByName[direction.linkOther]

				if other ~= NULL and other ~= direction and other.type == Direction {
					-- Allow the angle to go beyond -180°..+180° and use the other widget as limiter instead.
					-- This makes it easy to cover the whole 360° between the two values.
					angle = direction.angle + math.deltaAngle(direction.angle, angle)
					angle = math.clamp(angle, other.angle-math.TAU, other.angle+math.TAU)
				}
			}

			if begin  triggerBeginEvent(state, direction, "", 0, alsoEnsureEnabled=true)
			if angle ~= direction.angle {
				direction.angle = angle
				triggerActionEvent(state, direction, "", 0, .MOUSE)
			}
			if end  triggerEndEvent(state, direction, "", 0)

			if multiDrag {
				for direction.linkMultiDrag {
					local other = cast(Direction) state.elementsByName[it]

					if other ~= NULL and other ~= direction and other.type == Direction and isElementVisible(other) {
						if begin  triggerBeginEvent(state, other, "", 0, alsoEnsureEnabled=true)
						if other.angle ~= angle {
							other.angle = angle
							triggerActionEvent(state, other, "", 0, .MOUSE)
						}
						if end  triggerEndEvent(state, other, "", 0)
					}
				}
			}

		case Scrollable:
			local scrollable = cast(Scrollable) widget
			local handlePos, handleLen, handlePosMax = getScrollbarHandle(scrollable, visual=false)

			local visibleH = scrollable.layoutHeight
			local paddedH  = visibleH - 2*SPACING

			scrollable.scrollTarget = -math.round( ((my + state.scrollbarHandleDragOffset) - scrollable.layoutY) / handlePosMax * (scrollable.contentHeight-paddedH) )
			limitScroll(scrollable)
			scrollable.scroll = scrollable.scrollTarget

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) widget
			local button  = buttons.buttons[state.activeSubid]

			if button.draggable {
				if state.activeDragging {
					triggerDragEvent(state, buttons, button.name, state.activeSubid, mx, my)

				} elseif math.distance(mx,my, state.activeStartMx,state.activeStartMy) > DRAG_RADIUS {
					state.activeDragging = true
					triggerDragBeginEvent(state, buttons, button.name, state.activeSubid)
				}
			}
	}

	-- Update tooltip.
	state.currentTooltip = ""

	if state.hoveredId and not state.activeId {
		widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget.type == Buttons or widget.type == Radio or widget.type == Tabs {
			local buttons        = cast(Buttons) widget
			state.currentTooltip = buttons.buttons[state.hoveredSubid].tooltip

			if buttons.vertical {
				state.tooltipX  = buttons.layoutX
				state.tooltipY1 = math.round(buttons.layoutY + (state.hoveredSubid-1) * buttons.buttonHeight)
				state.tooltipY2 = math.round(buttons.layoutY + (state.hoveredSubid  ) * buttons.buttonHeight)
			} else {
				state.tooltipX  = math.round(buttons.layoutX + (state.hoveredSubid-1) * buttons.buttonWidth)
				state.tooltipY1 = buttons.layoutY
				state.tooltipY2 = buttons.layoutY + buttons.layoutHeight
			}
		}

		if not state.currentTooltip {
			state.currentTooltip = widget.tooltip
			if widget.type ~= Section
				{} -- void
			elseif widget.tooltip
				state.currentTooltip ..= (app.hiddenSections[widget.name] ? " (Click to expand)" : " (Click to collapse)")
			else
				state.currentTooltip   = (app.hiddenSections[widget.name] ?   "Click to expand"  :   "Click to collapse" )

			state.tooltipX  = widget.layoutX
			state.tooltipY1 = widget.layoutY
			state.tooltipY2 = widget.layoutY + widget.layoutHeight
		}

		if state.currentTooltip {
			local offset     = getScrollOffset(widget)
			state.tooltipY1 += offset
			state.tooltipY2 += offset
		}
	}

	if not state.currentTooltip {
		state.tooltipTime = 0
	} else {
		if state.tooltipTime == 0  state.tooltipTime = LT.getTime()
	}

	updateMouseCursor(state)
}

export onMouseReleased :: (state:State, mx,my:int, mbutton:int, presses:int, cancel=false) {
	if state.focusId {
		local input = cast(InputText) state.elementsById[state.focusId]
		if input.type == InputText and input.field.mousereleased!(mx, my, mbutton) {
			state.onMouseMoved!(mx, my, 0, 0)
		}
	}

	-- LMB.
	if mbutton == 1 and state.activeId and not cancel {
		local widget = cast(Widget) state.elementsById[state.activeId]

		if widget ~= NULL  if widget.type == {
			case Buttons:
				if state.hoveredId and not state.activeDragging {
					local buttons = cast(Buttons) widget
					triggerBeginEvent (state, buttons, buttons.buttons[state.activeSubid].name, state.activeSubid, alsoEnsureEnabled=false)
					triggerActionEvent(state, buttons, buttons.buttons[state.activeSubid].name, state.activeSubid, .MOUSE, alsoEnd=true)
				}

			case Radio:
				if state.hoveredId and not state.activeDragging {
					local radio = cast(Radio) widget

					if triggerBeforeActionEvent(state, radio, radio.buttons[state.activeSubid].name, state.activeSubid) {
						-- void
					} elseif radio.index ~= state.hoveredSubid {
						triggerBeginEvent (state, radio, radio.buttons[state.activeSubid].name, state.activeSubid, alsoEnsureEnabled=false)
						radio.index = state.hoveredSubid
						triggerActionEvent(state, radio, radio.buttons[state.activeSubid].name, state.activeSubid, .MOUSE, alsoEnd=true)
					}
				}

			case Tabs:
				if state.hoveredId and not state.activeDragging {
					local tabs = cast(Tabs) widget

					if triggerBeforeActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid) {
						-- void
					} elseif tabs.specialLastTab and state.hoveredSubid == #tabs.buttons {
						triggerBeginEvent (state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, alsoEnsureEnabled=false)
						triggerActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, .MOUSE, alsoEnd=true)
					} elseif tabs.index ~= state.hoveredSubid {
						triggerBeginEvent (state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, alsoEnsureEnabled=false)
						tabs.index = state.hoveredSubid
						triggerActionEvent(state, tabs, tabs.buttons[state.activeSubid].name, state.activeSubid, .MOUSE, alsoEnd=true)
					}
				}

			case Checkbox:
				if state.hoveredId {
					local checkbox = cast(Checkbox) widget

					triggerBeginEvent(state, checkbox, "", 0, alsoEnsureEnabled=false)
					checkbox.checked = not checkbox.checked
					triggerActionEvent(state, checkbox, "", 0, .MOUSE, alsoEnd=true)
				}

			case Slider: !through
			case Color:  !through
			case Direction:
				scheduleSaveWorkspace()

			case Section:
				if state.hoveredId {
					local section = cast(Section) widget

					if app.hiddenSections[section.name]
						app.hiddenSections[section.name] = NULL
					else
						app.hiddenSections[section.name] = true

					scheduleSaveWorkspace()
					state.layoutNeedsUpdate = true
				}
		}
	}

	-- MMB.
	if mbutton == 3 and not state.activeId and state.hoveredId and not cancel {
		local widget = cast(Widget) state.elementsById[state.hoveredId]

		if widget ~= NULL  if widget.type == {
			case Tabs:
				local tabs = cast(Tabs) widget

				if not (tabs.specialLastTab and state.hoveredSubid == #tabs.buttons) {
					triggerCloseEvent(state, tabs, tabs.buttons[state.hoveredSubid].name, state.hoveredSubid)
				}
		}
	}

	-- RMB.
	if mbutton == 2 and not state.activeId and state.hoveredId and not cancel {
		local widget = cast(Widget) state.elementsById[state.hoveredId]
		local name   = ""

		if widget.type == {
			case Tabs:  !through
			case Radio: !through
			case Buttons: name = (cast(Buttons)widget).buttons[state.hoveredSubid].name
		}

		if widget ~= NULL and not triggerOptionEvent(state, widget, name, state.hoveredSubid) {
			local maybeInsertContextMenuItem :: (items:[]string, choiceCount:int, label:string, doInsert:bool) -> (choiceCount:int, choice:int) {
				if not doInsert  return choiceCount, -1
				choiceCount += 1
				insert(items, label)
				return choiceCount, choiceCount
			}

			if widget.type == {
				case Direction:
					local direction = cast(Direction) widget
					local items: []string
					local choiceCount = 0

					local ^choiceCount, choiceReset  = maybeInsertContextMenuItem(items, choiceCount, "Reset angle", true)
					local ^choiceCount, choiceCopy   = maybeInsertContextMenuItem(items, choiceCount, "Copy angle",  true)
					local ^choiceCount, choicePaste  = maybeInsertContextMenuItem(items, choiceCount, "Paste angle", true)
					if direction.canDisable  insert(items, "-")
					local ^choiceCount, choiceToggle = maybeInsertContextMenuItem(items, choiceCount, (direction.enabled ? "Disable" : "Enable"), direction.canDisable)

					state.showContextMenuWithInput!(toString(direction.angle*360/math.TAU), inputTooltip="Degrees", items,
						[*] (choice:int) {
							if choice == choiceReset {
								triggerBeginEvent(state, direction, "", 0, alsoEnsureEnabled=true)
								direction.angle = 0
								triggerActionEvent(state, direction, "", 0, .MOUSE, alsoEnd=true)

							} elseif choice == choiceToggle {
								direction.enabled = not direction.enabled
								triggerToggleEvent(state, direction, "", 0)

							} elseif choice == choiceCopy {
								clipboardAngle    = direction.angle
								hasClipboardAngle = true

							} elseif choice == choicePaste {
								if not hasClipboardAngle  return

								triggerBeginEvent(state, direction, "", 0, alsoEnsureEnabled=true)
								direction.angle = clipboardAngle
								triggerActionEvent(state, direction, "", 0, .MOUSE, alsoEnd=true)
							}
						},
						[*] (text:string) {
							commitValueFromInput(state, direction, text)
						}
					)

				case Slider:
					local slider = cast(Slider) widget
					local items: []string
					local choiceCount = 0

					local ^choiceCount, choiceReset       = maybeInsertContextMenuItem(items, choiceCount, "Reset value", true)
					local ^choiceCount, choiceCopy        = maybeInsertContextMenuItem(items, choiceCount, "Copy value",  true)
					local ^choiceCount, choicePaste       = maybeInsertContextMenuItem(items, choiceCount, "Paste value", true)
					insert(items, "-")
					local ^choiceCount, choiceResetLimits = maybeInsertContextMenuItem(items, choiceCount, "Reset min/max limits", true)
					if slider.canDisable  insert(items, "-")
					local ^choiceCount, choiceToggle      = maybeInsertContextMenuItem(items, choiceCount, (slider.enabled ? "Disable" : "Enable"), slider.canDisable)

					state.showContextMenuWithInput!(toString(slider.value*slider.readoutMulti), items,
						[*] (choice:int) {
							if choice == choiceReset {
								triggerBeginEvent(state, slider, "", 0, alsoEnsureEnabled=true)
								slider.value = slider.defaultValue
								triggerActionEvent(state, slider, "", 0, .MOUSE, alsoEnd=true)

							} elseif choice == choiceToggle {
								slider.enabled = not slider.enabled
								triggerToggleEvent(state, slider, "", 0)

							} elseif choice == choiceCopy {
								clipboardScalar    = slider.value
								hasClipboardScalar = true

							} elseif choice == choicePaste {
								if not hasClipboardScalar  return

								triggerBeginEvent(state, slider, "", 0, alsoEnsureEnabled=true)
								slider.value = clipboardScalar
								triggerActionEvent(state, slider, "", 0, .MOUSE, alsoEnd=true)

							} elseif choice == choiceResetLimits {
								forgetLimitMultiplier(slider)
							}
						},
						[*] (text:string) {
							commitValueFromInput(state, slider, text)
						}
					)

				case Color:
					local COMPONENT_TITLES: Table(int, string) : {
						[1] = "hue",
						[2] = "saturation",
						[3] = "value strength",
						[4] = "opacity",
					}

					local colorEl   = cast(Color) widget
					local component = state.hoveredSubid
					local valueStr  = toString(colorEl.color[component] * (component == 1 ? 360 : 100))

					-- @Incomplete: Handle canDisable.
					local items: []string
					local choiceCount = 0

					local ^choiceCount, choiceResetColor     = maybeInsertContextMenuItem(items, choiceCount, "Reset color",                         true)
					local ^choiceCount, choiceCopyComponent  = maybeInsertContextMenuItem(items, choiceCount, "Copy "..COMPONENT_TITLES[component],  true)
					local ^choiceCount, choiceCopyColor      = maybeInsertContextMenuItem(items, choiceCount, "Copy color",                          true)
					local ^choiceCount, choicePasteComponent = maybeInsertContextMenuItem(items, choiceCount, "Paste "..COMPONENT_TITLES[component], true)
					local ^choiceCount, choicePasteColor     = maybeInsertContextMenuItem(items, choiceCount, "Paste color",                         true)

					state.showContextMenuWithInput!(valueStr, items,
						[*] (choice:int) {
							if choice == choiceResetColor {
								for 1, 4 {
									triggerBeginEvent(state, colorEl, "", it, alsoEnsureEnabled=true)
									colorEl.color[it] = (it <= 2) ? 0 : 1
									triggerActionEvent(state, colorEl, "", it, .MOUSE, alsoEnd=true)
								}

							} elseif choice == choiceCopyComponent {
								clipboardScalar    = colorEl.color[component]
								hasClipboardScalar = true

							} elseif choice == choiceCopyColor {
								for 1, 4  clipboardColor[it] = colorEl.color[it]
								hasClipboardColor = true

							} elseif choice == choicePasteComponent {
								if not hasClipboardScalar  return

								triggerBeginEvent(state, colorEl, "", component, alsoEnsureEnabled=true)
								colorEl.color[component] = clipboardScalar
								triggerActionEvent(state, colorEl, "", component, .MOUSE, alsoEnd=true)

							} elseif choice == choicePasteColor {
								if not hasClipboardColor  return

								for 1, 4 {
									triggerBeginEvent(state, colorEl, "", it, alsoEnsureEnabled=true)
									colorEl.color[it] = clipboardColor[it]
									triggerActionEvent(state, colorEl, "", it, .MOUSE, alsoEnd=true)
								}
							}
						},
						[*] (text:string) {
							commitValueFromInput(state, colorEl, component, text)
						}
					)
			}
		}
	}

	-- Release active ID.
	if state.activeId and (mbutton == 1 or cancel) {
		if state.elementsById[state.activeId] ~= NULL  state.onMouseMoved!(mx, my, 0, 0, end=true)

		if state.activeDragging {
			local widget = cast(Widget) state.elementsById[state.activeId]

			if widget.type == {
				case Tabs:  !through
				case Radio: !through
				case Buttons:
					local buttons = cast(Buttons) widget
					local button  = buttons.buttons[state.activeSubid]
					triggerDragEndEvent(state, buttons, button.name, state.activeSubid)

				case:
					log("Error: triggerDragEndEvent: Unhandled element type '%d'.", widget.type)
					triggerDragEndEvent(state, widget, "", state.activeSubid)
			}

			scheduleSaveWorkspace()
		}

		state.activeId       = 0
		state.activeSubid    = 0
		state.activeDragging = false

		LM.setGrabbed(false)
		LK.setKeyRepeat(true)

		state.onMouseMoved!(mx, my, 0, 0)
	}
}

export cancelMouseActions :: (state:State) {
	if state.activeId {
		local mx, my = LM.getPosition()
		state.onMouseReleased!(mx, my, 1, 0, cancel=true)

		state.activeId    = 0
		state.activeSubid = 0
	}
}

export onMouseWheel :: (state:State, dx,dy:int) -> (handled:bool) {
	if state.activeId  return true
	if getModifierKey() ~= .NONE  return false

	updateLayoutIfNeeded(state)

	local mx, my = LM.getPosition()

	local found, el = state.getElementAt!(mx, my)
	while not (el == NULL or el.type == Scrollable) {
		el = el.parent
	}

	if el ~= NULL {
		local scrollable        = cast(Scrollable) el
		local maxDy             = math.max(scrollable.layoutHeight - 2 * (SCROLLABLE_PADDING + SPACING), 10)
		scrollable.scrollSource = scrollable.scroll
		scrollable.scrollTarget = scrollable.scrollTarget + math.clamp(50*dy, -maxDy, maxDy)
		limitScroll(scrollable)
		return true
	}

	return false
}

export onFocus :: (state:State, hasFocus:bool) {
	if not hasFocus  state.hideContextMenu!()
}



local calculateNaturalSize :: (state:State, el:Element) {
	for el  if it.active {
		calculateNaturalSize(state, it)
	}

	if el.type == {
		case Frame:
			local frame    = cast(Frame) el
			local contentW = 0
			local contentH = 0

			for frame  if it.active {
				contentW  = math.max(contentW, it.layoutWidth)
				contentH += it.layoutHeight + SPACING
			}

			frame.layoutWidth  = contentW + 2*SPACING
			frame.layoutHeight = contentH + SPACING

		case Scrollable:
			local scrollable = cast(Scrollable) el
			local contentH   = 0

			for scrollable  if it.active {
				contentH += it.layoutHeight + SPACING
			}

			scrollable.layoutWidth   = SCROLLBAR_WIDTH
			scrollable.contentHeight = contentH - SPACING + 2*SCROLLABLE_PADDING

			if scrollable.height > 0 {
				scrollable.layoutHeight = scrollable.height
			} else {
				scrollable.layoutHeight     = math.max(state.extraScrollableSpace + scrollable.height, 0)
				state.extraScrollableSpace -= scrollable.layoutHeight
			}

		case Section:
			local section = cast(Section) el

			if app.hiddenSections[section.name] {
				section.layoutWidth  = section.labelWidth + (section.icon16 ? 16 : 0)
				section.layoutHeight = math.max(fontNormal.getHeight!(), (section.icon16 ? 16 : 0))

			} else {
				local contentW = 0
				local contentH = 0

				if not app.hiddenSections[section.name] {
					for section  if it.active {
						contentW  = math.max(contentW, it.layoutWidth)
						contentH += it.layoutHeight + SPACING
					}
				}

				local sectionSideHeight = (section.label ? fontNormal.getHeight!() : 0) + (section.icon16 ? 16+SPACING : 0)

				section.layoutWidth  = section.labelWidth + contentW
				section.layoutHeight = math.max(contentH-SPACING, sectionSideHeight)
			}

		case Hbox:
			local hbox     = cast(Hbox) el
			local contentW = 0
			local contentH = 0

			for hbox  if it.active {
				contentW += it.layoutWidth + SPACING
				contentH  = math.max(contentH, it.layoutHeight)
			}

			hbox.layoutWidth  = contentW - SPACING
			hbox.layoutHeight = contentH

		case Vbox:
			local vbox     = cast(Vbox) el
			local contentW = 0
			local contentH = 0

			for vbox  if it.active {
				contentW  = math.max(contentW, it.layoutWidth)
				contentH += it.layoutHeight + SPACING
			}

			vbox.layoutWidth  = contentW
			vbox.layoutHeight = contentH - SPACING

		case Text:
			local textEl        = cast(Text) el
			local font          = textEl.size == 3 ? fontLarge : textEl.size == 1 ? fontSmall : fontNormal
			local fontH         = font.getHeight!()
			local lineCount     = textEl.textLines ? #textEl.textLines : 1 + countString(textEl.text, "\n")
			textEl.textHeight   = math.ceil(fontH + (lineCount-1) * fontH * font.getLineHeight!())
			textEl.layoutHeight = textEl.textHeight

			if textEl.textLines {
				local w = 0
				for textEl.textLines  w = math.max(w, font.getWidth!(it))
				textEl.layoutWidth = w + (textEl.size == 3 ? 1 : 0)
			} else {
				textEl.layoutWidth = font.getWidth!(textEl.text) + (textEl.size == 3 ? 1 : 0)
			}

		case Separator:
			local separator        = cast(Separator) el
			separator.layoutWidth  = 0
			separator.layoutHeight = separator.thick ? 5 : 1

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons    = cast(Buttons) el
			local buttonMaxW = 0
			local buttonMaxH = buttons.buttonMinHeight

			for buttons.buttons {
				local w: int = NULL
				local h: int = NULL

				it.labelWidth    = fontNormal.getWidth!(it.label)
				it.suffixWidth   = fontNormal.getWidth!(it.suffix)
				it.shortcutWidth = it.shortcut ? fontNormal.getWidth!(it.shortcut) + SPACING_LARGE : 0

				if it.system ~= NULL {
					w             = PARTICLE_PREVIEW_SIZE
					h             = PARTICLE_PREVIEW_SIZE
				} elseif (it.label or it.suffix or it.shortcut) and it.image {
					w, h          = guiImages[it.image].getDimensions!()
					it.imageScale = math.min(BUTTON_IMAGE_MAX_SIZE/w, BUTTON_IMAGE_MAX_SIZE/h, 1)
					w             = math.round(w*it.imageScale) + SPACING + it.labelWidth+it.suffixWidth+it.shortcutWidth
					h             = math.max(math.round(h*it.imageScale), fontNormal.getHeight!())
				} elseif it.image {
					w, h          = guiImages[it.image].getDimensions!()
					it.imageScale = math.min(BUTTON_IMAGE_MAX_SIZE/w, BUTTON_IMAGE_MAX_SIZE/h, 1)
					w             = math.round(w*it.imageScale)
					h             = math.round(h*it.imageScale)
				} else {
					w             = it.labelWidth + it.suffixWidth + it.shortcutWidth
					h             = fontNormal.getHeight!()
				}

				w               += buttons.buttonPaddingRight
				it.contentWidth  = w

				buttonMaxW = math.max(buttonMaxW, w)
				buttonMaxH = math.max(buttonMaxH, h)
			}

			if buttons.vertical {
				buttons.layoutWidth  = buttonMaxW + 2*SPACING
				buttons.layoutHeight = #buttons.buttons * (buttonMaxH + 2*BUTTON_PADDING_Y)
			} else {
				buttons.layoutWidth  = #buttons.buttons * (buttonMaxW + 2*SPACING)
				buttons.layoutHeight = buttonMaxH + 2*BUTTON_PADDING_Y
			}

		case Checkbox:
			local checkbox        = cast(Checkbox) el
			checkbox.layoutWidth  = CHECKBOX_SIZE + SPACING + fontSmall.getWidth!(checkbox.label) + SPACING_LARGE
			checkbox.layoutHeight = math.max(CHECKBOX_SIZE, fontSmall.getHeight!())

		case InputText:
			local input = cast(InputText) el
			input.layoutWidth  = INPUT_MIN_WIDTH
			input.layoutHeight = fontNormal.getHeight!() + 2*SPACING

		case Slider:
			local slider        = cast(Slider) el
			slider.layoutWidth  = SLIDER_MIN_LENGTH
			slider.layoutHeight = SLIDER_MIN_THICKNESS

		case Color:
			local colorEl        = cast(Color) el
			colorEl.layoutWidth  = SLIDER_MIN_LENGTH
			colorEl.layoutHeight = (colorEl.alpha ? 4 : 3) * SLIDER_MIN_THICKNESS

		case ColorPreview:
			local preview        = cast(ColorPreview) el
			preview.layoutWidth  = COLOR_PREVIEW_WIDTH
			preview.layoutHeight = 0

		case Direction:
			local direction        = cast(Direction) el
			direction.layoutWidth  = 2*DIRECTION_RADIUS
			direction.layoutHeight = 2*DIRECTION_RADIUS

		case Canvas:
			local canvasEl        = cast(Canvas) el
			canvasEl.layoutWidth  = 10
			canvasEl.layoutHeight = 10

		case: errorf("%d", el.type)
	}

	if el.width                             el.layoutWidth  = el.width
	if el.height and el.type ~= Scrollable  el.layoutHeight = el.height

	el.layoutWidth  = math.max(el.layoutWidth,  el.minWidth)
	el.layoutHeight = math.max(el.layoutHeight, el.minHeight)
	if el.maxWidth  >= 0  el.layoutWidth  = math.min(el.layoutWidth,  el.maxWidth)
	if el.maxHeight >= 0  el.layoutHeight = math.min(el.layoutHeight, el.maxHeight)

	-- The following count as outside the element, even though they take space as if they were part of the element.
	-- el.layoutWidth += el.inset
	if el.type == Tabs  el.layoutHeight += TAB_BOTTOM_LINE_WIDTH
}

local positionAndFit :: (state:State, el:Element, x,y,w,h:int) {
	local positionAndFitChildrenV :: (state:State, el:Element, x,y,w,h:int) {
		for el  if it.active {
			positionAndFit(state, it, x+it.inset, y, w-it.inset, it.layoutHeight)
			y += it.layoutHeight + SPACING
		}
	}
	local positionAndFitChildrenH :: (state:State, el:Element, x,y,w,h:int) {
		for el  if it.active {
			x += it.inset
			positionAndFit(state, it, x, y, it.layoutWidth, h)
			x += it.layoutWidth + SPACING
		}
	}

	-- x += el.inset
	-- w -= el.inset
	if el.type == Tabs  h -= TAB_BOTTOM_LINE_WIDTH

	el.layoutX      = x
	el.layoutY      = y
	el.layoutWidth  = w
	el.layoutHeight = h

	if el.type == {
		case Frame:
			local frame = cast(Frame) el

			if !complete frame.layout == {
				case .DOCKED:
					x = 0
					y = 0
				case .FLOATING:
					x = frame.x >= 0 ? frame.x : (LG.getWidth()  - w) // 2
					y = frame.y >= 0 ? frame.y : (LG.getHeight() - h) // 2
			}

			frame.layoutX = x
			frame.layoutY = y

			x += SPACING
			y += SPACING
			w -= 2*SPACING

			positionAndFitChildrenV(state, frame, x, y, w, h)

		case Scrollable:
			local scrollable = cast(Scrollable) el

			y += SPACING + SCROLLABLE_PADDING
			w -= SCROLLBAR_WIDTH + SPACING

			positionAndFitChildrenV(state, scrollable, x, y, w, h)

		case Section:
			local section = cast(Section) el

			x += section.labelWidth
			w -= section.labelWidth

			if not app.hiddenSections[section.name]  positionAndFitChildrenV(state, section, x, y, w, h)

		case Hbox:
			local hbox         = cast(Hbox) el
			local dynamicSpace = w
			local weight       = .0
			local activeCount  = 0

			for hbox  if it.active {
				activeCount  += 1
				dynamicSpace -= it.inset

				if it.weight {
					weight += it.weight
				} else {
					dynamicSpace -= it.layoutWidth
				}
			}

			if weight {
				dynamicSpace -= (activeCount-1) * SPACING

				for hbox  if it.active and it.weight {
					it.layoutWidth  = math.max(math.round(dynamicSpace * it.weight / weight), 1)
					dynamicSpace   -= it.layoutWidth
					weight         -= it.weight
				}
			}

			positionAndFitChildrenH(state, hbox, x, y, w, h)

		case Vbox:
			local vbox         = cast(Vbox) el
			local dynamicSpace = h
			local weight       = .0
			local activeCount  = 0

			for vbox  if it.active {
				activeCount += 1
				if it.weight
					weight += it.weight
				else
					dynamicSpace -= it.layoutHeight
			}

			if weight {
				dynamicSpace -= (activeCount-1) * SPACING

				for vbox  if it.active and it.weight {
					it.layoutHeight  = math.round(dynamicSpace * it.weight / weight)
					dynamicSpace    -= it.layoutHeight
					weight          -= it.weight
				}
			}

			positionAndFitChildrenV(state, vbox, x, y, w, h)

		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) el
			if buttons.vertical {
				buttons.buttonWidth  = w
				buttons.buttonHeight = h / #buttons.buttons
			} else {
				buttons.buttonWidth  = w / #buttons.buttons
				buttons.buttonHeight = h
			}

		case Tabs:
			local tabs = cast(Tabs) el
			tabs.buttonWidth
				= tabs.specialLastTab
				? (w-SPECIAL_TAB_WIDTH) / (#tabs.buttons-1)
				: (w                  ) / (#tabs.buttons  )

		case Color:
			local colorEl       = cast(Color) el
			colorEl.sliderWidth = h / (colorEl.alpha ? 4 : 3)

		case InputText:
			local input = cast(InputText) el
			if input.field ~= NULL  input.field.setWidth!(w - 2*SPACING)
	}
}

export updateLayout :: updateLayoutIfNeeded

local updateLayoutIfNeeded :: (state:State) {
	if not state.layoutNeedsUpdate  return
	state.layoutNeedsUpdate = false

	-- log("Updating layout.")

	local updateParents :: (el:Element, frame:Frame, parent:Element) {
		el.frame  = frame
		el.parent = parent
		for el  updateParents(it, frame, el)
	}
	for state.frames  updateParents(it, it, NULL)

	for state.frames  if it.active {
		state.extraScrollableSpace = 0
		calculateNaturalSize(state, it)

		do {
			-- We need to do calculateNaturalSize() twice to know how much scrollables can expand the frame.
			-- Note: If there are multiple scrollables with height<=0 then things may or may not work as expected!
			state.extraScrollableSpace = LG.getHeight() - it.layoutHeight -- layoutNeedsUpdate better be set if the window resizes!
			if it.layout == .FLOATING  state.extraScrollableSpace -= 2*SPACING_LARGE

			calculateNaturalSize(state, it)
		}

		positionAndFit(state, it, 0, 0, it.layoutWidth, it.layoutHeight)
	}

	for state.scrollables  limitScroll(it)

	local mx, my = LM.getPosition()
	if state.isOverGui!(mx, my)  state.onMouseMoved!(mx, my, 0, 0)
}



export update :: (state:State, dt:float) {
	local anyScrolling = false

	for state.scrollables {
		local targetReached: bool = NULL

		it.scroll, targetReached = math.moveTowards(
			it.scroll,
			it.scrollTarget,
			math.abs(it.scrollTarget - it.scrollSource) * dt / 0.05
		)
		if not targetReached  anyScrolling = true
	}

	if anyScrolling {
		local mx, my = LM.getPosition()
		state.onMouseMoved!(mx, my, 0, 0)
	}

	if state.focusId {
		local widget = cast(Widget) state.elementsById[state.focusId]

		if widget.type == InputText {
			local input = cast(InputText) widget
			input.field.update!(dt)
		}
	}

}



local drawElement :: (state:State, el:Element) {
	local drawChildren :: (state:State, el:Element) {
		for el {
			if it.active  drawElement(state, it)
		}
	}

	if state.onDrawBackground[el.name] ~= NULL {
		triggerDrawBackgroundEvent(state, el, el.layoutX, el.layoutY, getScrollOffset(el), el.layoutWidth, el.layoutHeight)
	}

	if el.labelLeft {
		local opacity = (el.enabled ? 1 : DISABLED_OPACITY)
		local textY: int

		if el.labelLeftAlign == {
			case .TOP:    textY = el.layoutY
			case .BOTTOM: textY = el.layoutY + (el.layoutHeight - fontSmall.getHeight!())
			case:         textY = el.layoutY + (el.layoutHeight - fontSmall.getHeight!()) // 2
		}

		LG.setFont(fontSmall)
		LG.setColor(1, 1, 1, TEXT_OPACITY*opacity)
		LG.print(el.labelLeft, el.layoutX-SPACING-fontSmall.getWidth!(el.labelLeft), textY)
		LG.setFont(fontNormal)
	}

	if el.type == {
		case Frame:
			local frame = cast(Frame) el

			local x = frame.layoutX
			local y = frame.layoutY
			local w = frame.layoutWidth
			local h = frame.layoutHeight

			if frame.layout == .FLOATING and frame.modal {
				local BORDER :: 10
				LG.setColor(.1, .1, .1, .9)
				LG.rectangle(LG.DrawMode.FILL, x-BORDER, y-BORDER, w+2*BORDER, h+2*BORDER, SPACING+BUTTON_RADIUS+BORDER)
			}

			if frame.style == .CONTEXT_MENU {
				LG.setColor(0, 0, 0, .6)
				drawBoxGradient(x, y, w, h)
			}

			if frame.style == .CONTEXT_MENU
				LG.setColor(.7, .7, .7)
			else
				LG.setColor(.2, .2, .2)

			if frame.style == .CONTEXT_MENU
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
			elseif frame.layout == .FLOATING
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h, SPACING+BUTTON_RADIUS)
			else
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h)

			if frame.style == .CONTEXT_MENU {
				LG.setColor(.1, .1, .1)
				LG.rectangle(LG.DrawMode.LINE, x+.5, y+.5, w-1, h-1)
			}

			LG.pushAll()
			intersectScissor(x, y, w, h)
			drawChildren(state, frame)
			LG.pop()

		case Scrollable:
			local scrollable = cast(Scrollable) el

			local x = scrollable.layoutX
			local y = scrollable.layoutY
			local w = scrollable.layoutWidth
			local h = scrollable.layoutHeight

			LG.pushAll()
			LG.translate(0, scrollable.scroll)
			intersectScissor(x-SPACING, y, w+SPACING, h)
			drawChildren(state, scrollable)
			LG.pop()

			-- Shadow.
			do {
				local shadowH = math.min((scrollable.scroll ? 30 : 10), math.round(.4*scrollable.layoutHeight))
				local iw, ih  = imageGradient.getDimensions!()
				local sx      = shadowH / ih
				local sy      = (w + SPACING - SCROLLBAR_WIDTH) / iw

				LG.setColor(0, 0, 0, (scrollable.scroll ? 1 : .3))
				LG.draw(imageGradient, x-SPACING, y+shadowH, -math.TAU/4, sx, sy)
			}

			-- Scrollbar.
			do {
				local handlePos, handleLen, handlePosMax = getScrollbarHandle(scrollable, visual=true)

				local barX = x + w - SCROLLBAR_WIDTH
				local barY = y + handlePos

				LG.setColor(0, 0, 0, .3)
				LG.rectangle(LG.DrawMode.FILL, barX, y, SCROLLBAR_WIDTH, h)

				if scrollable.id == state.activeId
					LG.setColor(1, 1, 1, .30)
				elseif scrollable.id == state.hoveredId
					LG.setColor(1, 1, 1, .45)
				else
					LG.setColor(1, 1, 1, .15)

				LG.rectangle(LG.DrawMode.FILL, barX+1, barY+1, SCROLLBAR_WIDTH-2, handleLen-2, SCROLLBAR_WIDTH//2-1)
			}

			-- Single-child focus.
			if #scrollable == 1 and scrollable[1].id == state.focusId {
				LG.setColor(COLOR_FOCUS)
				LG.rectangle(LG.DrawMode.LINE, x-SPACING+.5, y+.5, w+SPACING-1, h-1)
			}

		case Section:
			local section = cast(Section) el
			local hidden  = app.hiddenSections[section.name]
			local font    = fontNormal--hidden ? fontSmall : fontNormal

			if section.id == state.hoveredId {
				local x = section.layoutX - SPACING
				local y = section.layoutY - BUTTON_PADDING_Y
				local w = font.getWidth!(section.label) + 2*SPACING
				local h = font.getHeight!() + 2*BUTTON_PADDING_Y
				LG.setColor(1, 1, 1, .45)
				LG.rectangle(LG.DrawMode.FILL, x, y, w, h, BUTTON_RADIUS)
			}

			if section.icon16 {
				local x, y: int
				if hidden {
					x = section.layoutX + section.labelWidth
					y = section.layoutY
				} else {
					x = section.layoutX
					y = section.layoutY + section.layoutHeight - 16
				}
				LG.setColor(1, 1, 1, .15)
				LG.draw(imageIcons16, icon16Quads[section.icon16], x, y)
			}

			if section.label {
				LG.setFont(font)
				LG.setColor(1, 1, 1, TEXT_OPACITY)
				LG.print(section.label, section.layoutX, section.layoutY)
				LG.setFont(fontNormal)
			}

			if not hidden  drawChildren(state, section)

		case Hbox:
			local hbox = cast(Hbox) el
			drawChildren(state, hbox)

		case Vbox:
			local vbox = cast(Vbox) el
			drawChildren(state, vbox)

		case Text:
			local textEl = cast(Text) el
			local font   = textEl.size == 3 ? fontLarge : textEl.size == 1 ? fontSmall : fontNormal
			local textY  = textEl.layoutY + (textEl.layoutHeight - textEl.textHeight) // 2

			LG.pushAll()
			intersectScissor(textEl.layoutX, 0, textEl.layoutWidth, LG.getHeight())

			LG.setFont(font)
			LG.setColor(1, 1, 1, TEXT_OPACITY)

			if textEl.textLines {
				local lineDist = math.round(font.getHeight!() * font.getLineHeight!())
				for textEl.textLines {
					LG.print(it, textEl.layoutX, textY)
					textY += lineDist
				}
			} else {
				LG.print(textEl.text, textEl.layoutX, textY)
				if textEl.size == 3  LG.print(textEl.text, textEl.layoutX+1, textY)
			}

			LG.pop()

		case Separator:
			local separator = cast(Separator) el
			LG.setColor(0, 0, 0, (separator.thick ? .3 : .2))
			LG.rectangle(LG.DrawMode.FILL, separator.layoutX-SPACING, separator.layoutY, separator.layoutWidth+2*SPACING, separator.layoutHeight)

		case Tabs:  !through
		case Radio: !through
		case Buttons:
			local buttons = cast(Buttons) el
			local radio   = cast(Radio)   el
			local tabs    = cast(Tabs)    el

			local isRadio = el.type == Radio
			local isTabs  = el.type == Tabs

			local focused = (buttons.id == state.focusId)

			local x = buttons.layoutX
			local y = buttons.layoutY
			local w = buttons.layoutWidth
			local h = buttons.layoutHeight

			local paddingX = isTabs ? 9 : SPACING

			local bx1:   []int  : {}
			local bx2:   []int  : {}
			local by1:   []int  : {}
			local by2:   []int  : {}
			local bw:    []int  : {}
			local bh:    []int  : {}
			local faded: []bool : {}

			-- Backgrounds.
			for buttons.buttons {
				if buttons.vertical {
					bx1[itIndex] = x
					bx2[itIndex] = x + w
					by1[itIndex] = math.round(y + buttons.buttonHeight*(itIndex-1))
					by2[itIndex] = math.round(y + buttons.buttonHeight*(itIndex  ))
					by2[itIndex] = math.min(by2[itIndex], y + h)
				} else {
					bx1[itIndex] = math.round(x + buttons.buttonWidth*(itIndex-1))
					bx2[itIndex] = math.round(x + buttons.buttonWidth*(itIndex  ))
					bx2[itIndex] = math.min(bx2[itIndex], x + w)
					by1[itIndex] = y
					by2[itIndex] = y + h
				}
				bw[itIndex]    = bx2[itIndex] - bx1[itIndex]
				bh[itIndex]    = by2[itIndex] - by1[itIndex]
				faded[itIndex] = false

				if it.selected {
					if focused
						LG.setColor(COLOR_FOCUS)
					else
						LG.setColor(1, 1, 1, .3)
					local extraW = (not buttons.vertical and itIndex > 1) ? 1 : 0
					local extraH = (    buttons.vertical and itIndex > 1) ? 1 : 0
					LG.rectangle(LG.DrawMode.FILL, bx1[itIndex]+1-extraW, by1[itIndex]+1-extraH, bw[itIndex]-2+extraW, bh[itIndex]-2+extraH, BUTTON_RADIUS)
				}

				local showBg = true

				if not (buttons.id == state.hoveredId and itIndex == state.hoveredSubid) {
					faded[itIndex] = (isRadio or isTabs) and radio.index ~= itIndex
					if buttons.style ~= .NORMAL or not it.enabled
						showBg = false
					elseif faded[itIndex]
						LG.setColor(1, 1, 1, .1)
					else
						LG.setColor(1, 1, 1, .3)
				} elseif not (buttons.id == state.activeId and itIndex == state.activeSubid) {
					LG.setColor(1, 1, 1, .45)
				} else {
					LG.setColor(0, 0, 0, .5)
				}

				if not showBg {
					-- void
				} elseif isTabs {
					local topInset = math.min(.3*bh[itIndex], bw[itIndex]/4)
					LG.polygon(LG.DrawMode.FILL,
						bx1[itIndex],          by2[itIndex],
						bx1[itIndex]+topInset, by1[itIndex],
						bx2[itIndex]-topInset, by1[itIndex],
						bx2[itIndex],          by2[itIndex]
					)
				} else {
					local extraW = (not buttons.vertical and itIndex > 1) ? 1 : 0
					local extraH = (    buttons.vertical and itIndex > 1) ? 1 : 0
					LG.rectangle(LG.DrawMode.FILL, bx1[itIndex]+1-extraW, by1[itIndex]+1-extraH, bw[itIndex]-2+extraW, bh[itIndex]-2+extraH, BUTTON_RADIUS)
				}
			}

			-- Tab bottom line.
			if isTabs {
				LG.setColor(1, 1, 1, .3)
				LG.rectangle(LG.DrawMode.FILL, tabs.frame.layoutX, y+h, tabs.frame.layoutWidth, TAB_BOTTOM_LINE_WIDTH) -- Assume we haven't translated on the x axis.
				-- LG.rectangle(LG.DrawMode.FILL, x-SPACING, y+h, w+2*SPACING, TAB_BOTTOM_LINE_WIDTH)
			}

			-- Images.
			for buttons.buttons  if it.image {
				local image  = guiImages[it.image]
				local iw, ih = image.getDimensions!()

				local imageX: int = NULL

				if buttons.align == {
					case .LEFT:  imageX = bx1[itIndex] + paddingX
					case .RIGHT: imageX = bx1[itIndex] + math.max(math.round(bw[itIndex] - paddingX - it.contentWidth), paddingX)
					case:        imageX = bx1[itIndex] + math.max((bw[itIndex] - it.contentWidth) // 2,                 paddingX)
				}

				if not it.enabled
					LG.setColor(1, 1, 1, .6)
				else
					LG.setColor(1, 1, 1, 1)

				LG.draw(image,
					imageX,
					by1[itIndex] + bh[itIndex] // 2,
					0, it.imageScale, it.imageScale, 0, ih/2
				)
			}

			-- Particle previews.
			--
			-- @Cleanup: All this is a bit misplaced in the GUI. Maybe provide an onDraw
			-- event for elements so systems and projects can stay outside this file.
			-- (Update: We now have gui.Canvas! Except this is on a Button...)
			--
			local PREVIEW_SCALE :: 2.5
			local project = app.projects[app.currentProjectIndex]
			local scale   = PREVIEW_SCALE * PARTICLE_PREVIEW_SIZE / math.min(LG.getWidth() - MAIN_PANEL_WIDTH, LG.getHeight()) * project.zoom
			local r, g, b = hsvToRgb(project.bgColor)

			for buttons.buttons  if it.system ~= NULL {
				local system = it.system

				if system.visible {
					local emitterX, emitterY: float

					if project.movementPreset == .NONE {
						emitterX, emitterY = system.particles.getPosition!()
					}

					LG.pushAll()
					intersectScissor(
						bx1[itIndex] + (bw[itIndex] - PARTICLE_PREVIEW_SIZE) // 2,
						by1[itIndex] + (bh[itIndex] - PARTICLE_PREVIEW_SIZE) // 2 + getScrollOffset(buttons),
						PARTICLE_PREVIEW_SIZE,
						PARTICLE_PREVIEW_SIZE
					)

					LG.clear(r, g, b)
					if system.currentShader ~= NULL  LG.setShader(system.currentShader.shader)
					LG.setBlendMode(system.blendMode)
					LG.setColor(1, 1, 1)

					LG.draw(system.particles,
						bx1[itIndex] + bw[itIndex]/2 - emitterX*scale,
						by1[itIndex] + bh[itIndex]/2 - emitterY*scale,
						0, scale
					)

					LG.pop()
				}

				if system.title {
					local scissorX1 = bx1[itIndex] + (paddingX-1)
					local scissorX2 = bx2[itIndex] - (paddingX-1)

					if scissorX2 > scissorX1 {
						local textY = by1[itIndex] + (bh[itIndex] - fontNormal.getHeight!()) // 2
						local textX = bx1[itIndex] + math.max((bw[itIndex] - fontNormal.getWidth!(system.title)) // 2, paddingX)

						LG.pushAll()
						intersectScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
						LG.setColor(0, 0, 0, .7)
						LG.print(system.title, textX+1, textY+1)
						LG.setColor(1, 1, 1)
						LG.print(system.title, textX, textY)
						LG.pop()
					}
				}
			}

			-- Submenu icons.
			LG.setColor(0, 0, 0)

			for buttons.buttons  if it.submenuIcon {
				local iw, ih = guiImages.iconSubmenu.getDimensions!()
				LG.draw(guiImages.iconSubmenu, bx2[itIndex]-iw-1, by1[itIndex]+(bh[itIndex]-ih)//2)
			}

			-- Custom.
			if state.onDraw[el.name] ~= NULL {
				triggerDrawEvent(state, el, el.layoutX, el.layoutY, getScrollOffset(el), el.layoutWidth, el.layoutHeight)
			}

			-- Labels.
			for buttons.buttons  if it.label or it.suffix or it.shortcut {
				local scissorX1 = bx1[itIndex] + (paddingX-1)
				local scissorX2 = bx2[itIndex] - (paddingX-1)

				if scissorX2 > scissorX1 {
					local textY = by1[itIndex] + (bh[itIndex] - fontNormal.getHeight!()) // 2
					local textX: int = NULL

					if buttons.align == {
						case .LEFT:  textX = bx1[itIndex] + paddingX
						case .RIGHT: textX = bx1[itIndex] + math.max(math.round(bw[itIndex] - paddingX - it.contentWidth), paddingX)
						case:        textX = bx1[itIndex] + math.max((bw[itIndex] - it.contentWidth) // 2,                 paddingX)
					}

					if it.image {
						local iw  = guiImages[it.image].getWidth!()
						textX    += math.round(iw*it.imageScale + SPACING)
					}

					local grey, a: float
					if not it.enabled
						grey, a = 1, .6
					elseif faded[itIndex]
						grey, a = 1, .8
					elseif buttons.style == .CONTEXT_MENU
						grey, a = 0, 1
					else
						grey, a = 1, 1

					LG.pushAll()
					intersectScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
					if it.label {
						LG.setColor(grey, grey, grey, TEXT_OPACITY*a)
						LG.print(it.label, textX, textY)
					}
					if it.suffix {
						LG.setColor(grey, grey, grey, TEXT_OPACITY*a*.6)
						LG.print(it.suffix, textX+it.labelWidth, textY)
					}
					if it.shortcut {
						LG.setColor(grey, grey, grey, TEXT_OPACITY*a)
						LG.print(it.shortcut, bx2[itIndex]-paddingX-it.shortcutWidth+SPACING_LARGE, textY)
					}
					LG.pop()
				}
			}

		case Checkbox:
			local checkbox = cast(Checkbox) el
			local y        = checkbox.layoutY + checkbox.layoutHeight // 2

			if checkbox.id ~= state.hoveredId {
				if checkbox.checked
					LG.setColor(1, 1, 1, .35)
				else
					LG.setColor(1, 1, 1, .25)
			} elseif checkbox.id ~= state.activeId {
				LG.setColor(1, 1, 1, .55)
			} else {
				LG.setColor(1, 1, 1, .45)
			}

			if checkbox.checked {
				LG.rectangle(LG.DrawMode.LINE, checkbox.layoutX+.5, y-CHECKBOX_SIZE//2+.5, CHECKBOX_SIZE-1, CHECKBOX_SIZE-1)
				LG.rectangle(LG.DrawMode.FILL, checkbox.layoutX+2,  y-CHECKBOX_SIZE//2+2,  CHECKBOX_SIZE-4, CHECKBOX_SIZE-4)
			} else {
				LG.rectangle(LG.DrawMode.LINE, checkbox.layoutX+.5, y-CHECKBOX_SIZE//2+.5, CHECKBOX_SIZE-1, CHECKBOX_SIZE-1)
			}

			LG.setFont(fontSmall)
			LG.setColor(1, 1, 1, TEXT_OPACITY)
			LG.print(checkbox.label, checkbox.layoutX+CHECKBOX_SIZE+SPACING, y-fontSmall.getHeight!()//2)
			LG.setFont(fontNormal)

		case InputText:
			local input = cast(InputText) el
			local field = input.field

			local focused = (input.id == state.focusId)

			local x = input.layoutX
			local y = input.layoutY
			local w = input.layoutWidth
			local h = input.layoutHeight

			local valueX = x + SPACING

			-- Background.
			LG.setColor(0, 0, 0, (input.style == .CONTEXT_MENU ? .8 : .5))
			LG.rectangle(LG.DrawMode.FILL, x, y, w, h, BUTTON_RADIUS)

			LG.pushAll()
			intersectScissor(x, 0, w, LG.getHeight())

			-- Selection.
			if focused {
				local x1, x2 = field.getSelectionOffset!()
				if x2 > x1 {
					LG.setColor(1, 1, 0, .5)
					LG.rectangle(LG.DrawMode.FILL, valueX+x1, y, x2-x1, h)
				}
				LG.setColor(1, 1, 1, math.lerp(.1, .9, math.cos01(field.getBlinkPhase!()*math.TAU/1.00)))
				LG.rectangle(LG.DrawMode.FILL, valueX+field.getCursorOffset!(), y, 1, h)
			}

			-- Value.
			local textOffset = focused ? field.getTextOffset!() : 0
			local text       = focused ? field.getText!()       : input.value
			if text {
				LG.setColor(1, 1, 1, TEXT_OPACITY)
			} else {
				LG.setColor(1, 1, 1, TEXT_OPACITY*.5)
				text = input.placeholder
			}
			if text  LG.print(text, valueX+textOffset, y+SPACING)

			-- Cursor.
			if focused {
				LG.setColor(1, 1, 1, math.lerp(.1, .9, math.cos01(field.getBlinkPhase!()*math.TAU/1.00)))
				LG.rectangle(LG.DrawMode.FILL, valueX+field.getCursorOffset!(), y, 1, h)
			}

			LG.pop()

			-- Hover/focus effect.
			if input.id == state.hoveredId or focused {
				if focused
					LG.setColor(COLOR_FOCUS)
				else
					LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
				LG.rectangle(LG.DrawMode.LINE, x-.5, y-.5, w+1, h+1, BUTTON_RADIUS)
			}

		case Slider:
			local slider  = cast(Slider) el
			local x1      = slider.layoutX +                      SLIDER_MIN_THICKNESS // 2
			local x2      = slider.layoutX + slider.layoutWidth - SLIDER_MIN_THICKNESS // 2
			local w       = x2 - x1
			local value01 = math.clamp01((slider.value - applyLimitMultiplier(slider, slider.min)) / (applyLimitMultiplier(slider, slider.max) - applyLimitMultiplier(slider, slider.min)))
			value01       = applyExponential(slider, value01, .5)
			local handleX = x1 + math.round(value01 * w)
			local y       = slider.layoutY + slider.layoutHeight // 2

			local opacity   = slider.enabled ? 1 : DISABLED_OPACITY
			local highlight = shouldHighlight(state, slider)

			local showLimits = (
				(state.activeId or state.hoveredId)
				and slider.id == math.max(state.activeId, state.hoveredId)
				and ((state.activeId and state.activeMod == .A) or (not state.activeId and getModifierKey() == .A))
			)

			-- Line/background.
			LG.setColor(1, 1, 1, (highlight ? .2 : .1)*opacity)
			LG.rectangle(LG.DrawMode.FILL, x1, y-1, w, 2)

			-- Guides.
			LG.setColor(1, 1, 1, .12*opacity)
			LG.rectangle(LG.DrawMode.FILL, x1, y-3, +1, 6)
			LG.rectangle(LG.DrawMode.FILL, x2, y-3, -1, 6)
			if w >= 50 {
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,1/4,.5)*w), y-3, 1, 6)
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,2/4,.5)*w), y-3, 1, 6)
				LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,3/4,.5)*w), y-3, 1, 6)
				if w >= 200 {
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,1/8,.5)*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,3/8,.5)*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,5/8,.5)*w), y-1, 1, 2)
					LG.rectangle(LG.DrawMode.FILL, math.round(x1+applyExponential(slider,7/8,.5)*w), y-1, 1, 2)
				}
			}

			-- Handle.
			local grey = (highlight ? .8 : .65)
			LG.setColor(grey, grey, grey, opacity)
			LG.rectangle(LG.DrawMode.FILL, handleX-1, y-SLIDER_MIN_THICKNESS/2, 2, SLIDER_MIN_THICKNESS)

			-- Readout.
			local COLOR_TEXT:   love.Color: {1,1,1,.8*TEXT_OPACITY}
			local COLOR_SHADOW: love.Color: {0,0,0,.5*TEXT_OPACITY}

			if showLimits {
				local textMin = format("min "..slider.readout, applyLimitMultiplier(slider, slider.min) * slider.readoutMulti)
				local textMax = format("max "..slider.readout, applyLimitMultiplier(slider, slider.max) * slider.readoutMulti)
				local textX1  = x1 + 3
				local textX2  = x2 - 3 - fontSmall.getWidth!(textMax)
				local textY   = y  - fontSmall.getHeight!() // 2 - 1

				LG.setFont(fontSmall)
				LG.setColor(COLOR_SHADOW[1], COLOR_SHADOW[2], COLOR_SHADOW[3], COLOR_SHADOW[4]*opacity)
				LG.print(textMin, textX1+1, textY+1)
				LG.print(textMax, textX2+1, textY+1)
				LG.setColor(COLOR_TEXT[1], COLOR_TEXT[2], COLOR_TEXT[3], COLOR_TEXT[4]*opacity)
				LG.print(textMin, textX1, textY)
				LG.print(textMax, textX2, textY)
				LG.setFont(fontNormal)

			} elseif app.showPanelNumbers {
				drawSliderReadout(x2, y-SLIDER_MIN_THICKNESS//2, SLIDER_MIN_THICKNESS, handleX, slider.value, slider.readoutMulti, slider.readout, slider.readoutZero, COLOR_TEXT, COLOR_SHADOW, opacity)
			}

		case Color:
			local drawSliderValue :: (sliderX,sliderY:int, sliderW,sliderH:int, value:float, readout:float, readoutFormat:string, highlight:bool) {
				local x = math.round(sliderX + value*(sliderW-4))
				local a = (highlight ? .9 : .7)

				if app.showPanelNumbers {
					local COLOR_TEXT:   love.Color: {1,1,1,1}
					local COLOR_SHADOW: love.Color: {0,0,0,1}
					drawSliderReadout(sliderX+sliderW, sliderY, sliderH, x, readout, 1, readoutFormat, "", COLOR_TEXT, COLOR_SHADOW, 1) -- @Incomplete: Opacity.
				}

				LG.setColor(0, 0, 0, a)
				LG.rectangle(LG.DrawMode.FILL, x, sliderY, 4, sliderH)

				LG.setColor(1, 1, 1, a)
				LG.rectangle(LG.DrawMode.FILL, x+1, sliderY, 2, sliderH)
			}

			local colorEl    = cast(Color) el
			local components = (colorEl.alpha ? 3 : 4)
			local x          = colorEl.layoutX
			local y1         = colorEl.layoutY
			local y2         = y1 + math.round(1 * colorEl.sliderWidth)
			local y3         = y1 + math.round(2 * colorEl.sliderWidth)
			local y4         = y1 + math.round(3 * colorEl.sliderWidth)
			local y5         = y1 + colorEl.layoutHeight
			local w          = colorEl.layoutWidth

			local hue        = colorEl.color[1]
			local saturation = colorEl.color[2]
			local value      = colorEl.color[3]
			local a          = colorEl.color[4]

			local opacity        = colorEl.enabled ? 1 : DISABLED_OPACITY
			local highlightWhole = shouldHighlight(state, colorEl)
			local highlight      = highlightWhole ? math.max(state.activeSubid, state.hoveredSubid) : 0

			local iw, ih     = imageRainbow.getDimensions!()
			local rainbowSx  = w / iw
			local rainbowSy  = (y2-y1) / ih
			LG.setColor(1, 1, 1)
			LG.draw(imageRainbow, x, y1, 0, rainbowSx, rainbowSy)
			drawSliderValue(x, y1, w, y2-y1, hue, hue*360, "%d°", (highlight == 1))

			local r, g, b    = hsvToRgb(hue, 1, 1)
			iw, ih           = imageGradient.getDimensions!()
			local gradientSx = w / iw
			local gradientSy = (y3-y2) / ih
			LG.setColor(.5, .5, .5)
			LG.rectangle(LG.DrawMode.FILL, x, y2, w, y2-y1)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, y2, 0, gradientSx, gradientSy)
			drawSliderValue(x, y2, w, y3-y2, saturation, saturation*100, "%d%%", (highlight == 2))

			r, g, b    = hsvToRgb(hue, saturation, 1)
			gradientSy = (y4-y3) / ih
			LG.setColor(0, 0, 0)
			LG.rectangle(LG.DrawMode.FILL, x, y3, w, y4-y3)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, y3, 0, gradientSx, gradientSy)
			drawSliderValue(x, y3, w, y4-y3, value, value*100, "%d%%", (highlight == 3))

			if colorEl.alpha {
				r, g, b    = hsvToRgb(hue, saturation, value)
				gradientSy = (y5-y4) / ih
				drawCheckerBox(x, y4, w, y5-y4)
				LG.setColor(r, g, b)
				LG.draw(imageGradient, x, y4, 0, gradientSx, gradientSy)
				drawSliderValue(x, y4, w, y5-y4, a, a*100, "%d%%", (highlight == 4))
			}

			if highlight {
				local hlIndex = math.max(state.hoveredSubid, state.activeSubid)
				local hlY1    = y1 + math.round((hlIndex-1) * colorEl.sliderWidth)
				local hlY2    = y1 + math.round((hlIndex  ) * colorEl.sliderWidth)
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY_STRONG)
				LG.rectangle(LG.DrawMode.LINE, x-.5, hlY1-.5, w+1, hlY2-hlY1+1)
			}

			if highlightWhole {
				local mod = state.activeId ? state.activeMod : getModifierKey()

				if not (mod == .S or mod == .CS) {
					local hlY1 = y1 - 1
					local hlY2 = y1 + math.round((colorEl.alpha?4:3) * colorEl.sliderWidth) + 1
					LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY_STRONG)
					LG.rectangle(LG.DrawMode.LINE, x-1.5, hlY1-.5, w+3, hlY2-hlY1+1)
				}
			}

		case ColorPreview:
			local preview = cast(ColorPreview) el

			-- The shader only supports 8 colors, but we can change that if necessary.
			static colorsForShader = []love.Color.{ {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1} }
			local  colorCount      = 0

			for preview.linkColors {
				local colorEl = cast(Color) state.elementsByName[it]

				if colorEl ~= NULL and isElementVisible(colorEl) {
					colorCount  += 1
					local color  = colorsForShader[colorCount]

					color[1], color[2], color[3] = hsvToRgb(colorEl.color)
					color[4]                     = colorEl.alpha ? colorEl.color[4] : 1
				}
			}

			drawCheckerBox(preview.layoutX, preview.layoutY, preview.layoutWidth, preview.layoutHeight)

			LG.setBlendMode(preview.blendMode)
			drawColorGradient(preview.layoutX, preview.layoutY, preview.layoutWidth, preview.layoutHeight, colorsForShader, colorCount)
			LG.setBlendMode(.ALPHA)

		case Direction:
			local direction = cast(Direction) el

			local r :: DIRECTION_RADIUS
			local x = direction.layoutX + r
			local y = direction.layoutY + r

			local angle = direction.angle

			local opacity   = direction.enabled ? 1 : DISABLED_OPACITY
			local highlight = shouldHighlight(state, direction)

			-- Background.
			LG.setColor(0, 0, 0, .4*opacity)
			LG.circle(LG.DrawMode.FILL, x, y, r)

			-- Spread.
			if direction.linkSpread {
				local other = cast(Slider) state.elementsByName[direction.linkSpread]

				if other ~= NULL and other.type == Slider and other.value ~= 0 and isElementVisible(other) and other.enabled {
					LG.setColor(1, 1, 1, .25*opacity)
					LG.arc(LG.DrawMode.FILL, x, y, .8*r, angle-other.value/2, angle+other.value/2, 32)
				}

			} elseif direction.linkOther {
				local other = cast(Direction) state.elementsByName[direction.linkOther]

				if other ~= NULL and other.type == Direction and other.angle ~= angle and isElementVisible(other) {
					LG.setColor(1, 1, 1, .25*opacity)
					LG.arc(LG.DrawMode.FILL, x, y, .8*r, angle, other.angle, 32)
				}
			}

			-- Guides.
			LG.setColor(1, 1, 1, .08*opacity)
			LG.line(x-r+1, y, x+r-1, y)
			LG.line(x, y-r+1, x, y+r-1)
			LG.line(x-.3*r, y-.3*r, x+.3*r, y+.3*r)
			LG.line(x+.3*r, y-.3*r, x-.3*r, y+.3*r)

			-- Outline.
			if highlight {
				LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY*opacity)
				LG.circle(LG.DrawMode.LINE, x, y, r+.5)
			}

			-- Value.
			LG.setColor(1, 1, 1, opacity)
			LG.line(x, y, x+r*math.cos(angle), y+r*math.sin(angle))

			-- Readout.
			if app.showPanelNumbers {
				local text  = format("%d°", angle*360/math.TAU)
				local textX = x - fontSmall.getWidth!(text) // 2
				local textY = (angle % math.TAU < math.PI) ? direction.layoutY+5 : direction.layoutY+2*r-5-fontSmall.getHeight!()
				LG.setFont(fontSmall)
				LG.setColor(0, 0, 0, TEXT_OPACITY*opacity)
				LG.print(text, textX+1, textY+1)
				LG.setColor(1, 1, 1, TEXT_OPACITY*opacity)
				LG.print(text, textX, textY)
				LG.setFont(fontNormal)
			}

		case Canvas:
			triggerDrawEvent(state, el, el.layoutX, el.layoutY, getScrollOffset(el), el.layoutWidth, el.layoutHeight)

		case: errorf("%d", el.type)
	}

	if state.onDrawForeground[el.name] ~= NULL {
		triggerDrawForegroundEvent(state, el, el.layoutX, el.layoutY, getScrollOffset(el), el.layoutWidth, el.layoutHeight)
	}

	!if DEV  if LK.isScancodeDown"`" {
		if el[1] == NULL {
			LG.setColor(0, 1, 0, .5)
		} else {
			LG.setColor(1, 0, 0, .35)
			LG.setColorMask(true, false, true, true)
		}
		LG.rectangle(LG.DrawMode.LINE, el.layoutX+.5, el.layoutY+.5, el.layoutWidth-1, el.layoutHeight-1)
		LG.setColorMask()
	}
}

export draw :: (state:State) {
	updateLayoutIfNeeded(state)

	local ww, wh   = LG.getDimensions()
	local topModal = state.getTopmostActiveModal!()

	for state.frames  if it.active {
		if it == topModal {
			LG.setColor(.2, .2, .2, .6)
			LG.rectangle(LG.DrawMode.FILL, 0, 0, ww, wh)
		}
		drawElement(state, it)
	}

	if state.currentTooltip {
		local a = math.clamp01(((LT.getTime() - state.tooltipTime) - .30) / 0.20)

		if a > 0 {
			local w, lines = fontNormal.getWrap!(state.currentTooltip, 100_000)
			local fontH    = fontNormal.getHeight!()

			w       += 2*SPACING
			local h  = fontH + math.ceil((#lines-1)*fontH*fontNormal.getLineHeight!()) + 2*BUTTON_PADDING_Y
			local x  = math.max(math.min(state.tooltipX, ww-w), 0)
			local y  = state.tooltipY1 - h - 1

			if y < 0  y = state.tooltipY2 + 1

			LG.setColor(0, 0, 0, .3*a)
			drawBoxGradient(x, y, w, h)
			LG.setColor(0, 0, 0, .8*a)
			LG.rectangle(LG.DrawMode.FILL, x-1, y-1, w+2, h+2, BUTTON_RADIUS)
			LG.setColor(.8, .8, .8, a)
			LG.rectangle(LG.DrawMode.FILL, x, y, w, h, 2)
			LG.setColor(0, 0, 0, a)
			LG.print(state.currentTooltip, x+SPACING, y+BUTTON_PADDING_Y)
		}
	}

	!if DEV  if LK.isScancodeDown"`" {
		local mx, my    = LM.getPosition()
		local found, el = state.getElementAt!(mx, my)

		local name = found ? el.name : ""

		if found and (el.type == Buttons or el.type == Radio or el.type == Tabs) {
			local buttons = cast(Buttons) el
			local hoveredSubid: int

			if buttons.vertical
				hoveredSubid = math.clamp(math.floor(1 + (my-buttons.layoutY-getScrollOffset(buttons)) / buttons.buttonHeight), 1, #buttons.buttons)
			else
				hoveredSubid = math.clamp(math.floor(1 + (mx-buttons.layoutX                         ) / buttons.buttonWidth ), 1, #buttons.buttons)

			if not buttons.buttons[hoveredSubid].name {
				-- void
			} elseif name {
				name = name.."."..buttons.buttons[hoveredSubid].name
			} else {
				name = buttons.buttons[hoveredSubid].name
			}
		}

		if name {
			local x = mx + 8
			local y = my + 20

			LG.setColor(0, 0, 0)
			LG.rectangle(LG.DrawMode.FILL, x, y, fontSmall.getWidth!(name), fontSmall.getHeight!())

			LG.setFont(fontSmall)
			LG.setColor(1, 1, 1)
			LG.print(name, x, y)
			LG.setFont(fontNormal)
		}
	}
}



export isInsideElement :: (state:State, x,y:int, el:Element) -> bool {
	if not el.active  return false

	updateLayoutIfNeeded(state)

	if el.type == {
		case Direction:
			local r :: DIRECTION_RADIUS
			return math.distance(x,y, el.layoutX+r,el.layoutY+r) <= r

		case Slider:
			return x >= el.layoutX and x < el.layoutX+el.layoutWidth and math.abs(y-(el.layoutY+el.layoutHeight/2)) <= SLIDER_MIN_THICKNESS/2

		case Checkbox:
			return x >= el.layoutX and x < el.layoutX+el.layoutWidth and math.abs(y-(el.layoutY+el.layoutHeight/2)) <= CHECKBOX_SIZE/2

		case:
			return
				x >= el.layoutX and
				y >= el.layoutY and
				x <  el.layoutX+el.layoutWidth and
				y <  el.layoutY+el.layoutHeight
	}
}

export isOverGui :: (state:State, x,y:int) -> bool {
	for state.frames {
		if state.isInsideElement!(x, y, it)  return true
	}
	return false
}



export getElement :: (state:State, name:string, $T:Type) -> T {
	return cast(T) state.elementsByName[name]
}
export getElement :: (state:State, name:string) -> Element { -- @Compiler @Incomplete: Default values for baked arguments (so we can use the above function always).
	return state.elementsByName[name]
}

export getElementAt :: (state:State, x,y:int) -> (found:bool, el:Element) {
	updateLayoutIfNeeded(state)

	for < state.frames  if it.active {
		local helper :: (state:State, el:Element, x,y:int) -> Element {
			if not state.isInsideElement!(x, y, el)  return NULL

			if el.type == Scrollable  y -= math.round((cast(Scrollable)el).scroll)

			if not (el.type == Section and app.hiddenSections[el.name]) {
				for < el {
					local subEl = helper(state, it, x, y)
					if subEl ~= NULL  return subEl
				}
			}

			return el
		}

		local el = helper(state, it, x, y)
		if el ~= NULL  return true, el

		if it.modal  return false, NULL
	}

	return false, NULL
}

export getWidgetAt :: (state:State, x,y:int) -> (found:bool, widget:Widget) {
	local found, widget = state.getElementAt!(x, y)
	if not found  return false, NULL

	if widget.type == {
		case Buttons:      return true, cast(Widget)widget
		case InputText:    return true, cast(Widget)widget
		case Radio:        return true, cast(Widget)widget
		case Tabs:         return true, cast(Widget)widget
		case Checkbox:     return true, cast(Widget)widget
		case Slider:       return true, cast(Widget)widget
		case Color:        return true, cast(Widget)widget
		case ColorPreview: return true, cast(Widget)widget
		case Direction:    return true, cast(Widget)widget

		case Scrollable:
			if x < widget.layoutX + widget.layoutWidth - SCROLLBAR_WIDTH  return false, NULL
			return true, cast(Widget)widget

		case Section:
			local section = cast(Section) widget
			if not section.name   return false, NULL
			if not section.label  return false, NULL
			if y >= widget.layoutY + fontNormal.getHeight!() + getScrollOffset(section)  return false, NULL
			if x >= widget.layoutX + fontNormal.getWidth!(section.label)                 return false, NULL
			return true, cast(Widget)widget

		case:
			return false, NULL
	}
}

export findParent :: (state:State, el:Element, name:string) -> (found:bool, parent:Element) {
	while true {
		el = el.parent
		if el      == NULL  return false, NULL
		if el.name == name  return true,  el
	}
}



export setActive :: (state:State, name:string, active:bool) -> (success:bool) {
	local el = state.elementsByName[name]
	if el == NULL {
		log("Error: No element '%s'.", name)
		return false
	}

	return state.setActive!(el, active)
}
export setActive :: (state:State, el:Element, active:bool) -> (success:bool) {
	if el.active == active  return true

	el.active               = active
	state.layoutNeedsUpdate = true

	if not active and state.focusId and (el.id == state.focusId or hasParent(state.elementsById[state.focusId], el)) {
		state.blurFocus!(abort=false)
	}

	if el.type == Frame {
		local frame    = cast(Frame) el
		local found, i = indexOf(state.frames, frame)
		assert(found)
		remove(state.frames, i)
		insert(state.frames, frame)
	}

	if active {
		local resetScroll :: (el:Element) {
			if el.type == Scrollable {
				local scrollable = cast(Scrollable) el
				scrollTo(scrollable, 0)
			}
			for el  resetScroll(it)
		}
		resetScroll(el)
	}

	if active
		triggerActiveEvent(state, el)
	else
		triggerInactiveEvent(state, el)

	return true
}

local hasParent :: (el:Element, parent:Element) -> bool {
	while el.parent ~= NULL {
		if el.parent == parent  return true
		el = el.parent
	}
	return false
}



local getScrollbarHandle :: (scrollable:Scrollable, visual:bool) -> (handlePos:int, handleLen:int, handlePosMax:int) {
	local contentH = scrollable.contentHeight
	local visibleH = scrollable.layoutHeight
	local paddedH  = visibleH - 2*SPACING

	local handleLen = math.clamp(
		math.round(visibleH * paddedH / contentH),
		SCROLLBAR_MIN_LENGTH,
		visibleH
	)

	local handlePos, handlePosMax = 0, 0
	if contentH > paddedH {
		local scroll = visual ? scrollable.scroll : scrollable.scrollTarget
		handlePosMax = visibleH - handleLen
		handlePos    = math.min(math.round(-scroll*handlePosMax/(contentH-paddedH)), handlePosMax)
	}

	return handlePos, handleLen, handlePosMax
}

local limitScroll :: (scrollable:Scrollable) {
	local limit             = math.max(scrollable.contentHeight - scrollable.layoutHeight + 2*SPACING, 0)
	scrollable.scrollTarget = math.clamp(scrollable.scrollTarget, -limit, 0)
	scrollable.scroll       = math.clamp(scrollable.scroll,       -limit, 0)
}

export getScrollOffset :: (state:State, el:Element) -> int {
	return getScrollOffset(el)
}

export getScrollOffset :: (el:Element) -> int {
	local offset = 0

	while el.parent ~= NULL {
		el = el.parent
		if el.type == Scrollable {
			offset += math.round((cast(Scrollable)el).scroll) -- Should we round here or when we return?
		}
	}

	return offset
}



export drawChecker :: (x,y,w,h:float, scale=1.0) {
	static quad: LG.Quad = NULL

	if quad == NULL {
		local iw, ih = imageChecker.getDimensions!()
		quad         = LG.newQuad(0, 0, 1, 1, iw, ih)
	}

	quad.setViewport!(0, 0, w/scale, h/scale)
	LG.draw(imageChecker, quad, x, y, 0, scale)
}

export drawCheckerBox :: (x,y,w,h:int) {
	LG.setColor(.15, .15, .15)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
	LG.setColor(.27, .27, .27)
	drawChecker(x, y, w, h)
}



export drawBoxGradient :: (x,y,w,h:int, bw=10, drawCenter=true) {
	static quad11: LG.Quad = NULL
	static quad12: LG.Quad = NULL
	static quad13: LG.Quad = NULL
	static quad21: LG.Quad = NULL
	static quad22: LG.Quad = NULL
	static quad23: LG.Quad = NULL
	static quad31: LG.Quad = NULL
	static quad32: LG.Quad = NULL
	static quad33: LG.Quad = NULL

	if quad11 == NULL {
		local iw, ih = imageBoxGradient.getDimensions!()

		quad11 = LG.newQuad(0,0, 1,1, 3,3)
		quad12 = LG.newQuad(1,0, 1,1, 3,3)
		quad13 = LG.newQuad(2,0, 1,1, 3,3)
		quad21 = LG.newQuad(0,1, 1,1, 3,3)
		quad22 = LG.newQuad(1,1, 1,1, 3,3)
		quad23 = LG.newQuad(2,1, 1,1, 3,3)
		quad31 = LG.newQuad(0,2, 1,1, 3,3)
		quad32 = LG.newQuad(1,2, 1,1, 3,3)
		quad33 = LG.newQuad(2,2, 1,1, 3,3)
	}

	LG.draw(imageBoxGradient, quad11, x-bw, y-bw, 0, bw, bw)
	LG.draw(imageBoxGradient, quad12, x,    y-bw, 0, w,  bw)
	LG.draw(imageBoxGradient, quad13, x+w,  y-bw, 0, bw, bw)
	LG.draw(imageBoxGradient, quad21, x-bw, y,    0, bw, h)
	if drawCenter {
	LG.draw(imageBoxGradient, quad22, x,    y,    0, w,  h)
	}
	LG.draw(imageBoxGradient, quad23, x+w,  y,    0, bw, h)
	LG.draw(imageBoxGradient, quad31, x-bw, y+h,  0, bw, bw)
	LG.draw(imageBoxGradient, quad32, x,    y+h,  0, w,  bw)
	LG.draw(imageBoxGradient, quad33, x+w,  y+h,  0, bw, bw)
}



export drawColorGradient :: (x,y,w,h:int, colors:[]love.Color, colorCount=-1) {
	if colorCount < 0  colorCount = #colors

	static shader: LG.Shader = NULL
	if shader == NULL  shader = LG.newShader("src/particleColorPreview.glsl")

	shader.send!("colors",     colors[1], unpack(colors, 2))
	shader.send!("colorCount", colorCount)

	local oldShader = LG.getShader()
	LG.setShader(shader)
	LG.draw(imagePixel, x, y, 0, w, h)
	LG.setShader(oldShader)
}



local triggerRefreshEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onRefresh[el.name]
	if cb == NULL  return
	cb(el)
	state.layoutNeedsUpdate = true
}

local triggerActiveEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onActive[el.name]
	if cb == NULL  return
	cb(el)
}
local triggerInactiveEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onInactive[el.name]
	if cb == NULL  return
	cb(el)
}

local triggerDrawBackgroundEvent :: (state:State, el:Element, x,y,scrollOffset,w,h:int) {
	local cb = cast((el:Element, w,h:int)) state.onDrawBackground[el.name]
	if cb == NULL  return

	LG.pushAll()
	LG.translate(x, y)
	LG.setColor(1, 1, 1)
	intersectScissor(x, y+scrollOffset, w, h)
	cb(el, w, h)
	LG.pop()
}
local triggerDrawEvent :: (state:State, el:Element, x,y,scrollOffset,w,h:int) {
	local cb = cast((el:Element, w,h:int)) state.onDraw[el.name]
	if cb == NULL  return

	LG.pushAll()
	LG.translate(x, y)
	LG.setColor(1, 1, 1)
	intersectScissor(x, y+scrollOffset, w, h)
	cb(el, w, h)
	LG.pop()
}
local triggerDrawForegroundEvent :: (state:State, el:Element, x,y,scrollOffset,w,h:int) {
	local cb = cast((el:Element, w,h:int)) state.onDrawForeground[el.name]
	if cb == NULL  return

	LG.pushAll()
	LG.translate(x, y)
	LG.setColor(1, 1, 1)
	intersectScissor(x, y+scrollOffset, w, h)
	cb(el, w, h)
	LG.pop()
}

local triggerSubmitEvent :: (state:State, el:Element) {
	local cb = cast((el:Element)) state.onSubmit[el.name]
	if cb == NULL  return
	cb(el)
}

export ActionSource :: enum string { UNKNOWN, MOUSE, KEYBOARD }

local triggerBeforeActionEvent :: (state:State, widget:Widget, name:string, subid:int) -> (ignore:bool) {
	local cb = cast((widget:Widget, subid:int) -> (ignore:bool)) state.onBeforeAction[name ?: widget.name]
	if cb == NULL  return false
	return cb(widget, subid)
}
local triggerBeginEvent :: (state:State, widget:Widget, name:string, subid:int, alsoEnsureEnabled=false) {
	-- printf("GuiEvent: Begin  '%s'", (name ?: widget.name)) -- DEBUG

	local cb = cast((widget:Widget, subid:int)) state.onBegin[name ?: widget.name]
	if cb ~= NULL  cb(widget, subid)

	-- @Robustness: Can we ensure enabled before onBegin without messing up undo history recording?
	if alsoEnsureEnabled and not widget.enabled {
		widget.enabled = true
		triggerToggleEvent(state, widget, name, subid)
	}
}
local triggerActionEvent :: (state:State, widget:Widget, name:string, subid:int, source:ActionSource, alsoEnd=false) {
	-- printf("GuiEvent: Action '%s'", (name ?: widget.name)) -- DEBUG

	local cb = cast((widget:Widget, subid:int, source:ActionSource)) state.onAction[name ?: widget.name]
	if cb ~= NULL  cb(widget, subid, source)

	if alsoEnd {
		triggerEndEvent(state, widget, name, subid)
		if cb ~= NULL  scheduleSaveWorkspace()
	}
}
local triggerEndEvent :: (state:State, widget:Widget, name:string, subid:int) {
	-- printf("GuiEvent: End    '%s'", (name ?: widget.name)) -- DEBUG
	local cb = cast((widget:Widget, subid:int)) state.onEnd[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
	scheduleSaveWorkspace()
}

local triggerDoublePressEvent :: (state:State, widget:Widget, name:string, subid:int) -> (handled:bool) {
	local cb = cast((widget:Widget, subid:int)) state.onDouble[name ?: widget.name]
	if cb == NULL  return false

	cb(widget, subid)
	scheduleSaveWorkspace()
	return true
}

local triggerOptionEvent :: (state:State, widget:Widget, name:string, subid:int) -> (handled:bool) {
	local cb = cast((widget:Widget, subid:int)) state.onOption[name ?: widget.name]
	if cb == NULL  return false

	cb(widget, subid)
	return true
}

local triggerCloseEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, subid:int)) state.onClose[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
	scheduleSaveWorkspace()
}

local triggerDragBeginEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, subid:int)) state.onDragBegin[name ?: widget.name]
	if cb == NULL  return
	cb(widget, subid)
}
local triggerDragEvent :: (state:State, widget:Widget, name:string, subid:int, mx,my:int) {
	local cb = cast((widget:Widget, subid:int, mx,my:int)) state.onDrag[name ?: widget.name]
	if cb == NULL  return
	cb(widget, subid, mx, my)
}
local triggerDragEndEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, subid:int)) state.onDragEnd[name ?: widget.name]
	if cb == NULL  return
	cb(widget, subid)
}

local triggerMouseEnterEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, subid:int)) state.onMouseEnter[name ?: widget.name]
	if cb == NULL  return
	cb(widget, subid)
}

local triggerBeforeKeyPressedEvent :: (state:State, input:InputText, name:string, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (ignore:bool) {
	local cb = state.onBeforeKeyPressed[name ?: input.name]
	if cb == NULL  return false
	return cb(input, key, scancode, isRepeat)
}
local triggerBeforeTextInputEvent :: (state:State, input:InputText, name:string, text:string) -> (ignore:bool) {
	local cb = state.onBeforeTextInput[name ?: input.name]
	if cb == NULL  return false
	return cb(input, text)
}

local triggerToggleEvent :: (state:State, widget:Widget, name:string, subid:int) {
	local cb = cast((widget:Widget, subid:int)) state.onToggle[name ?: widget.name]
	if cb == NULL  return

	cb(widget, subid)
	scheduleSaveWorkspace()
}



export refresh :: (state:State, el:Element) {
	triggerRefreshEvent(state, el)
}
export refresh :: (state:State, name:string) {
	local el = state.elementsByName[name]
	if el == NULL {
		log("Error: No element '%s'.", name)
		return
	}

	triggerRefreshEvent(state, el)
}

export refreshRecursively :: (state:State, el:Element, onlyActive=true) {
	triggerRefreshEvent(state, el)
	for el  if not (onlyActive and not it.active) {
		state.refreshRecursively!(it, onlyActive)
	}
}
export refreshRecursively :: (state:State, name:string, onlyActive=true) {
	local el = state.elementsByName[name]
	if el == NULL {
		log("Error: No element '%s'.", name)
		return
	}

	triggerRefreshEvent(state, el)
	for el  if not (onlyActive and not it.active) {
		state.refreshRecursively!(it, onlyActive)
	}
}

export refreshAll :: (state:State, onlyActive=true) {
	for state.frames  if not (onlyActive and not it.active) {
		state.refreshRecursively!(it, onlyActive)
	}
}



export isElementVisible :: (el:Element) -> bool {
	while el.parent ~= NULL {
		if not el.active  return false
		el = el.parent
	}

	return el.active
}

export isElementVisible :: (state:State, el:Element) -> bool {
	return isElementVisible(el)
}

export isElementVisible :: (state:State, name:string) -> bool {
	local el = state.elementsByName[name]
	return el ~= NULL and isElementVisible(el)
}



export setFocus :: (state:State, name:string) {
	local input = cast(InputText) state.elementsByName[name]
	if input == NULL {
		log("Error: No element '%s'.", name)
		return
	}

	if input.type ~= InputText {
		log("Error: Element '%s' is not InputText.", name)
		return
	}

	state.setFocus!(input)
}
export setFocus :: (state:State, widget:Widget) {
	if not state.isElementVisible!(widget)  return
	if state.focusId == widget.id           return

	state.blurFocus!(abort=false)
	state.focusId = widget.id

	if widget.type == InputText {
		local input = cast(InputText) widget

		if input.field == NULL {
			input.field = InputField()
			input.field.setFont!(fontNormal)
			input.field.setWidth!(input.layoutWidth - 2*SPACING)
		}

		input.field.setText!(input.value)
		input.field.setScroll!(0)
	}
}

export blurFocus :: (state:State, abort=false) {
	if not state.focusId  return

	local widget = cast(Widget) state.elementsById[state.focusId]

	if widget.type == InputText {
		local input = cast(InputText) widget
		local field = input.field

		field.release!()

		if field.getText!() == input.value {
			-- void
		} elseif abort {
			field.setText!(input.value)
		} else {
			triggerBeginEvent(state, input, "", 0, alsoEnsureEnabled=false)
			input.value = field.getText!()
			triggerActionEvent(state, input, "", 0, .UNKNOWN, alsoEnd=true)
		}
	}

	state.focusId = 0
	scheduleSaveWorkspace()
}



export getTopmostActiveModal :: (state:State) -> Frame {
	for < state.frames {
		if it.active and it.modal  return it
	}
	return NULL
}



export pressButton :: (state:State, buttonsElementName:string, i:int) {
	local buttons = cast(Buttons) state.elementsByName[buttonsElementName]
	if buttons == NULL {
		log("Error: No element '%s'.", buttonsElementName)
		return
	}

	if not (buttons.type == Buttons or buttons.type == Radio or buttons.type == Tabs) {
		log("Error: '%s' is not a buttons element.", buttonsElementName)
		return
	}

	local button = buttons.buttons[i]
	if button == NULL or true {
		log("Error: No button at index %d in '%s'.", i, buttonsElementName)
		return
	}

	triggerBeginEvent (state, buttons, button.name, i, alsoEnsureEnabled=false)
	triggerActionEvent(state, buttons, button.name, i, .UNKNOWN, alsoEnd=true)
}



local limitMenuPosition :: (state:State, contextMenu:Frame) {
	updateLayoutIfNeeded(state)

	local x = contextMenu.layoutX
	local y = contextMenu.layoutY
	local w = contextMenu.layoutWidth
	local h = contextMenu.layoutHeight

	if x   > LG.getWidth()-w  state.layoutNeedsUpdate, contextMenu.x = true, math.max(LG.getWidth()-w, 0)
	if y+h > LG.getHeight()   state.layoutNeedsUpdate, contextMenu.y = true, y - h
}

-- Note that the cbChoice() type is different from showContextMenu*().
export showMenu :: (state:State, x,y:int, items:[]MenuItem, cbChoice:(choice:string,data:any), cbButtonOption:(choice:string,data:any)=NULL, cbDrawButton:(choice:string,data:any,w,h:int)=NULL, buttonPaddingRight=0) {
	state.hideContextMenu!()

	local makeContextMenu :: (state:State, items:[]MenuItem, parentMenu:Frame, buttonPaddingRight:int, active:bool) -> Frame {
		local buttonH     = items[1] ~= NULL ? items[1].height : 16--MenuItem.height -- @Compiler: Access to default member values.
		local buttons     = state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=buttonH, buttonPaddingRight=buttonPaddingRight })
		local contextMenu = state.frame!({ parentFrame=parentMenu, minWidth=CONTEXT_MENU_MIN_WIDTH, layout=.FLOATING, style=.CONTEXT_MENU, temp=true, active=active, buttons })
		insert(state.contextMenus, contextMenu)

		for items {
			if it.label == "-" {
				insert(contextMenu, state.separator!({ thick=false }))

				buttonH = items[itIndex+1] ~= NULL ? items[itIndex+1].height : 16--MenuItem.height -- @Compiler: Access to default member values.
				buttons = state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=buttonH, buttonPaddingRight=buttonPaddingRight })
				insert(contextMenu, buttons)

			} else {
				insert(buttons.buttons, cast(Button){ value=it, label=it.label, shortcut=it.shortcut, submenuIcon=cast(bool)it.submenu })

				if it.submenu  it.submenuFrame = makeContextMenu(state, it.submenu, contextMenu, buttonPaddingRight, false)
			}
		}

		return contextMenu
	}

	local contextMenu = makeContextMenu(state, items, NULL, buttonPaddingRight, true)
	contextMenu.data  = [cbChoice] (choice:int) { cbChoice("", nil) }
	contextMenu.x     = x
	contextMenu.y     = y

	for state.contextMenus  insert(state.frames, it)

	state.layoutNeedsUpdate = true
	limitMenuPosition(state, contextMenu)

	if cbButtonOption ~= NULL {
		state.onOption.__contextMenuButtons = [cbButtonOption] (buttons:Buttons, buttonIndex:int) {
			local button = buttons.buttons[buttonIndex]
			local item   = cast(MenuItem) button.value

			if item.submenu  return

			cbButtonOption(item.name, item.data)
		}
	}

	state.onMouseEnter.__contextMenuButtons = [state] (buttons:Buttons, buttonIndex:int) {
		local button = buttons.buttons[buttonIndex]
		local item   = cast(MenuItem) button.value

		local frame                           = buttons.frame
		local menusToShow: Table(Frame, bool) = {[frame]=true}

		while frame.parentFrame ~= NULL {
			frame              = frame.parentFrame
			menusToShow[frame] = true
		}

		-- @UX: Don't hide (or show) submenus until after a delay (or click to show).
		for state.contextMenus  if it.active and not menusToShow[it] {
			it.active               = false
			state.layoutNeedsUpdate = true
		}

		if not item.submenu  return

		item.submenuFrame.active = true
		item.submenuFrame.x      = buttons.parent.layoutX + buttons.parent.layoutWidth - 3
		item.submenuFrame.y      = math.round(buttons.layoutY + (buttonIndex-1) * buttons.buttonHeight) - SPACING
		state.layoutNeedsUpdate  = true
		limitMenuPosition(state, item.submenuFrame)
	}

	state.onAction.__contextMenuButtons = [state,cbChoice] (buttons:Buttons, buttonIndex:int, source:ActionSource) {
		local button = buttons.buttons[buttonIndex]
		local item   = cast(MenuItem) button.value

		if item.submenu  return

		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		cbChoice(item.name, item.data)
		scheduleSaveWorkspace()
	}

	if cbDrawButton ~= NULL {
		state.onDraw.__contextMenuButtons = [state,cbDrawButton] (buttons:Buttons, w,h:int) {
			local buttonH = math.round(buttons.buttonHeight)

			for buttons.buttons {
				local item    = cast(MenuItem) it.value
				local offsetY = ((itIndex-1) * buttonH)

				LG.pushAll()
				LG.translate(0, offsetY)
				intersectScissor(buttons.layoutX, buttons.layoutY+offsetY, w, buttonH)
				cbDrawButton(item.name, item.data, w, buttonH)
				LG.pop()
			}
		}
	}
}

export showContextMenu :: (state:State, items:[]string, cbChoice:(choice:int)) {
	local mx, my = LM.getPosition()
	state.showContextMenu!(mx, my, items, cbChoice)
}
export showContextMenu :: (state:State, x,y:int, items:[]string, cbChoice:(choice:int)) {
	state.hideContextMenu!()

	local buttons     = state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16 })
	local contextMenu = state.frame  !({ data=cbChoice, x=x, y=y, minWidth=CONTEXT_MENU_MIN_WIDTH, layout=.FLOATING, style=.CONTEXT_MENU, temp=true, buttons })
	local choice      = 0

	for items {
		local ok, label, shortcut = matchPattern(it, "^(.*)\t(.*)$")
		if it == "-" {
			insert(contextMenu, state.separator!({ thick=false }))
			buttons = state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16 })
			insert(contextMenu, buttons)
		} elseif ok {
			choice += 1
			insert(buttons.buttons, cast(Button){ value=choice, label=cast(string)label, shortcut=cast(string)shortcut })
		} else {
			choice += 1
			insert(buttons.buttons, cast(Button){ value=choice, label=it })
		}
	}

	state.contextMenus = {contextMenu}
	insert(state.frames, contextMenu)

	state.layoutNeedsUpdate = true
	limitMenuPosition(state, contextMenu)

	state.onAction.__contextMenuButtons = [state,cbChoice] (buttons:Buttons, buttonIndex:int, source:ActionSource) {
		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		cbChoice(cast(int) buttons.buttons[buttonIndex].value)
		scheduleSaveWorkspace()
	}
}

export showContextMenuWithInput :: (state:State, value:string, items:[]string, cbChoice:(choice:int), cbInput:(text:string)=NULL, cbSubmit:(text:string)=NULL, cbOption:()=NULL, inputTooltip="", minWidth=0) {
	local mx, my = LM.getPosition()
	state.showContextMenuWithInput!(mx, my, value, items, cbChoice, cbInput, cbSubmit, cbOption, inputTooltip, minWidth)
}
export showContextMenuWithInput :: (state:State, x,y:int, value:string, items:[]string, cbChoice:(choice:int), cbInput:(text:string)=NULL, cbSubmit:(text:string)=NULL, cbOption:()=NULL, inputTooltip="", minWidth=0) {
	state.hideContextMenu!()

	local input       = state.inputText!({ name="__contextMenuInput", value=value, style=.CONTEXT_MENU, tooltip=inputTooltip })
	local buttons     = state.buttons  !({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16 })
	local contextMenu = state.frame    !({ data=cbChoice, x=x, y=y, minWidth=CONTEXT_MENU_MIN_WIDTH, layout=.FLOATING, style=.CONTEXT_MENU, temp=true, input, buttons })
	local choice      = 0

	for items {
		local ok, label, shortcut = matchPattern(it, "^(.*)\t(.*)$")
		if it == "-" {
			insert(contextMenu, state.separator!({ thick=false }))
			buttons = state.buttons!({ name="__contextMenuButtons", vertical=true, align=.LEFT, style=.CONTEXT_MENU, buttonMinHeight=16 })
			insert(contextMenu, buttons)
		} elseif ok {
			choice += 1
			insert(buttons.buttons, cast(Button){ value=choice, label=cast(string)label, shortcut=cast(string)shortcut })
		} else {
			choice += 1
			insert(buttons.buttons, cast(Button){ value=choice, label=it })
		}
	}

	state.contextMenus = {contextMenu}
	insert(state.frames, contextMenu)

	state.layoutNeedsUpdate = true
	limitMenuPosition(state, contextMenu)

	if cbInput ~= NULL {
		state.onAction.__contextMenuInput = [cbInput] (input:InputText, _:int, source:ActionSource) {
			cbInput(input.value)
			scheduleSaveWorkspace()
		}
	}
	-- if cbOption ~= NULL {
	-- 	state.onOption.__contextMenuInput = [cbOption] (input:InputText, _:int) {
	-- 		cbOption()
	-- 	}
	-- }

	state.onSubmit.__contextMenuInput = [state,cbChoice,cbSubmit] (input:InputText) {
		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		if cbSubmit ~= NULL  cbSubmit(input.value)
		cbChoice(0)
		scheduleSaveWorkspace()
	}

	state.onAction.__contextMenuButtons = [state,cbChoice] (buttons:Buttons, buttonIndex:int, source:ActionSource) {
		state.contextMenus[1].data = NULL -- So hideContextMenu() doesn't call the callback too!
		state.hideContextMenu!()
		cbChoice(cast(int) buttons.buttons[buttonIndex].value)
		scheduleSaveWorkspace()
	}

	state.setFocus!(input)
	input.field.selectAll!()
}

export hideContextMenu :: (state:State, mayDeactivateSubmenu=false) -> (success:bool) {
	local contextMenus = state.contextMenus
	if not contextMenus  return false

	if mayDeactivateSubmenu {
		local activeCount = 0
		for contextMenus  if it.active  activeCount += 1

		if activeCount >= 2 {
			for < contextMenus  if it.active {
				it.active = false
				return true
			}
		}
	}

	for contextMenus  state.delete!(it)
	state.contextMenus = {}

	local mx, my = LM.getPosition()
	state.onMouseMoved!(mx, my, 0, 0)

	state.onAction    .__contextMenuButtons = nil
	state.onMouseEnter.__contextMenuButtons = nil
	state.onOption    .__contextMenuButtons = nil
	state.onDraw      .__contextMenuButtons = nil
	state.onAction    .__contextMenuInput   = nil
	state.onSubmit    .__contextMenuInput   = nil
	-- state.onOption    .__contextMenuInput   = nil

	local cbChoice = cast((choice:int)) contextMenus[1].data
	if cbChoice ~= NULL  cbChoice(0)

	return true
}



export showTextPrompt :: (state:State, label:string, value:string, cbInput:(text:string), inputTooltip="", minWidth=0) -> Frame {
	state.hideContextMenu!() -- Because why not?

	local input = state.inputText!({ name="__textPromptInput", value=value, style=.CONTEXT_MENU, tooltip=inputTooltip })

	local prompt = state.frame!({ name=newName"__textPrompt", layout=.FLOATING, modal=true, temp=true, minWidth=CONTEXT_MENU_MIN_WIDTH,
		state.text!({ text=label }),
		input,
	})

	insert(state.frames, prompt)
	state.layoutNeedsUpdate = true

	state.onSubmit.__textPromptInput = [state,prompt,cbInput] (input:InputText) {
		-- state.delete!(prompt) -- No, allow user code to keep the prompt open!

		cbInput(input.value)
		scheduleSaveWorkspace()

		if state.exists!(prompt) and state.focusId ~= input.id {
			state.setFocus!(input)
			input.field.selectAll!()
		}
	}

	state.setFocus!(input)
	input.field.selectAll!()

	return prompt
}



export delete :: (state:State, el:Element, updateInteractions=true) {
	updateLayoutIfNeeded(state) -- Needed for parents. @Speed

	if el.type == Frame {
		local frame    = cast(Frame) el
		local found, i = indexOf(state.frames, frame)
		if not found  return

		unregisterTree(state, frame, updateInteractions)
		remove(state.frames, i)

	} else {
		local found, i = indexOf(el.parent, el)
		if not found  return

		unregisterTree(state, el, updateInteractions)
		remove(el.parent, i)
	}
}



local shouldHighlight :: (state:State, el:$T) -> bool {
	if el.id == state.activeId or el.id == state.hoveredId  return true

	local mod = state.activeId ? state.activeMod : getModifierKey()
	if not (mod == .S or mod == .CS)  return false

	local other = cast(T) state.elementsById[state.activeId ?: state.hoveredId]
	if other      == NULL  return false
	if other.type ~= T     return false

	!if    T == Slider     return (indexOf(other.linkMultiDrag, el.name))
	elseif T == Direction  return (indexOf(other.linkMultiDrag, el.name))
	elseif T == Color      return (indexOf(other.linkMultiDrag, el.name))
}



local intersectScissor :: (x,y,w,h:int) {
	LG.intersectScissor(x, y, math.max(w, 0), math.max(h, 0))
}



local drawSliderReadout :: (rightX:int, topY:int, height:int, handleX:int, value:float, valueMultiplierForFormat:float, formatString:string, formatStringIfZero:string, colorText,colorShadow:love.Color, opacity:float) {
	if value == 0 and formatStringIfZero  formatString = formatStringIfZero

	if not formatString  return

	local text  = format(formatString, value * valueMultiplierForFormat)
	local textW = fontSmall.getWidth!(text)
	local textX = rightX - SPACING - textW
	local textY = topY + (height - fontNormal.getHeight!()) // 2

	local MIN_DIST_TO_HANDLE :: 5
	if textX < handleX+MIN_DIST_TO_HANDLE  textX = handleX-MIN_DIST_TO_HANDLE - textW

	LG.setFont(fontSmall)
	LG.setColor(colorShadow[1], colorShadow[2], colorShadow[3], colorShadow[4]*opacity)
	LG.print(text, textX+1, textY+1)
	LG.setColor(colorText[1], colorText[2], colorText[3], colorText[4]*opacity)
	LG.print(text, textX, textY)
	LG.setFont(fontNormal)
}



local applyLimitMultiplier :: (slider:Slider, value:float) -> float {
	value = (value - slider.limitCenter) * getLimitMultiplier(slider) + slider.limitCenter
	if slider.isInt  value = math.round(value)
	return value
}

local getLimitMultiplier :: (slider:Slider) -> float {
	local project = app.projects[app.currentProjectIndex] -- @Cleanup: Remove project stuff from GUI.
	local limit   = project.guiLimits[slider.limitName]
	return limit ~= NULL ? limit : 1
}

local setLimitMultiplier :: (slider:Slider, limitMultiplier:float) {
	if not slider.limitName  return

	local project = app.projects[app.currentProjectIndex] -- @Cleanup: Remove project stuff from GUI.
	project.guiLimits[slider.limitName] = limitMultiplier

	-- Note: We're not calling scheduleSaveWorkspace() here - that's the caller's responsibility!
}

local forgetLimitMultiplier :: (slider:Slider) {
	if not slider.limitName  return

	local project = app.projects[app.currentProjectIndex] -- @Cleanup: Remove project stuff from GUI.
	project.guiLimits[slider.limitName] = NULL

	-- Note: We're not calling scheduleSaveWorkspace() here - that's the caller's responsibility!
}



local applyExponential :: (slider:Slider, value01:float, exponent:float) -> float {
	if not slider.exponential  return value01

	local zero01      = slider.min / (slider.min - slider.max)
	local rangeOnSide = (value01 < zero01) ? zero01 : 1-zero01

	value01 = math.powKeepSign((value01 - zero01) / rangeOnSide, exponent) * rangeOnSide + zero01

	return value01
}



local commitValueFromInput :: (state:State, slider:Slider, text:string) {
	local ok, n = stringToFloat(text)
	if not ok  return

	n = n / slider.readoutMulti

	if slider.isInt  n = math.round(n)

	if n < 0 and slider.min == 0 and slider.limitCenter == 0 {
		n = 0
	}

	if n == slider.value  return

	triggerBeginEvent(state, slider, "", 0, alsoEnsureEnabled=false)
	slider.value = n
	triggerActionEvent(state, slider, "", 0, .UNKNOWN, alsoEnd=true)
}

local commitValueFromInput :: (state:State, direction:Direction, text:string) {
	local ok, angle = stringToFloat(text)
	if not ok  return

	angle = angle / 360 * math.TAU

	if angle == direction.angle  return

	triggerBeginEvent(state, direction, "", 0, alsoEnsureEnabled=false)
	direction.angle = angle
	triggerActionEvent(state, direction, "", 0, .UNKNOWN, alsoEnd=true)
}

local commitValueFromInput :: (state:State, colorEl:Color, component:int, text:string) {
	local ok, value = stringToFloat(text)
	if not ok  return

	value = value / (component == 1 ? 360 : 100)
	value = math.clamp01(value)

	if value == colorEl.color[component]  return

	triggerBeginEvent(state, colorEl, "", component, alsoEnsureEnabled=false)
	colorEl.color[component] = value
	triggerActionEvent(state, colorEl, "", component, .UNKNOWN, alsoEnd=true)
}



export scrollTo :: (scrollable:Scrollable, scroll:int, limit=false) {
	scrollable.scroll       = scroll
	scrollable.scrollSource = scroll
	scrollable.scrollTarget = scroll

	if limit  limitScroll(scrollable)
}

export scrollTo :: (state:State, scrollable:Scrollable, scroll:int, limit=false) {
	scrollTo(scrollable, scroll, limit)
}

export scrollIntoView :: (state:State, el:Element, subid:int) {
	updateLayoutIfNeeded(state)

	local scrollCurrent = getScrollOffset(el)
	local targetY1      = el.layoutY + scrollCurrent
	local targetY2      = targetY1 + el.layoutHeight

	if el.type == Buttons {
		local buttons = cast(Buttons) el
		if buttons.vertical {
			targetY2 = math.round(targetY1+(subid  )*buttons.buttonHeight) -- Note: We change targetY1 on the next line!
			targetY1 = math.round(targetY1+(subid-1)*buttons.buttonHeight)
		}
	}

	while true {
		el = el.parent
		if el == NULL  break

		if el.type == Scrollable {
			local scrollable = cast(Scrollable) el
			local scrollOld  = scrollable.scrollTarget
			scrollCurrent    = scrollCurrent - scrollOld

			local scrollDelta = 0
			local y1          = scrollable.layoutY + scrollCurrent                           + (SCROLLABLE_PADDING + SPACING) -- @UX: The top of the target element is partially behind the scrollable's shadow. Not great!
			local y2          = scrollable.layoutY + scrollCurrent + scrollable.layoutHeight - (SCROLLABLE_PADDING + SPACING)

			if targetY2 > y2  scrollDelta = y2 - targetY2
			if targetY1 < y1  scrollDelta = y1 - targetY1

			if scrollDelta {
				scrollTo(scrollable, scrollable.scrollTarget+scrollDelta, limit=true)
				scrollDelta = scrollable.scrollTarget - scrollOld

				scrollCurrent = scrollCurrent + scrollDelta
				targetY1      = targetY1      + scrollDelta
				targetY2      = targetY2      + scrollDelta
			}
		}
	}
}



local getVisibleAreaInLocalSpace :: (state:State, el0:Element) -> (x,y,w,h:int) {
	updateLayoutIfNeeded(state)

	-- @Incomplete: Check isElementVisible().
	local el     = el0
	local x1     = el.layoutX
	local y1     = el.layoutY
	local x2     = x1 + el.layoutWidth
	local y2     = y1 + el.layoutHeight
	local offset = 0

	while true {
		el = el.parent
		if el == NULL  break

		if el.type == Scrollable {
			local scrollable  = cast(Scrollable) el
			x1                = math.max(x1, scrollable.layoutX)
			y1                = math.max(y1, scrollable.layoutY)
			x2                = math.min(x2, scrollable.layoutX+scrollable.layoutWidth)
			y2                = math.min(y2, scrollable.layoutY+scrollable.layoutHeight)
			offset           += scrollable.scrollTarget
		}
	}

	return x1-el0.layoutX, y1-el0.layoutY+offset, x2-x1, y2-y1
}



export getButtonLayout :: (state:State, buttons:Buttons, i:int) -> (x,y,w,h:int) {
	updateLayoutIfNeeded(state)

	if buttons.vertical {
		local y1 = math.round(buttons.buttonHeight*(i-1))
		local h  = math.round(buttons.buttonHeight*(i  )) - y1
		return buttons.layoutX, buttons.layoutY+y1, buttons.layoutWidth, h
	} else {
		local x1 = math.round(buttons.buttonWidth*(i-1))
		local w  = math.round(buttons.buttonWidth*(i  )) - x1
		return buttons.layoutX+x1, buttons.layoutY, w, buttons.layoutHeight
	}
}



local newName :: (prefix:string) -> string {
	static n  = 0
	n        += 1
	return format("%s%d", prefix, n)
}



export exists :: (state:State, el:Element) -> bool {
	return state.elementsById[el.id] ~= NULL
}


