--[[============================================================
--=
--=  GUI setup
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

export MAIN_PANEL_WIDTH    :: 450
export DIALOG_WIDTH        :: 400
export DIALOG_WIDTH_LOG    :: 700
export DIALOG_WIDTH_EXPORT :: 700

local BIG_BUTTON_HEIGHT    :: 40
local MEDIUM_BUTTON_HEIGHT :: 16



export setupGuiFrames :: () {
	guiState.frames = {
		guiState.frame!({ name="main", width=MAIN_PANEL_WIDTH,
			guiState.tabs!({ name="projects", specialLastTab=true }),
			guiState.text!({ height=1 }), -- Spacer.

			guiState.hbox!({
				guiState.buttons!({ name="menuAndSettingsButtons", buttons={{name="menu",label="File"},{name="toggleProjectSettings",label="Project",tooltip="Toggle project settings"}} }),
				guiState.buttons!({ buttons={{name="undo",image="iconLeft",tooltip="Undo  ("..ctrlText.."+Z)"},{name="redo",image="iconRight",tooltip="Redo  ("..ctrlText.."+Shift+Z)"}} }),
				guiState.text!({ name="undoRedoText", text="0/0", size=1 }),
			}),
			guiState.separator!({ thick=true }),

			guiState.vbox!({ name="projectSettings",
				guiState.section!({ name="customDataProjectSection", label="Custom data", icon16="data",
					guiState.inputText!({ name="customDataProject" }),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ label="Pixelate",
					guiState.hbox!({
						guiState.checkbox!({ name="pixelateWorld",    label="world"    }),
						guiState.checkbox!({ name="pixelateTextures", label="textures" }),
					}),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ name="backgroundSection", label="Background", icon16="background",
					guiState.hbox!({
						guiState.color!({ name="bgColor", alpha=false, weight=1 }),
						guiState.colorPreview!({ linkColors={"bgColor"} }),
					}),
					guiState.hbox!({
						guiState.slider!({ name="bgChecker", labelLeft="pattern", defaultValue=0, min=-1, max=1,   exponential=true, readoutMulti=100,     readout="%d%%",  weight=2 }),
						guiState.slider!({ name="bgSize",    labelLeft="size",    defaultValue=8, min=1,  max=128, exponential=true, isInt=true, inset=30, readout="%d px", weight=1 }), -- @UX: Maybe make this a global configuration?
					}),
					guiState.hbox!({
						guiState.inputText!({ name="bgPath", labelLeft="path", tooltip="Absolute path, or relative to the .hotparticles file (Right-click for recent)", weight=1 }),
						guiState.buttons!({ buttons={
							{name="bgChoose",   image="iconFolder",            tooltip="Browse files"},
							{name="bgRelative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
							{name="bgReload",   image="iconReload",            tooltip="Reload background"},
						}}),
					}),
					guiState.hbox!({
						guiState.slider!({ name="bgScale", labelLeft="scale", defaultValue=1, min=0, max=4, exponential=true, limitName="bgScale", readoutMulti=100, readout="%d%%", weight=1 }),
						guiState.checkbox!({ name="bgRepeatX", label="repeat x" }),
						guiState.checkbox!({ name="bgRepeatY", label="repeat y" }),
					}),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ name="emitterMovementSection", label="EmitterMovem.", tooltip="Emitter movement", icon16="movement",
					guiState.radio!({ name="emitterMovement",
						buttons = {
							{value=Movement.NONE,      label="none",      tooltip="No movement"},
							{value=Movement.CIRCLE,    label="circle",    tooltip="Circle, or back and forth"},
							{value=Movement.EIGHT,     label="eight",     tooltip="Numeral eight, on the side"},
							{value=Movement.IRREGULAR, label="irregular", tooltip="Irregular movement"},
						}
					}),
					guiState.hbox!({
						guiState.vbox!({ weight=1,
							guiState.slider!({ name="emitterMovementSx", labelLeft="scale x", canDisable=true, defaultValue=1, min=0, max=2, limitName="emitterMovementScale", readoutMulti=100, readout="%d%%", linkMultiDrag={"emitterMovementSy"} }),
							guiState.slider!({ name="emitterMovementSy", labelLeft="scale y", canDisable=true, defaultValue=1, min=0, max=2, limitName="emitterMovementScale", readoutMulti=100, readout="%d%%", linkMultiDrag={"emitterMovementSx"} }),
						}),
						guiState.slider!({ name="emitterMovementSpeed", labelLeft="speed", inset=40, defaultValue=1, min=-8, max=8, limitName="emitterMovementSpeed", readoutMulti=100, readout="%d%%", weight=1.5 }),
					}),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ name="regionSection", label="Region", tooltip="Visual rectangular guide", icon16="region",
					guiState.slider!({ name="regionWidth",  labelLeft="width",  canDisable=true, defaultValue=0, min=0, max=1024, exponential=true, isInt=true, limitName="region", readout="%d", linkMultiDrag={"regionHeight"} }),
					guiState.slider!({ name="regionHeight", labelLeft="height", canDisable=true, defaultValue=0, min=0, max=1024, exponential=true, isInt=true, limitName="region", readout="%d", linkMultiDrag={"regionWidth"} }),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ name="scaleGlobalSection", label="GlobalScale", tooltip="Scale all parameters in all systems", icon16="scaleGlobal",
					guiState.slider!({ name="scaleGlobalTime",  labelLeft="time",  canDisable=true, defaultValue=1, min=0, max=4, exponential=true, limitName="scaleGlobalTime",  readoutMulti=100, readout="%d%%" }),
					guiState.slider!({ name="scaleGlobalSpace", labelLeft="space", canDisable=true, defaultValue=1, min=0, max=4, exponential=true, limitName="scaleGlobalSpace", readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleGlobalSize"} }),
					guiState.slider!({ name="scaleGlobalSize",  labelLeft="size",  canDisable=true, defaultValue=1, min=0, max=4, exponential=true, limitName="scaleGlobalSize",  readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleGlobalSpace"} }),
				}),

				guiState.separator!({ thick=true }),
			}),

			guiState.vbox!({ name="system",
				guiState.tabs!({ name="systems", specialLastTab=true }),

				guiState.scrollable!({
					guiState.section!({ name="customDataSystemSection", label="Custom data", icon16="data",
						guiState.inputText!({ name="customDataSystem" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="textureSection", label="Texture", tooltip="Particle texture", icon16="texture",
						guiState.radio!({ name="textureName", labelLeft="preset" }),
						guiState.hbox!({
							guiState.inputText!({ name="texturePath", labelLeft="path", tooltip="Absolute path, or relative to the .hotparticles file (Right-click for recent)", weight=1 }),
							guiState.buttons!({ buttons={
								{name="textureChoose",   image="iconFolder",            tooltip="Browse files"},
								{name="textureRelative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
								{name="textureReload",   image="iconReload",            tooltip="Reload texture"},
							}}),
						}),
						guiState.hbox!({
							guiState.slider!({ name="textureOffsetX", defaultValue=.5, min=0, max=1, limitName="textureOffset", limitCenter=.5, readoutMulti=100, readout="%d%%", weight=1, labelLeft="offset x/y" }),
							guiState.slider!({ name="textureOffsetY", defaultValue=.5, min=0, max=1, limitName="textureOffset", limitCenter=.5, readoutMulti=100, readout="%d%%", weight=1 }),
							guiState.buttons!({ name="animationButton", buttons={{label="Animation",tooltip="Create/edit particle animation (Right-click for options)"}} }),
						}),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="scaleAllSection", label="ScaleAll", tooltip="Scale all parameters in this system", icon16="scale",
						guiState.slider!({ name="scaleTime",  labelLeft="time",  canDisable=true, defaultValue=1, min=0, max=4, exponential=true, limitName="scaleTime",  readoutMulti=100, readout="%d%%" }),
						guiState.slider!({ name="scaleSpace", labelLeft="space", canDisable=true, defaultValue=1, min=0, max=4, exponential=true, limitName="scaleSpace", readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleSize"} }),
						guiState.slider!({ name="scaleSize",  labelLeft="size",  canDisable=true, defaultValue=1, min=0, max=4, exponential=true, limitName="scaleSize",  readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleSpace"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="spawnSection", label="Spawn", tooltip="Particle spawning", icon16="spawn",
						guiState.radio!({ name="insertMode", labelLeft="layer", buttons={
							{value=LG.ParticleInsertMode.TOP,    label="front",  tooltip="Insert at top"},
							{value=LG.ParticleInsertMode.BOTTOM, label="back",   tooltip="Insert at bottom"},
							{value=LG.ParticleInsertMode.RANDOM, label="random", tooltip="Insert randomly"},
						}}),
						guiState.slider!({ name="emissionRate",   labelLeft="rate",                              defaultValue=1, min=0, max=512,  exponential=true,             limitName="emissionRate",   readout="%.1f / sec" }),
						guiState.slider!({ name="kickStartEmit",  labelLeft="emit at start",    canDisable=true, defaultValue=0, min=0, max=1024, exponential=true, isInt=true, limitName="kickStartEmit",  readout="%.0f" }),
						guiState.slider!({ name="kickStartSteps", labelLeft="kick-start steps", canDisable=true, defaultValue=0, min=0, max=128,  exponential=true, isInt=true, limitName="kickStartSteps", readout="%.0f", readoutZero="no kick-start" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="lifetimeSection", label="Lifetime", icon16="time",
						guiState.hbox!({ labelLeft="emitter",
							guiState.slider!({ name="emitterLifetime", defaultValue=0, min=0, max=16, exponential=true, limitName="emitterLifetime", readout="%.2f sec"--[[, readoutZero="∞"]], weight=1 }),
							guiState.checkbox!({ name="emitterContinuous", label="continuous", tooltip="Infinite lifetime" }),
						}),
						guiState.slider!({ name="particleLifetimeMin", labelLeft="particle min", defaultValue=1, min=0, max=16, exponential=true, limitName="particleLifetime", readout="%.2f sec", linkMultiDrag={"particleLifetimeMax"} }),
						guiState.slider!({ name="particleLifetimeMax", labelLeft="particle max", defaultValue=1, min=0, max=16, exponential=true, limitName="particleLifetime", readout="%.2f sec", linkMultiDrag={"particleLifetimeMin"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="areaSection", label="Area", tooltip="Spawning area", icon16="areaSize",
						guiState.radio!({ name="areaDistribution", labelLeft="distribution", buttons={
							{value=LG.AreaSpreadDistribution.NONE,             label="none",    tooltip="None"},
							{value=LG.AreaSpreadDistribution.ELLIPSE,          label="ellip",   tooltip="Ellipse"},
							{value=LG.AreaSpreadDistribution.UNIFORM,          label="rect",    tooltip="Rectangle/uniform"},
							{value=LG.AreaSpreadDistribution.BORDER_ELLIPSE,   label="b.ellip", tooltip="Border ellipse"},
							{value=LG.AreaSpreadDistribution.BORDER_RECTANGLE, label="b.rect",  tooltip="Border rectangle"},
							{value=LG.AreaSpreadDistribution.NORMAL,           label="norm",    tooltip="Normal distribution"},
						}}),
						guiState.hbox!({ name="areaParams", active=false,
							guiState.direction!({ name="areaAngle", labelLeft="angle", canDisable=true }),
							guiState.vbox!({ weight=1,
								guiState.slider!({ name="areaDx", labelLeft="dx", canDisable=true, inset=30, defaultValue=100, min=0, max=1000, exponential=true, limitName="areaSize", readout="%.0f", linkMultiDrag={"areaDy"} }),
								guiState.slider!({ name="areaDy", labelLeft="dy", canDisable=true, inset=30, defaultValue=100, min=0, max=1000, exponential=true, limitName="areaSize", readout="%.0f", linkMultiDrag={"areaDx"} }),
								guiState.checkbox!({ name="areaRelative", label="direction relative to area center", inset=14, weight=1 }),
							}),
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="directionSection", label="Direction", tooltip="Movement direction", icon16="direction",
						guiState.hbox!({
							guiState.direction!({ name="direction", canDisable=true, linkSpread="directionSpread" }),
							guiState.slider!({ name="directionSpread", canDisable=true, labelLeft="spread", defaultValue=0, min=0, max=math.TAU, readoutMulti=360/math.TAU, readout="%d°", weight=1, inset=50 }),
						}),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="speedSection", label="Speed", tooltip="Initial velocity", icon16="speed",
						guiState.slider!({ name="speedMin", labelLeft="min", canDisable=true, defaultValue=0, min=-2000, max=2000, exponential=true, limitName="speed", readout="%.0f / sec", linkMultiDrag={"speedMax"} }),
						guiState.slider!({ name="speedMax", labelLeft="max", canDisable=true, defaultValue=0, min=-2000, max=2000, exponential=true, limitName="speed", readout="%.0f / sec", linkMultiDrag={"speedMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="accelerationLinearSection", label="AccLinear", tooltip="Acceleration, linear", icon16="accelerationLinear",
						guiState.slider!({ name="accLinearXmin", labelLeft="xmin", canDisable=true, defaultValue=0, min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearXmax"} }),
						guiState.slider!({ name="accLinearXmax", labelLeft="xmax", canDisable=true, defaultValue=0, min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearXmin"} }),
						guiState.slider!({ name="accLinearYmin", labelLeft="ymin", canDisable=true, defaultValue=0, min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearYmax"} }),
						guiState.slider!({ name="accLinearYmax", labelLeft="ymax", canDisable=true, defaultValue=0, min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearYmin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="accelerationRadialSection", label="AccRadial", tooltip="Acceleration, radial", icon16="accelerationRadial",
						guiState.slider!({ name="accRadialMin", labelLeft="min", canDisable=true, defaultValue=0, min=-10000, max=10000, exponential=true, limitName="radialAcceleration", readout="%.0f / sec²", linkMultiDrag={"accRadialMax"} }),
						guiState.slider!({ name="accRadialMax", labelLeft="max", canDisable=true, defaultValue=0, min=-10000, max=10000, exponential=true, limitName="radialAcceleration", readout="%.0f / sec²", linkMultiDrag={"accRadialMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="accelerationTangentSection", label="AccTangent", tooltip="Acceleration, tangential", icon16="accelerationTangent",
						guiState.slider!({ name="accTangentMin", labelLeft="min", canDisable=true, defaultValue=0, min=-10000, max=10000, exponential=true, limitName="tangentialAcceleration", readout="%.0f / sec²", linkMultiDrag={"accTangentMax"} }),
						guiState.slider!({ name="accTangentMax", labelLeft="max", canDisable=true, defaultValue=0, min=-10000, max=10000, exponential=true, limitName="tangentialAcceleration", readout="%.0f / sec²", linkMultiDrag={"accTangentMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="dampingSection", label="Damping", tooltip="Velocity damping", icon16="damping",
						guiState.slider!({ name="linearDampingMin", labelLeft="min", canDisable=true, defaultValue=0, min=-20, max=20, exponential=true, limitName="linearDamping", readout="%.2f", linkMultiDrag={"linearDampingMax"} }),
						guiState.slider!({ name="linearDampingMax", labelLeft="max", canDisable=true, defaultValue=0, min=-20, max=20, exponential=true, limitName="linearDamping", readout="%.2f", linkMultiDrag={"linearDampingMin"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="rotationSection", label="Rotation", tooltip="Particle rotation", icon16="rotation",
						guiState.hbox!({
							guiState.direction!({ name="rotationMin", canDisable=true, linkOther="rotationMax", linkMultiDrag={"rotationMax"}, labelLeft="min/max" }),
							guiState.direction!({ name="rotationMax", canDisable=true, linkOther="rotationMin", linkMultiDrag={"rotationMin"}, }),
							guiState.checkbox!({ name="rotationRelative", label="rotation relative to direction", inset=10 }),
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="spinSection", label="Spin", tooltip="Particle spin", icon16="spin",
						guiState.slider!({ name="spinMin",       labelLeft="at start",  canDisable=true, defaultValue=0, min=-8, max=8, exponential=true, limitName="spin", readout="%.2f turns / sec", linkMultiDrag={"spinMax"} }),
						guiState.slider!({ name="spinMax",       labelLeft="at end",    canDisable=true, defaultValue=0, min=-8, max=8, exponential=true, limitName="spin", readout="%.2f turns / sec", linkMultiDrag={"spinMin"} }),
						guiState.slider!({ name="spinVariation", labelLeft="variation", canDisable=true, defaultValue=0, min=0,  max=1, readoutMulti=100, readout="%d%%" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="sizesSection", label="Size", icon16="size",
						guiState.hbox!({ name="sizeContainer1", data=1, labelLeft="#1",
							guiState.buttons!({ data=1, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size1", data=1, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer2", data=2, labelLeft="#2", active=false,
							guiState.buttons!({ data=2, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size2", data=2, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer3", data=3, labelLeft="#3", active=false,
							guiState.buttons!({ data=3, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size3", data=3, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer4", data=4, labelLeft="#4", active=false,
							guiState.buttons!({ data=4, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size4", data=4, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer5", data=5, labelLeft="#5", active=false,
							guiState.buttons!({ data=5, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size5", data=5, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer6", data=6, labelLeft="#6", active=false,
							guiState.buttons!({ data=6, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size6", data=6, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer7", data=7, labelLeft="#7", active=false,
							guiState.buttons!({ data=7, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size7", data=7, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer8", data=8, labelLeft="#8", active=false,
							guiState.buttons!({ data=8, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size8", data=8, defaultValue=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.slider!({ name="sizeVariation", labelLeft="variation", canDisable=true, defaultValue=0, min=0, max=1, readoutMulti=100, readout="%d%%" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="colorSection", label="Color", icon16="brush",
						guiState.hbox!({
							guiState.vbox!({ name="colors", weight=1,
								guiState.hbox!({ name="colorContainer1", labelLeft="#1",
									guiState.buttons!({ data=1, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=1, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color1", data=1, weight=1, linkMultiDrag={"color2","color3","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer2", labelLeft="#2", active=false,
									guiState.buttons!({ data=2, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=2, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color2", data=2, weight=1, linkMultiDrag={"color1","color3","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer3", labelLeft="#3", active=false,
									guiState.buttons!({ data=3, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=3, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color3", data=3, weight=1, linkMultiDrag={"color1","color2","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer4", labelLeft="#4", active=false,
									guiState.buttons!({ data=4, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=4, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color4", data=4, weight=1, linkMultiDrag={"color1","color2","color3","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer5", labelLeft="#5", active=false,
									guiState.buttons!({ data=5, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=5, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color5", data=5, weight=1, linkMultiDrag={"color1","color2","color3","color4","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer6", labelLeft="#6", active=false,
									guiState.buttons!({ data=6, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=6, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color6", data=6, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer7", labelLeft="#7", active=false,
									guiState.buttons!({ data=7, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=7, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color7", data=7, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color6","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer8", labelLeft="#8", active=false,
									guiState.buttons!({ data=8, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=8, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color8", data=8, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color6","color7"} }),
								}),
							}),
							guiState.colorPreview!({ name="colorPreview", linkColors={"color1","color2","color3","color4","color5","color6","color7","color8"} }),
						}),
						guiState.radio!({ name="blendMode", labelLeft="blend mode",
							buttons = {
								{value=LG.BlendMode.ALPHA,    label="alpha"},
								{value=LG.BlendMode.ADD,      label="add"},
								{value=LG.BlendMode.SUBTRACT, label="subtract"},
								{value=LG.BlendMode.SCREEN,   label="screen"},
							},
						}),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="shaderSection", label="Shader", tooltip="Fragment shader", icon16="shader",
						guiState.hbox!({
							guiState.inputText!({ name="shaderPath", labelLeft="path", tooltip="Absolute path, or relative to the .hotparticles file", weight=1 }),
							guiState.buttons!({ buttons={
								{name="shaderChoose",   image="iconFolder",            tooltip="Browse files"},
								{name="shaderRelative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
								{name="shaderReload",   image="iconReload",            tooltip="Reload shader"},
							}}),
						}),
					}),
				}),
			}),
		}),

		guiState.frame!({ name="fileDialog", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ name="fileDialog_title", size=3 }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Bookmarks", weight=1 }),
				guiState.buttons!({ name="fileDialog_addBookmark", buttons={{image="iconAdd",tooltip="Add current folder to bookmarks"}} }),
			}),
			guiState.scrollable!({ height=120,
				guiState.buttons!({ name="fileDialog_bookmarks", vertical=true, align=.LEFT, style=.LIST }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="fileDialog_directory", tooltip="Current folder (Right-click for recent)" }),
			guiState.scrollable!({ name="fileDialog_itemsSrollable",
				guiState.buttons!({ name="fileDialog_items", vertical=true, align=.LEFT, style=.LIST, buttonMinHeight=MEDIUM_BUTTON_HEIGHT }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="fileDialog_filename" }),
			guiState.buttons!({ name="fileDialog_buttons", height=BIG_BUTTON_HEIGHT, buttons={
				{name="fileDialog_choose"},
				{name="util_popPanel", label="Cancel"},
			},
			}),
		}),

		guiState.frame!({ name="exportProject", width=DIALOG_WIDTH_EXPORT, modal=true, layout=.FLOATING, active=false,
			guiState.text!({ text="Export", size=3 }),

			guiState.separator!({ thick=false }),
			guiState.section!({ name="exportProject_baseDirectorySection", label="Base folder", icon16="folder",
				guiState.hbox!({
					guiState.inputText!({ name="exportProject_baseDirectory", tooltip="Absolute path, or relative to the .hotparticles file", weight=1 }),
					guiState.buttons!({ buttons={
						{name="exportProject_baseDirectory_choose",   image="iconFolder",            tooltip="Browse folders"},
						{name="exportProject_baseDirectory_relative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
					}}),
				}),
				guiState.hbox!({ labelLeft="resulting path",
					guiState.text!({ name="exportProject_baseDirectoryResult", weight=1 }),
					guiState.buttons!({ name="exportProject_baseDirectoryResultInfo", buttons={{image="iconEye"}} }),
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ name="exportProject_particlesSection", label="Particles", icon16="particles",
				guiState.hbox!({
					guiState.checkbox!({ name="exportProject_particles_writeFile", label="export particle systems" }),
					guiState.checkbox!({ name="exportProject_particles_overwrite", label="overwrite existing", tooltip="Overwrite existing files without confirmation" }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="exportProject_particles_path", labelLeft="output filename", placeholder="?.lua", tooltip="Absolute path, or relative to base folder", weight=1 }),
					guiState.buttons!({ buttons={
						{name="exportProject_particles_path_choose",   image="iconFolder",            tooltip="Browse files"},
						{name="exportProject_particles_path_relative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
					}}),
				}),
				guiState.hbox!({ labelLeft="resulting path",
					guiState.text!({ name="exportProject_particles_pathResult", weight=1 }),
					guiState.buttons!({ name="exportProject_particles_pathResultInfo", buttons={{image="iconEye"}} }),
				}),
				guiState.hbox!({
					guiState.buttons!({ name="exportProject_particles_template", labelLeft="template", align=.LEFT, buttonMinHeight=MEDIUM_BUTTON_HEIGHT, weight=1,
						buttons={{image="iconDown",label="defaultLuaModule"}},
					}),
					guiState.buttons!({ buttons={
						{name="exportProject_particles_templateChoose",   image="iconFolder",            tooltip="Browse files"},
						{name="exportProject_particles_templateRelative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
					}}),
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ name="exportProject_texturesSection", label="Textures", icon16="texture",
				guiState.hbox!({
					guiState.checkbox!({ name="exportProject_textures_copyFiles", label="copy texture files" }),
					guiState.checkbox!({ name="exportProject_textures_overwrite", label="overwrite existing", tooltip="Overwrite existing files without confirmation" }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="exportProject_textures_directory", labelLeft="output folder", tooltip="Absolute path, or relative to base folder", weight=1 }),
					guiState.buttons!({ buttons={
						{name="exportProject_textures_directory_choose",   image="iconFolder",            tooltip="Browse folders"},
						{name="exportProject_textures_directory_relative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
					}}),
				}),
				guiState.hbox!({ labelLeft="resulting paths",
					guiState.scrollable!({ height=fontNormal.getHeight!()+2*(gui.SCROLLABLE_PADDING+gui.SPACING), weight=1,
						guiState.text!({ name="exportProject_textures_pathResults" }),
					}),
					guiState.buttons!({ name="exportProject_textures_pathResultsInfo", buttons={{image="iconEye"}} }),
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ name="exportProject_clipboardSection", label="Clipboard", icon16="clipboard",
				guiState.buttons!({ align=.LEFT, buttonMinHeight=MEDIUM_BUTTON_HEIGHT, buttons={{name="exportProject_clipboard_export",label="Export to clipboard"}}}),
				guiState.hbox!({
					guiState.buttons!({ name="exportProject_clipboard_template", labelLeft="template", align=.LEFT, buttonMinHeight=MEDIUM_BUTTON_HEIGHT, weight=1,
						buttons={{image="iconDown",label="defaultLuaClipboard"}},
					}),
					guiState.buttons!({ buttons={
						{name="exportProject_clipboard_templateChoose",   image="iconFolder",            tooltip="Browse files"},
						{name="exportProject_clipboard_templateRelative", image="iconRelativeDirectory", tooltip="Toggle relative path"},
					}}),
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="exportProject_exportFiles",label="Export files"},{name="util_popPanel",label="Close"}},
			}),
		}),

		guiState.frame!({ name="preferences", width=DIALOG_WIDTH, modal=true, layout=.FLOATING, active=false,
			guiState.text!({ text="Preferences", size=3 }),

			guiState.separator!({ thick=true }),
			guiState.section!({ label="Max buffer size",
				guiState.inputText!({ name="preferences_maxBufferSize", tooltip="Default: 16000" }),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ label="File browser",
				guiState.checkbox!({ name="preferences_preferRelativePaths", label="Prefer relative paths", tooltip="Returned paths will be relative whenever possible" }),
			}),

			guiState.separator!({ thick=false }),
			guiState.section!({ label="Max recent",
				guiState.hbox!({
					guiState.inputText!({ name="preferences_maxRecentFiles"--[[, labelLeft="files"]], tooltip="Default: 15", weight=1 }),
					-- guiState.inputText!({ name="preferences_maxRecentFolders", labelLeft="folders", tooltip="Default: 4", weight=1, inset=45 }),
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ label="Projects",
				guiState.checkbox!({ name="preferences_initializeSystemInNewProjects", label="Start with default particle system", tooltip="If this is unchecked, the initial particle system in new projects will be completely empty" }),
				guiState.inputText!({ name="preferences_maxChanges", labelLeft="Undo history", tooltip="Default: 200" }),
			}),

			guiState.separator!({ thick=true }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT, buttons={{name="util_popPanel",label="Close"}} }),
		}),

		guiState.frame!({ name="log", width=DIALOG_WIDTH_LOG, modal=true, layout=.FLOATING, active=false,
			guiState.text!({ text="Log", size=3 }),

			guiState.separator!({ thick=false }),
			guiState.scrollable!({
				guiState.text!({ name="log_text" }),
			}),

			guiState.separator!({ thick=true }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT, buttons={{name="util_popPanel",label="Close"}} }),
		}),

		guiState.frame!({ name="animation", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ text="Animation", size=3 }),
			guiState.canvas!({ name="animation_preview", width=100, height=100 }),
			guiState.section!({ --[[name="animation_lifetimeSection",]] label="ParticleLifetime", icon16="time", labelWidth=120,
				guiState.slider!({ name="animation_particleLifetimeMin", labelLeft="min", defaultValue=1, min=0, max=16, exponential=true, limitName="particleLifetime", readout="%.2f sec", linkMultiDrag={"animation_particleLifetimeMax"} }),
				guiState.slider!({ name="animation_particleLifetimeMax", labelLeft="max", defaultValue=1, min=0, max=16, exponential=true, limitName="particleLifetime", readout="%.2f sec", linkMultiDrag={"animation_particleLifetimeMin"} }),
			}),
			guiState.separator!({ thick=true }),
			guiState.buttons!({ buttons={{name="animation_empty",label="Remove all frames"}} }),
			guiState.separator!({ thick=true }),
			guiState.section!({ label="Sequence", icon16="sequence", labelWidth=120,
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_areaPosition", labelLeft="area x/y",  value="0 0",           weight=1, tooltip="Top/left corner of first frame. Negative means offset from bottom/right corner of texture. Format: [x y]" }),
					guiState.inputText!({ name="animation_sequence_areaSize",     labelLeft="area size", value="0 0", inset=50, weight=1, tooltip="Size of area containing frames. Non-positive means offset from bottom/right corner of texture. Format: [width height] or [size]" }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_framePadding", labelLeft="padding", value="0",           weight=1, tooltip="Padding around each frame. Format: [paddingX paddingY] or [padding]" }),
					guiState.inputText!({ name="animation_sequence_frameSpacing", labelLeft="spacing", value="0", inset=50, weight=1, tooltip="Space between frames. Format: [spacingX spacingY] or [spacing]" }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_frameSize", labelLeft="frame size", value="10 10", weight=1, tooltip="Zero means full length. Format: [width height] or [size]" }),
					guiState.buttons!({ width=200, buttons={{name="animation_sequence_generateFromSize",label="Generate using frame size"}} }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_rows",    labelLeft="rows",    value="1",           weight=1 }),
					guiState.inputText!({ name="animation_sequence_columns", labelLeft="columns", value="1", inset=50, weight=1 }),
					guiState.buttons!({ width=200, buttons={{name="animation_sequence_generateFromDivision",label="Generate using rows+columns"}} }),
				}),
			}),
			guiState.scrollable!({
				guiState.vbox!({ name="animation_frames", inset=25 }),
			}),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT, buttons={
				{name="animation_ok",     label="OK"},
				{name="animation_cancel", label="Cancel"},
			}}),
		}),
	}
}



export panelStack: []string

export pushPanel :: (name:string) {
	assert(not indexOf(panelStack, name))
	if not guiState.setActive!(name, true)  return

	insert(panelStack, name)
}

export pushTempChoiceDialog :: (title:string, text:string, buttonList:[]gui.Button, cb:(choice:int), submitIndex=0, extraContent:gui.Element=NULL, width=DIALOG_WIDTH) {
	static tempN = 0 ; tempN += 1

	local name        = format("temp%d", tempN)
	local nameButtons = name.."_buttons"

	local frame = guiState.frame!({ name=name, temp=true, layout=.FLOATING, modal=true, width=width, active=false })
	insert(guiState.frames, frame)

	if title {
		insert(frame, guiState.text!({ text=title, size=3 }))
		insert(frame, guiState.separator!({ thick=true }))
	}
	if text {
		insert(frame, guiState.text!({ text=text }))
		insert(frame, guiState.separator!({ thick=false }))
	}
	if extraContent ~= NULL {
		insert(frame, extraContent)
		insert(frame, guiState.separator!({ thick=false }))
	}
	insert(frame, guiState.buttons!({ name=nameButtons, height=BIG_BUTTON_HEIGHT, buttons={ unpack(buttonList) } }))

	local cleanUp = [name,nameButtons] () {
		guiState.onSubmit[name]        = NULL
		guiState.onAction[nameButtons] = NULL
		guiState.onInactive[name]      = NULL
	}

	if submitIndex {
		guiState.onSubmit[name] = [cb,cleanUp,submitIndex] (frame:gui.Frame) {
			cleanUp()
			popPanel()
			cb(submitIndex)
		}
	}
	guiState.onAction[nameButtons] = [cb,cleanUp] (buttons:gui.Buttons, choice:int, source:gui.ActionSource) {
		cleanUp()
		popPanel()
		cb(choice)
	}
	guiState.onInactive[name] = [cb,cleanUp] (frame:gui.Frame) {
		cleanUp()
		cb(0)
	}

	pushPanel(name)
}

export popPanel :: (nameForAssert="") -> (success:bool) {
	local ok, name = remove(panelStack)
	if nameForAssert  assert(name == nameForAssert)
	if not ok  return false

	local frame = guiState.getElement!(name, gui.Frame)
	guiState.setActive!(frame, false)

	if frame.temp  guiState.delete!(frame)
	return true
}



export FileDialogType :: enum { OPEN, SAVE, CHOOSE }

local fileDialog_type                : FileDialogType = NULL
local fileDialog_dir                 : string         = NULL
local fileDialog_filename            : string         = NULL
local fileDialog_filenamePattern     : string         = NULL
local fileDialog_filenameHidePattern : string         = NULL
local fileDialog_chooseFolder        : bool           = NULL
local fileDialog_relativeTo          : string         = NULL

export fileDialog_lastDirectory = ""

local fileDialog_onHighlight: (pathObj:Path, pathAbsoluteObj:Path) = NULL
local fileDialog_onChoose:    (pathObj:Path, pathAbsoluteObj:Path) = NULL
local fileDialog_onClose:     ()                                   = NULL

export showFileDialog :: (type:FileDialogType,
	title:string, dir,filename:string,
	onHighlight: type_of(fileDialog_onHighlight) = NULL,
	onChoose:    type_of(fileDialog_onChoose)    = NULL,
	onClose:     type_of(fileDialog_onClose)     = NULL,
	filenamePattern="", filenameHidePattern="", floating=false, chooseFolder=false, relativeTo=""
) {
	fileDialog_type                = type
	fileDialog_dir                 = dir
	fileDialog_filename            = filename
	fileDialog_filenamePattern     = filenamePattern
	fileDialog_filenameHidePattern = filenameHidePattern
	fileDialog_chooseFolder        = chooseFolder
	fileDialog_relativeTo          = relativeTo
	fileDialog_onHighlight         = onHighlight
	fileDialog_onChoose            = onChoose
	fileDialog_onClose             = onClose

	fileDialog_lastDirectory = dir ?: fileDialog_lastDirectory

	guiState.getElement!("fileDialog_title", gui.Text).text = title

	local frame = guiState.getElement!("fileDialog", gui.Frame)
	if floating {
		frame.modal  = true
		frame.layout = .FLOATING
	} else {
		frame.modal  = false
		frame.layout = .DOCKED
	}

	pushPanel("fileDialog")
}



export setupGuiCallbacks :: () {
	--==============================================================
	--= Main/project
	--==============================================================

	-- Tabs.
	guiState.onRefresh.projects = (tabs:gui.Tabs) {
		tabs.buttons = {}

		for app.projects {
			local label = (it.edited ? format("%s •", it.displayedName) : it.displayedName)
			insert(tabs.buttons, cast(gui.Button){ label=label, tooltip=it.path, draggable=true })
		}
		insert(tabs.buttons, cast(gui.Button){ image="iconAdd", tooltip="New project  ("..ctrlText.."+N)" })

		tabs.index = app.currentProjectIndex
	}
	guiState.onAction.projects = (tabs:gui.Tabs, buttonIndex:int, source:gui.ActionSource) {
		if buttonIndex < #tabs.buttons {
			setCurrentProject(buttonIndex)
			return
		}

		local project = addNewProject()

		insert(tabs.buttons, #tabs.buttons, cast(gui.Button){ label=project.displayedName, draggable=true })
		guiState.layoutNeedsUpdate = true

		setCurrentProject(#app.projects)
	}
	guiState.onOption.projects = (tabs:gui.Tabs, projectIndex:int) {
		if projectIndex == #tabs.buttons  return

		local project      = app.projects[projectIndex]
		local ok, filename = Path(project.path).getFilename!()
		if not ok  filename = ""

		guiState.showContextMenuWithInput!(filename, inputTooltip="Filename (Change to rename)", {"Close\t"..ctrlText.."+W","Duplicate"},
			cb = [projectIndex] (choice:int) {
				if choice == {
					case 1:
						confirmCloseProject(projectIndex)

					case 2:
						local project = app.projects[projectIndex].clone!()
						insert(app.projects, projectIndex+1, project)

						guiState.refreshRecursively!("projects")
						setCurrentProject(projectIndex+1, force=true)
				}
			},
			cbInput = [projectIndex] (filenameNew:string) {
				if not filenameNew  return

				local project = app.projects[projectIndex]
				if not project.fileIsSaved  return

				if not findPattern(filenameNew, "%.hotparticles$") {
					filenameNew = filenameNew..".hotparticles"
				}

				-- @UX: Confirm rename? (May actually be annoying.)

				local pathObj = Path(project.path)

				local _, dir, filenameOld = pathObj.getDirectoryAndFilename!()
				if not connectToRemoteDirectory(dir)  return
				defer disconnectFromRemoteDirectory()

				if getFileInfo(filenameNew) {
					setErrorText("Rename: File '"..filenameNew.."' already exists") -- @UX: Ask if the user wants to overwrite the file.
					return
				}

				local contents, err = LF.read(filenameOld)
				if contents == nil {
					setErrorText("Rename: Failed reading '"..filenameOld.."': "..cast(string)err)
					return
				}

				local ok, ^err = LF.write(filenameNew, cast(string)contents)
				if not ok {
					setErrorText("Rename: Failed writing '"..filenameNew.."': "..cast(string)err)
					return
				}

				setMessageText("Renamed '"..filenameOld.."' to '"..filenameNew.."'")

				ok = LF.remove(filenameOld)
				if not ok {
					setErrorText("Rename: Failed deleting old file '"..filenameNew.."'")
					-- Don't return! Just leave the old file and let the user take care of it.
				}

				pathObj.setFilename!(filenameNew)
				project.path          = pathObj.toString!()
				project.displayedName = filenameNew

				guiState.refreshRecursively!("projects")
				updateWindowTitle()
			}
		)
	}
	guiState.onClose.projects = (tabs:gui.Tabs, buttonIndex:int) {
		if buttonIndex < #tabs.buttons  confirmCloseProject(buttonIndex)
	}
	guiState.onDrag.projects = (tabs:gui.Tabs, buttonIndex:int, mx,my:int) {
		local targetIndex = math.clamp(math.floor(1 + (mx - tabs.layoutX) / tabs.buttonWidth), 1, #app.projects)
		if targetIndex == buttonIndex  return

		local isCurrent = (buttonIndex == app.currentProjectIndex)

		local _, project = remove(app.projects, buttonIndex)
		local _, button  = remove(tabs.buttons, buttonIndex)
		insert(app.projects, targetIndex, project)
		insert(tabs.buttons, targetIndex, button)

		if isCurrent
			app.currentProjectIndex = targetIndex
		elseif buttonIndex > app.currentProjectIndex and targetIndex <= app.currentProjectIndex
			app.currentProjectIndex += 1
		elseif buttonIndex < app.currentProjectIndex and targetIndex >= app.currentProjectIndex
			app.currentProjectIndex -= 1

		tabs.index = app.currentProjectIndex

		guiState.activeSubid  = targetIndex
		guiState.hoveredSubid = targetIndex
	}

	-- Menu.
	guiState.onRefresh.menuAndSettingsButtons = (buttons:gui.Buttons) {
		local _, button = itemWith(buttons.buttons, "name", "toggleProjectSettings")
		button.image    = app.showProjectSettings ? "iconUp" : "iconDown"
		guiState.setActive!("projectSettings", app.showProjectSettings)
	}
	guiState.onAction.menu = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		showMainMenu()
	}
	guiState.onAction.toggleProjectSettings = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		app.showProjectSettings = not app.showProjectSettings
		local _, button         = itemWith(buttons.buttons, "name", "toggleProjectSettings")
		button.image            = app.showProjectSettings ? "iconUp" : "iconDown"
		guiState.setActive!("projectSettings", app.showProjectSettings)
	}

	-- Undo/redo.
	guiState.onAction.undo = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		undo()
	}
	guiState.onAction.redo = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		redo()
	}
	guiState.onRefresh.undoRedoText = (textEl:gui.Text) {
		local project = app.projects[app.currentProjectIndex]

		if not project.changes {
			textEl.text = "0/0"
			return
		}

		local change        = project.changes[project.changeIndex-1] -- Note: changeIndex points at the next entry.
		local bundleCurrent = change ~= NULL ? change.bundle : -1

		local bundleCount = 0
		local bundleIndex = 0
		local lastBundle  = -1

		local labels: []string
		local labelsAdded: struct { !key:string, !value:bool }

		for project.changes {
			if it.bundle ~= lastBundle {
				bundleCount += 1
				lastBundle   = it.bundle
			}

			if it.bundle == bundleCurrent {
				bundleIndex = bundleCount

				if not labelsAdded[it.label] {
					labelsAdded[it.label] = true
					insert(labels, it.label)
				}
			}
		}

		textEl.text = format("%d/%d  %s", bundleIndex, bundleCount, concatinate(labels, ", "))
	}

	-- Project settings.
	static lastSource: gui.ActionSource = NULL

	local addEventHandlersForDirection :: (name:string, changeLabel:string,
		onUpdateValue: (project:Project, system:System, angle:float),
		finalize:      (project:Project, system:System) = NULL,
		forSystem = false
	) {
		guiState.onBegin[name] = (direction:gui.Direction, _:int) {
			lastSource         = .UNKNOWN
			direction.dataTemp = direction.angle
		}
		guiState.onAction[name] = [*] (direction:gui.Direction, _:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			onUpdateValue(project, system, direction.angle)
			lastSource = source
		}
		guiState.onEnd[name] = [*] (direction:gui.Direction, _:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(float) direction.dataTemp
			local valueNew        = direction.angle
			if valueNew == valueOld  return

			local sourceIsKeyboard = (lastSource == .KEYBOARD)
			local prevChange       = getFirstChangeInPreviousBundle(project)

			if sourceIsKeyboard and prevChange ~= NULL and prevChange.name == name and prevChange.data == "nudge" {
				undo(silent=true) -- Hopefully this updates our widget!
				valueOld = direction.angle
			}

			recordChange(name, changeLabel, (sourceIsKeyboard ? "nudge" : NULL),
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueNew)  },
				[system, valueOld, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueOld)  },
				[system, name, finalize, forSystem] (project:Project) {
					if not (forSystem and not isSystemCurrent(system)) {
						if guiState.isElementVisible!(name)  guiState.refreshRecursively!(name)
					}
					if finalize ~= NULL  finalize(project, system)
				}
			)
		}
	}

	local addEventHandlersForSlider :: (name:string, changeLabel:string,
		onUpdateValue: (project:Project, system:System, value:float),
		finalize:      (project:Project, system:System) = NULL,
		onBegin:       (project:Project, system:System) = NULL,
		onEnd:         (project:Project, system:System) = NULL,
		forSystem = false
	) {
		guiState.onBegin[name] = [*] (slider:gui.Slider, _:int) {
			lastSource      = .UNKNOWN
			slider.dataTemp = slider.value

			if onBegin ~= NULL {
				local project, system = getCurrentProjectAndSystem()
				onBegin(project, system)
			}
		}
		guiState.onAction[name] = [*] (slider:gui.Slider, _:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			onUpdateValue(project, system, slider.value)
			lastSource = source
		}
		guiState.onEnd[name] = [*] (slider:gui.Slider, _:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(float) slider.dataTemp
			local valueNew        = slider.value

			if valueNew ~= valueOld {
				local sourceIsKeyboard = (lastSource == .KEYBOARD)
				local prevChange       = getFirstChangeInPreviousBundle(project)

				if sourceIsKeyboard and prevChange ~= NULL and prevChange.name == name and prevChange.data == "nudge" {
					undo(silent=true) -- Hopefully this updates our widget!
					valueOld = slider.value
				}

				recordChange(name, changeLabel, (sourceIsKeyboard ? "nudge" : NULL),
					[system, valueNew, onUpdateValue  ] (project:Project) {  onUpdateValue(project, system, valueNew)  },
					[system, valueOld, onUpdateValue  ] (project:Project) {  onUpdateValue(project, system, valueOld)  },
					[system, name, finalize, forSystem] (project:Project) {
						if not (forSystem and not isSystemCurrent(system)) {
							if guiState.isElementVisible!(name)  guiState.refreshRecursively!(name)
						}
						if finalize ~= NULL  finalize(project, system)
					}
				)
			}

			if onEnd ~= NULL  onEnd(project, system)
		}
	}

	local addEventHandlersForColor :: (name:string, changeLabel:string,
		onUpdateValue: (project:Project, system:System, component:int, value:float),
		finalize:      (project:Project, system:System) = NULL,
		onBegin:       (project:Project, system:System) = NULL,
		onEnd:         (project:Project, system:System) = NULL,
		forSystem = false
	) {
		guiState.onBegin[name] = [*] (colorEl:gui.Color, component:int) {
			lastSource       = .UNKNOWN
			colorEl.dataTemp = colorEl.color[component]

			if onBegin ~= NULL {
				local project, system = getCurrentProjectAndSystem()
				onBegin(project, system)
			}
		}
		guiState.onAction[name] = [*] (colorEl:gui.Color, component:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			onUpdateValue(project, system, component, colorEl.color[component])
			lastSource = source
		}
		guiState.onEnd[name] = [*] (colorEl:gui.Color, component:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(float) colorEl.dataTemp
			local valueNew        = colorEl.color[component]

			if valueNew ~= valueOld {
				local sourceIsKeyboard = (lastSource == .KEYBOARD)
				local prevChange       = getFirstChangeInPreviousBundle(project)

				local NUDGE_CHANGE_DATAS :: {"nudge1","nudge2","nudge3","nudge4"}
				local changeData = NUDGE_CHANGE_DATAS[component]

				if sourceIsKeyboard and prevChange ~= NULL and prevChange.name == name and prevChange.data == changeData {
					undo(silent=true) -- Hopefully this updates our widget!
					valueOld = colorEl.color[component]
				}

				recordChange(name, changeLabel, (sourceIsKeyboard ? changeData : NULL),
					[system, valueNew, component, onUpdateValue] (project:Project) {  onUpdateValue(project, system, component, valueNew)  },
					[system, valueOld, component, onUpdateValue] (project:Project) {  onUpdateValue(project, system, component, valueOld)  },
					[system, name, finalize, forSystem         ] (project:Project) {
						if not (forSystem and not isSystemCurrent(system)) {
							if guiState.isElementVisible!(name)  guiState.refreshRecursively!(name)
						}
						if finalize ~= NULL  finalize(project, system)
					}
				)
			}

			if onEnd ~= NULL  onEnd(project, system)
		}
	}

	local addEventHandlersForRadio :: (name:string, $ValueType:Type, changeLabel:string,
		onUpdateValue: (project:Project, system:System, value:ValueType)
	) {
		guiState.onBegin[name] = (radio:gui.Radio, buttonIndex:int) {
			radio.dataTemp = radio.buttons[radio.index].value
		}
		guiState.onAction[name] = [*] (radio:gui.Radio, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(ValueType) radio.dataTemp
			local valueNew        = cast(ValueType) radio.buttons[buttonIndex].value
			if valueNew == valueOld  return

			recordChange(name, changeLabel, nil,
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueNew)  },
				[system, valueOld, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueOld)  },
				[name                           ] (project:Project) {  if guiState.isElementVisible!(name)  guiState.refreshRecursively!(name)  }
			)
		}
	}

	local addEventHandlersForCheckbox :: (name:string, changeLabel:string,
		onUpdateValue: (project:Project, system:System, value:bool)
	) {
		guiState.onAction[name] = [*] (checkbox:gui.Checkbox, _:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local valueNew        = checkbox.checked

			recordChange(name, changeLabel, nil,
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system,     valueNew)  },
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system, not valueNew)  },
				[name                           ] (project:Project) {  if guiState.isElementVisible!(name)  guiState.refreshRecursively!(name)  }
			)
		}
	}

	local addToggleEventHandler :: (name:string, changeLabelPrefix:string,
		onToggle: (project:Project, system:System, enabled:bool),
		finalize: (project:Project, system:System) = NULL,
		forSystem = false
	) {
		guiState.onToggle[name] = [*] (widget:gui.Widget, _:int) {
			local project, system = getCurrentProjectAndSystem()
			local enabled         = widget.enabled
			local changeLabel     = changeLabelPrefix .. (enabled ? " enabled" : " disabled")

			recordChange(name, changeLabel, nil,
				[system, onToggle, enabled        ] (project:Project) {  onToggle(project, system,     enabled)  },
				[system, onToggle, enabled        ] (project:Project) {  onToggle(project, system, not enabled)  },
				[system, name, finalize, forSystem] (project:Project) {
					if not (forSystem and not isSystemCurrent(system)) {
						if guiState.isElementVisible!(name)  guiState.refreshRecursively!(name)
					}
					if finalize ~= NULL  finalize(project, system)
				}
			)
		}
	}

	-- Pixelate flags.
	guiState.onRefresh.pixelateWorld = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.pixelateWorld
	}
	addEventHandlersForCheckbox("pixelateWorld", "Pixelate world",
		(project:Project, __:System, value:bool) {  project.pixelateWorld = value ; limitZoomLevel(project) ; scheduleRecreateCanvases = true  }
	)
	guiState.onRefresh.pixelateTextures = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.pixelateTextures
	}
	addEventHandlersForCheckbox("pixelateTextures", "Pixelate textures",
		(project:Project, __:System, value:bool) {
			project.pixelateTextures = value
			updateImageFilters()
		}
	)

	-- Background.
	guiState.onRefresh.bgColor = (colorEl:gui.Color) {
		local project    = app.projects[app.currentProjectIndex]
		colorEl.color[1] = project.bgColor[1]
		colorEl.color[2] = project.bgColor[2]
		colorEl.color[3] = project.bgColor[3]
	}
	addEventHandlersForColor("bgColor", "Background color",
		(project:Project, __:System, component:int, value:float) {  project.bgColor[component] = value  }
	)

	guiState.onRefresh.bgChecker = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.bgChecker
	}
	addEventHandlersForSlider("bgChecker", "Background pattern",
		(project:Project, __:System, value:float) {  project.bgChecker = value  }
	)

	guiState.onRefresh.bgSize = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.bgSize
	}
	addEventHandlersForSlider("bgSize", "Background size",
		(project:Project, __:System, value:float) {  project.bgSize = math.round(value)  }
	)

	guiState.onRefresh.bgPath = (input:gui.InputText) {
		local project = app.projects[app.currentProjectIndex]
		input.value   = project.bgPath
	}
	guiState.onAction.bgPath = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local project = app.projects[app.currentProjectIndex]
		setBackgroundPath(project, Path(trim(input.value)).toString!())
	}
	guiState.onOption.bgPath = (input:gui.InputText, _:int) {
		showRecentFilesContextMenu("Recent textures", app.recentTextures, (path:string) {
			local project = app.projects[app.currentProjectIndex]
			setBackgroundPath(project, path)
		})
	}

	guiState.onAction.bgChoose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project = app.projects[app.currentProjectIndex]

		local ok, path = getFullPathToBackground(project)
		local dir: string
		if ok      ok, dir  = Path(path).getDirectory!()
		if not ok  ok, dir  = Path(project.path).getDirectory!()
		if not ok  dir      = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"
		local ^ok, filename = Path(project.bgPath).getFilename!()
		if not ok  filename = ""

		showFileDialog(.OPEN, "Choose texture", dir, filename, filenameHidePattern="%.hotparticles$",
			onHighlight = (pathObj:Path, pathAbsoluteObj:Path) {
				textureBrowserPreviewImage = NULL

				local _, dir, filename = pathAbsoluteObj.getDirectoryAndFilename!()
				if not connectToRemoteDirectory(dir)  return
				defer disconnectFromRemoteDirectory()

				local ^textureBrowserPreviewImage, err = pcall_newImage(filename)
				if textureBrowserPreviewImage == NULL {
					log(err)
					return
				}

				local project = app.projects[app.currentProjectIndex]
				local filter  = project.pixelateTextures ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR
				textureBrowserPreviewImage.setFilter!(filter, filter)
			},
			onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
				local ok, dir, filename = pathAbsoluteObj.getDirectoryAndFilename!()
				if not ok  return -- @UX: Show error message.

				if not connectToRemoteDirectory(dir) {
					setErrorText("Could not access folder '%s'", dir)
					return
				}
				defer disconnectFromRemoteDirectory()

				addRecent(app.recentFolders, dir, app.maxRecentFiles)

				local image = pcall_newImage(filename)
				if image == NULL {
					setErrorText("'%s' is not a valid texture file", filename)
					return
				}

				local project = app.projects[app.currentProjectIndex]
				setBackgroundPath(project, pathObj.toString!())
				popPanel()
			},
			onClose = () {
				textureBrowserPreviewImage = NULL
			}
		)
	}

	guiState.onAction.bgRelative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project  = app.projects[app.currentProjectIndex]
		local ok, path = toggleRelativePath(project, project.bgPath, [*] () -> (success:bool, path:string) {
			local ok, path = getFullPathToBackground(project)
			return ok, path
		})
		if ok  setBackgroundPath(project, path)
	}

	guiState.onAction.bgReload = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project = app.projects[app.currentProjectIndex]
		if project.bgPath  updateBackgroundTexture(project)
	}

	guiState.onRefresh.bgScale = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.bgScale
	}
	addEventHandlersForSlider("bgScale", "Background scale",
		(project:Project, __:System, value:float) {  project.bgScale = value  }
	)

	guiState.onRefresh.bgRepeatX = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.bgRepeatX
	}
	guiState.onRefresh.bgRepeatY = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.bgRepeatY
	}
	addEventHandlersForCheckbox("bgRepeatX", "Background repeat",
		(project:Project, __:System, value:bool) {  project.bgRepeatX = value  }
	)
	addEventHandlersForCheckbox("bgRepeatY", "Background repeat",
		(project:Project, __:System, value:bool) {  project.bgRepeatY = value  }
	)

	-- Emitter.
	do {
		guiState.onRefresh.emitterMovement = (radio:gui.Radio) {
			local project  = app.projects[app.currentProjectIndex]
			local found, i = indexWith(radio.buttons, "value", project.movementPreset)
			assert(found)
			radio.index = i
		}
		addEventHandlersForRadio("emitterMovement", Movement, "Emitter movement",
			(project:Project, __:System, value:Movement) {  project.movementPreset = value  }
		)

		guiState.onRefresh.emitterMovementSx = (slider:gui.Slider) {
			local project  = app.projects[app.currentProjectIndex]
			slider.enabled = project.movementScaleXEnabled
			slider.value   = project.movementScaleX
		}
		guiState.onRefresh.emitterMovementSy = (slider:gui.Slider) {
			local project  = app.projects[app.currentProjectIndex]
			slider.enabled = project.movementScaleYEnabled
			slider.value   = project.movementScaleY
		}
		addEventHandlersForSlider("emitterMovementSx", "Emitter movement scale X",
			(project:Project, __:System, value:float) {  project.movementScaleX = value  }
		)
		addEventHandlersForSlider("emitterMovementSy", "Emitter movement scale Y",
			(project:Project, __:System, value:float) {  project.movementScaleY = value  }
		)
		addToggleEventHandler("emitterMovementSx", "Emitter movement scale X",
			onToggle = (project:Project, __:System, enabled:bool) {  project.movementScaleXEnabled = enabled  }
		)
		addToggleEventHandler("emitterMovementSy", "Emitter movement scale Y",
			onToggle = (project:Project, __:System, enabled:bool) {  project.movementScaleYEnabled = enabled  }
		)

		guiState.onRefresh.emitterMovementSpeed = (slider:gui.Slider) {
			local project = app.projects[app.currentProjectIndex]
			slider.value  = project.movementSpeed
		}
		addEventHandlersForSlider("emitterMovementSpeed", "Emitter movement speed",
			(project:Project, __:System, value:float) {  project.movementSpeed = value  }
		)
	}

	-- Custom data.
	guiState.onRefresh.customDataProject = (input:gui.InputText) {
		local project = app.projects[app.currentProjectIndex]
		input.value   = project.customData
	}
	guiState.onAction.customDataProject = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local project = app.projects[app.currentProjectIndex]
		local dataOld = project.customData
		local dataNew = input.value

		recordChange("", "Project custom data", nil,
			[dataNew] (project:Project) {  project.customData = dataNew  },
			[dataOld] (project:Project) {  project.customData = dataOld  },
			--[[   ]] (project:Project) {  guiState.refreshRecursively!("customDataProject")  }
		)
	}

	-- Region.
	do {
		guiState.onRefresh.regionWidth = (slider:gui.Slider) {
			local project  = app.projects[app.currentProjectIndex]
			slider.enabled = project.regionEnabled
			slider.value   = project.regionWidth
		}
		guiState.onRefresh.regionHeight = (slider:gui.Slider) {
			local project  = app.projects[app.currentProjectIndex]
			slider.enabled = project.regionEnabled
			slider.value   = project.regionHeight
		}
		addEventHandlersForSlider("regionWidth", "Region",
			(project:Project, __:System, value:float) {  project.regionWidth = math.round(value)  }
		)
		addEventHandlersForSlider("regionHeight", "Region",
			(project:Project, __:System, value:float) {  project.regionHeight = math.round(value)  }
		)
		addToggleEventHandler("regionWidth", "Region",
			onToggle = (project:Project, __:System, enabled:bool) {
				project.regionEnabled = enabled
				guiState.refreshRecursively!("regionHeight")
			}
		)
		addToggleEventHandler("regionHeight", "Region",
			onToggle = (project:Project, __:System, enabled:bool) {
				project.regionEnabled = enabled
				guiState.refreshRecursively!("regionWidth")
			}
		)
	}

	-- Scale global.
	do {
		guiState.onRefresh.scaleGlobalTime = (slider:gui.Slider) {
			local project  = app.projects[app.currentProjectIndex]
			slider.enabled = project.scaleGlobalTimeEnabled
			slider.value   = project.scaleGlobalTime
		}
		guiState.onRefresh.scaleGlobalSpace = (slider:gui.Slider) {
			local project  = app.projects[app.currentProjectIndex]
			slider.enabled = project.scaleGlobalSpaceEnabled
			slider.value   = project.scaleGlobalSpace
		}
		guiState.onRefresh.scaleGlobalSize = (slider:gui.Slider) {
			local project  = app.projects[app.currentProjectIndex]
			slider.enabled = project.scaleGlobalSizeEnabled
			slider.value   = project.scaleGlobalSize
		}
		addEventHandlersForSlider("scaleGlobalTime", "Global time scale",
			(project:Project, __:System, value:float) {
				project.scaleGlobalTime = value
				for project.systems  updateParticleParams(project, it)
			}
		)
		addEventHandlersForSlider("scaleGlobalSpace", "Global space scale",
			(project:Project, __:System, value:float) {
				project.scaleGlobalSpace = value
				for project.systems  updateParticleParams(project, it)
			}
		)
		addEventHandlersForSlider("scaleGlobalSize", "Global size scale",
			(project:Project, __:System, value:float) {
				project.scaleGlobalSize = value
				for project.systems  updateParticleParams(project, it)
			}
		)
		addToggleEventHandler("scaleGlobalTime", "Global time scale",
			onToggle = (project:Project, __:System, enabled:bool) {
				project.scaleGlobalTimeEnabled = enabled
				for project.systems  updateParticleParams(project, it)
			}
		)
		addToggleEventHandler("scaleGlobalSpace", "Global space scale",
			onToggle = (project:Project, __:System, enabled:bool) {
				project.scaleGlobalSpaceEnabled = enabled
				for project.systems  updateParticleParams(project, it)
			}
		)
		addToggleEventHandler("scaleGlobalSize", "Global size scale",
			onToggle = (project:Project, __:System, enabled:bool) {
				project.scaleGlobalSizeEnabled = enabled
				for project.systems  updateParticleParams(project, it)
			}
		)
	}

	-- Systems.
	guiState.onRefresh.systems = (tabs:gui.Tabs) {
		local project = app.projects[app.currentProjectIndex]
		tabs.buttons  = {}

		for project.systems {
			insert(tabs.buttons, cast(gui.Button){ system=it, draggable=true, tooltip=format("Particle system #%d (%s+click to toggle)", itIndex, ctrlText) })
		}
		insert(tabs.buttons, cast(gui.Button){ image="iconAdd", tooltip="New particle system" })

		tabs.index = project.systemIndex
	}
	guiState.onBeforeAction.systems = (tabs:gui.Tabs, buttonIndex:int) -> (ignore:bool) {
		if buttonIndex == #tabs.buttons  return false
		if not LK.isDown(lctrl,rctrl)    return false

		local project                        = app.projects[app.currentProjectIndex]
		project.systems[buttonIndex].visible = not project.systems[buttonIndex].visible

		return true
	}
	guiState.onAction.systems = (tabs:gui.Tabs, buttonIndex:int, source:gui.ActionSource) {
		local project = app.projects[app.currentProjectIndex]

		if buttonIndex < #tabs.buttons {
			setCurrentSystem(buttonIndex)
			return
		}

		local system = newSystem(project)

		recordChange("", "Add particle system", nil,
			[system] (project:Project) {  insert(project.systems, system) ; setCurrentSystem(#project.systems)  },
			--[[  ]] (project:Project) {  remove(project.systems)         ; setCurrentSystem(math.min(project.systemIndex, #project.systems))  },
			--[[  ]] (project:Project) {  guiState.refreshRecursively!("systems")  }
		)
	}
	guiState.onOption.systems = (tabs:gui.Tabs, systemIndex:int) {
		if systemIndex == #tabs.buttons  return

		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[systemIndex]

		local items = {
			--[[1]] "Delete\t"..ctrlText.."+Delete",
			--[[2]] "Duplicate\t"..ctrlText.."+D",
			--[[3]] "Copy",
			--[[4]] "Paste new",
			"-",
			--[[5]] (system.visible ? "Hide\tH" : "Show\tH"),
		}

		static clipboardSystem: System = NULL
		static hasClipboardSystem      = false

		guiState.showContextMenuWithInput!(system.title, inputTooltip="Particle system title", items,
			cb = [system, systemIndex] (choice:int) {
				if choice == {
					case 1:
						confirmDeleteSystem(systemIndex)

					case 2:
						duplicateSystem(systemIndex)

					case 3:
						hasClipboardSystem = true
						clipboardSystem    = system.clone!()

					case 4:
						if not hasClipboardSystem  return

						local project      = app.projects[app.currentProjectIndex]
						local systemPasted = clipboardSystem.clone!()

						-- Should we do this in the recordChange() callback since we might have saved
						-- an unsaved project inbetween doing, undoing and redoing? Also, the texture
						-- file may be modified. @UX
						updateParticleTexture(project, systemPasted)

						recordChange("", "Paste particle system", nil,
							[system, systemIndex, systemPasted] (project:Project) {
								insert(project.systems, systemIndex, systemPasted)
								setCurrentSystem(systemIndex, force=true)
							},
							[system, systemIndex] (project:Project) {
								remove(project.systems, systemIndex)
								setCurrentSystem(math.clamp(project.systemIndex, 1, #project.systems), force=true)
							}
						)

					case 5:
						system.visible = not system.visible
				}
			},
			cbInput = [system] (valueNew:string) {
				local valueOld = system.title
				if valueNew == valueOld  return

				recordChange("", "Particle system title", nil,
					[system, valueNew] (project:Project) {  system.title = valueNew  },
					[system, valueOld] (project:Project) {  system.title = valueOld  }
				)
			}
		)
	}
	guiState.onClose.systems = (tabs:gui.Tabs, buttonIndex:int) {
		if buttonIndex < #tabs.buttons  confirmDeleteSystem(buttonIndex)
	}
	guiState.onDragBegin.systems = (tabs:gui.Tabs, buttonIndex:int) {
		local project   = app.projects[app.currentProjectIndex]
		tabs.dataTemp   = project.systems
		project.systems = {unpack(project.systems)}
	}
	guiState.onDrag.systems = (tabs:gui.Tabs, buttonIndex:int, mx,my:int) {
		local project     = app.projects[app.currentProjectIndex]
		local targetIndex = math.clamp(math.floor(1 + (mx - tabs.layoutX) / tabs.buttonWidth), 1, #project.systems)
		if targetIndex == buttonIndex  return

		local isCurrent = (buttonIndex == project.systemIndex)

		local _, system = remove(project.systems, buttonIndex)
		local _, button = remove(tabs.buttons, buttonIndex)
		insert(project.systems, targetIndex, system)
		insert(tabs.buttons,    targetIndex, button)

		if isCurrent
			project.systemIndex = targetIndex
		elseif buttonIndex > project.systemIndex and targetIndex <= project.systemIndex
			project.systemIndex += 1
		elseif buttonIndex < project.systemIndex and targetIndex >= project.systemIndex
			project.systemIndex -= 1

		tabs.index = project.systemIndex

		guiState.activeSubid  = targetIndex
		guiState.hoveredSubid = targetIndex
	}
	guiState.onDragEnd.systems = (tabs:gui.Tabs, buttonIndex:int) {
		local project    = app.projects[app.currentProjectIndex]
		local systemsOld = cast([]System) tabs.dataTemp
		local systemsNew = project.systems
		local newOrder   = false

		for systemsNew {
			if it ~= systemsOld[itIndex] {
				newOrder = true
				break
			}
		}
		if not newOrder  return

		recordChange("", "Reorder particle systems", nil,
			[systemsNew, systemsOld] (project:Project) {  _, project.systemIndex = indexOf(systemsNew, project.systems[project.systemIndex]) ; project.systems = systemsNew  },
			[systemsNew, systemsOld] (project:Project) {  _, project.systemIndex = indexOf(systemsOld, project.systems[project.systemIndex]) ; project.systems = systemsOld  },
			--[[                  ]] (project:Project) {  guiState.refreshRecursively!("systems") ; setCurrentSystem(project.systemIndex, force=true)  }
		)
	}

	-- Texture.
	guiState.onRefresh.textureName = (radio:gui.Radio) {
		local project, system = getCurrentProjectAndSystem()
		radio.buttons         = {}

		for particleImageNames {
			insert(radio.buttons, cast(gui.Button){ value=it, tooltip=it, image=it })
		}

		local found, i = indexOf(particleImageNames, system.textureName)
		assert(found)
		radio.index = i
	}
	addEventHandlersForRadio("textureName", string, "Texture preset",
		(project:Project, system:System, value:string) {  system.textureName = value ; updateParticleTexture(project, system)  }
	)

	guiState.onRefresh.texturePath = (input:gui.InputText) {
		local project, system = getCurrentProjectAndSystem()
		input.value           = system.texturePath
	}
	guiState.onAction.texturePath = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local project, system = getCurrentProjectAndSystem()
		setTexturePath(project, system, Path(trim(input.value)).toString!())
	}
	guiState.onOption.texturePath = (input:gui.InputText, _:int) {
		showRecentFilesContextMenu("Recent textures", app.recentTextures, (path:string) {
			local project, system = getCurrentProjectAndSystem()
			setTexturePath(project, system, path)
		})
	}

	guiState.onAction.textureChoose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project, system = getCurrentProjectAndSystem()

		local ok, path = getFullPathToTexture(project, system)
		if not system.texturePath  ok = false
		local dir: string
		if ok      ok, dir  = Path(path).getDirectory!()
		if not ok  ok, dir  = Path(project.path).getDirectory!()
		if not ok  dir      = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"
		local ^ok, filename = Path(system.texturePath).getFilename!()
		if not ok  filename = ""

		showFileDialog(.OPEN, "Choose texture", dir, filename, filenameHidePattern="%.hotparticles$",
			onHighlight = (pathObj:Path, pathAbsoluteObj:Path) {
				textureBrowserPreviewImage = NULL

				local _, dir, filename = pathAbsoluteObj.getDirectoryAndFilename!()
				if not connectToRemoteDirectory(dir)  return
				defer disconnectFromRemoteDirectory()

				local ^textureBrowserPreviewImage, err = pcall_newImage(filename)
				if textureBrowserPreviewImage == NULL {
					log(err)
					return
				}

				local project = app.projects[app.currentProjectIndex]
				local filter  = project.pixelateTextures ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR
				textureBrowserPreviewImage.setFilter!(filter, filter)
			},
			onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
				local ok, dir, filename = pathAbsoluteObj.getDirectoryAndFilename!()
				if not ok  return -- @UX: Show error message.

				if not connectToRemoteDirectory(dir) {
					setErrorText("Could not access folder '%s'", dir)
					return
				}
				defer disconnectFromRemoteDirectory()

				addRecent(app.recentFolders, dir, app.maxRecentFiles)

				local image = pcall_newImage(filename)
				if image == NULL {
					setErrorText("'%s' is not a valid texture file", filename)
					return
				}

				local project, system = getCurrentProjectAndSystem()
				setTexturePath(project, system, pathObj.toString!())
				popPanel()
			},
			onClose = () {
				textureBrowserPreviewImage = NULL
			}
		)
	}

	guiState.onAction.textureRelative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project, system = getCurrentProjectAndSystem()
		local ok, path = toggleRelativePath(project, system.texturePath, [*] () -> (success:bool, path:string) {
			local ok, path = getFullPathToTexture(project, system)
			return ok, path
		})
		if ok  setTexturePath(project, system, path)
	}

	guiState.onAction.textureReload = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project, system = getCurrentProjectAndSystem()
		if system.texturePath  updateParticleTexture(project, system)
	}

	guiState.onRefresh.textureOffsetX = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.offsetX
	}
	addEventHandlersForSlider(forSystem=true, "textureOffsetX", "Texture offset",
		(project:Project, system:System, value:float) {  system.offsetX = value ; updateParticleTextureOffset(system)  }
	)

	guiState.onRefresh.textureOffsetY = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.offsetY
	}
	addEventHandlersForSlider(forSystem=true, "textureOffsetY", "Texture offset",
		(project:Project, system:System, value:float) {  system.offsetY = value ; updateParticleTextureOffset(system)  }
	)

	do {
		static clipboardAnimation: []AnimationFrame = NULL
		static clipboardLifetimeMin: float          = NULL
		static clipboardLifetimeMax: float          = NULL
		static hasClipboardAnimation                = false

		guiState.onAction.animationButton = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			pushPanel("animation")
		}
		guiState.onOption.animationButton = (buttons:gui.Buttons, buttonIndex:int) {
			local ITEMS :: {"Clear animation","Copy animation","Paste animation"}

			guiState.showContextMenu!(ITEMS, (choice:int) {
				local project, system = getCurrentProjectAndSystem()

				if choice == {
					case 1:
						if not system.frames  return

						local framesOld = system.frames
						local framesNew: []AnimationFrame

						recordChange("", "Clear animation", nil,
							[system, framesNew] (project:Project) {  system.frames = framesNew ; updateParticleAnimation(system)  },
							[system, framesOld] (project:Project) {  system.frames = framesOld ; updateParticleAnimation(system)  }
						)

					case 2:
						hasClipboardAnimation = true
						clipboardAnimation    = copyFrames(system.frames)
						clipboardLifetimeMin  = system.psParticleLifetimeMin
						clipboardLifetimeMax  = system.psParticleLifetimeMax

					case 3:
						if not hasClipboardAnimation  return

						local framesOld,      framesNew      = system.frames,                copyFrames(clipboardAnimation)
						local lifetimeMinOld, lifetimeMinNew = system.psParticleLifetimeMin, clipboardLifetimeMin
						local lifetimeMaxOld, lifetimeMaxNew = system.psParticleLifetimeMax, clipboardLifetimeMax

						recordChange("", "Paste animation", nil,
							[system, framesNew, lifetimeMinNew, lifetimeMaxNew] (project:Project) {
								system.frames, system.psParticleLifetimeMin, system.psParticleLifetimeMax = framesNew, lifetimeMinNew, lifetimeMaxNew
							},
							[system, framesOld, lifetimeMinOld, lifetimeMaxOld] (project:Project) {
								system.frames, system.psParticleLifetimeMin, system.psParticleLifetimeMax = framesOld, lifetimeMinOld, lifetimeMaxOld
							},
							[system] (project:Project) {
								updateParticleAnimation(system)
								updateParticleParams(project, system)
								guiState.refreshRecursively!("particleLifetimeMin")
								guiState.refreshRecursively!("particleLifetimeMax")
							}
						)
				}
			})
		}
	}

	do {
		guiState.onRefresh.scaleTime = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.scaleTimeEnabled
			slider.value          = system.scaleTime
		}
		guiState.onRefresh.scaleSpace = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.scaleSpaceEnabled
			slider.value          = system.scaleSpace
		}
		guiState.onRefresh.scaleSize = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.scaleSizeEnabled
			slider.value          = system.scaleSize
		}
		addEventHandlersForSlider(forSystem=true, "scaleTime", "Time scale",
			(project:Project, system:System, value:float) {  system.scaleTime = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "scaleSpace", "Space scale",
			(project:Project, system:System, value:float) {  system.scaleSpace = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "scaleSize", "Size scale",
			(project:Project, system:System, value:float) {  system.scaleSize = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "scaleTime", "Time scale",
			onToggle = (project:Project, system:System, enabled:bool) {  system.scaleTimeEnabled = enabled ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "scaleSpace", "Space scale",
			onToggle = (project:Project, system:System, enabled:bool) {  system.scaleSpaceEnabled = enabled ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "scaleSize", "Size scale",
			onToggle = (project:Project, system:System, enabled:bool) {  system.scaleSizeEnabled = enabled ; updateParticleParams(project, system)  }
		)
	}

	guiState.onRefresh.insertMode = (radio:gui.Radio) {
		local project, system = getCurrentProjectAndSystem()
		local found, i        = indexWith(radio.buttons, "value", system.psInsertMode)
		assert(found)
		radio.index = i
	}
	addEventHandlersForRadio("insertMode", LG.ParticleInsertMode, "Spawn layer",
		(project:Project, system:System, value:LG.ParticleInsertMode) {  system.psInsertMode = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.emitterContinuous = (checkbox:gui.Checkbox) {
		local project, system = getCurrentProjectAndSystem()
		checkbox.checked      = system.psEmitterContinuous
	}
	addEventHandlersForCheckbox("emitterContinuous", "Continuous emitter",
		(project:Project, system:System, value:bool) {
			system.psEmitterContinuous = value
			updateParticleParams(project, system)
			if system.psEmitterContinuous  system.particles.start!()
		}
	)

	guiState.onRefresh.emitterLifetime = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psEmitterLifetime
	}
	static lastContinuousChange: Change = NULL
	addEventHandlersForSlider(forSystem=true, "emitterLifetime", "Emitter lifetime",
		onBegin = (project:Project, system:System) {
			if not system.psEmitterContinuous {
				lastContinuousChange = NULL
				return
			}
			lastContinuousChange = recordChange("", "Continuous emitter", nil,
				[system] (project:Project) {  system.psEmitterContinuous = false  },
				[system] (project:Project) {  system.psEmitterContinuous = true   },
				[system] (project:Project) {
					updateParticleParams(project, system)
					if system.psEmitterContinuous  system.particles.start!()
					guiState.refreshRecursively!("emitterContinuous")
				}
			)
		},
		(project:Project, system:System, value:float) {
			system.psEmitterLifetime = value
			updateParticleParams(project, system)
			system.particles.start!()
		},
		onEnd = (project:Project, system:System) {
			if lastContinuousChange ~= NULL {
				lastContinuousChange.bundle = project.changes[#project.changes].bundle
				guiState.refreshRecursively!("undoRedoText")
			}
		}
	)
	guiState.onRefresh.particleLifetimeMin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psParticleLifetimeMin
	}
	addEventHandlersForSlider(forSystem=true, "particleLifetimeMin", "Particle lifetime",
		(project:Project, system:System, value:float) {  system.psParticleLifetimeMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.particleLifetimeMax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psParticleLifetimeMax
	}
	addEventHandlersForSlider(forSystem=true, "particleLifetimeMax", "Particle lifetime",
		(project:Project, system:System, value:float) {  system.psParticleLifetimeMax = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.emissionRate = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psEmissionRate
	}
	addEventHandlersForSlider(forSystem=true, "emissionRate", "Spawn rate",
		(project:Project, system:System, value:float) {  system.psEmissionRate = value ; updateParticleParams(project, system)  }
	)

	do {
		guiState.onRefresh.kickStartEmit = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.kickStartEmitEnabled
			slider.value          = system.kickStartEmit
		}
		guiState.onRefresh.kickStartSteps = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.kickStartStepsEnabled
			slider.value          = system.kickStartSteps
		}
		addEventHandlersForSlider(forSystem=true, "kickStartEmit", "Emit at start",
			(project:Project, system:System, value:float) {  system.kickStartEmit = math.round(value) ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "kickStartSteps", "Kick-start steps",
			(project:Project, system:System, value:float) {  system.kickStartSteps = math.round(value) ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "kickStartEmit", "Emit at start",
			onToggle = (project:Project, system:System, enabled:bool) {  system.kickStartEmitEnabled = enabled --[[; updateParticleParams(project, system)]]  }
		)
		addToggleEventHandler(forSystem=true, "kickStartSteps", "Kick-start steps",
			onToggle = (project:Project, system:System, enabled:bool) {  system.kickStartStepsEnabled = enabled --[[; updateParticleParams(project, system)]]  }
		)
	}

	-- Area distribution.
	do {
		guiState.onRefresh.areaDistribution = (radio:gui.Radio) {
			local project, system = getCurrentProjectAndSystem()
			local found, i        = indexWith(radio.buttons, "value", system.psEmissionAreaDistribution)
			assert(found)
			radio.index = i
			guiState.setActive!("areaParams", (i > 1))
		}

		addEventHandlersForRadio("areaDistribution", LG.AreaSpreadDistribution, "Distribution",
			(project:Project, system:System, value:LG.AreaSpreadDistribution) {
				system.psEmissionAreaDistribution = value
				updateParticleParams(project, system)
				guiState.setActive!("areaParams", (value == .NONE))
				if value ~= .NONE  guiState.refreshRecursively!("areaParams")
			}
		)

		guiState.onRefresh.areaAngle = (direction:gui.Direction) {
			local project, system = getCurrentProjectAndSystem()
			direction.enabled     = system.psEmissionAreaAngleEnabled
			direction.angle       = system.psEmissionAreaAngle
		}
		addEventHandlersForDirection(forSystem=true, "areaAngle", "Distribution angle",
			(project:Project, system:System, value:float) {  system.psEmissionAreaAngle = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "areaAngle", "Distribution angle",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psEmissionAreaAngleEnabled = enabled ; updateParticleParams(project, system)  }
		)

		guiState.onRefresh.areaDx = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psEmissionAreaDxEnabled
			slider.value          = system.psEmissionAreaDx
		}
		guiState.onRefresh.areaDy = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psEmissionAreaDyEnabled
			slider.value          = system.psEmissionAreaDy
		}
		addEventHandlersForSlider(forSystem=true, "areaDx", "Distribution dx",
			(project:Project, system:System, value:float) {  system.psEmissionAreaDx = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "areaDy", "Distribution dy",
			(project:Project, system:System, value:float) {  system.psEmissionAreaDy = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "areaDx", "Distribution dx",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psEmissionAreaDxEnabled = enabled ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "areaDy", "Distribution dy",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psEmissionAreaDyEnabled = enabled ; updateParticleParams(project, system)  }
		)

		guiState.onRefresh.areaRelative = (checkbox:gui.Checkbox) {
			local project, system = getCurrentProjectAndSystem()
			checkbox.checked      = system.psEmissionAreaRelative
		}
		addEventHandlersForCheckbox("areaRelative", "Relative direction",
			(project:Project, system:System, value:bool) {  system.psEmissionAreaRelative = value ; updateParticleParams(project, system)  }
		)
	}

	do {
		guiState.onRefresh.direction = (direction:gui.Direction) {
			local project, system = getCurrentProjectAndSystem()
			direction.enabled     = system.psDirectionEnabled
			direction.angle       = system.psDirection
		}
		addEventHandlersForDirection(forSystem=true, "direction", "Direction",
			(project:Project, system:System, value:float) {  system.psDirection = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "direction", "Direction",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psDirectionEnabled = enabled ; updateParticleParams(project, system)  }
		)

		guiState.onRefresh.directionSpread = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psSpreadEnabled
			slider.value          = system.psSpread
		}
		addEventHandlersForSlider(forSystem=true, "directionSpread", "Spread",
			(project:Project, system:System, value:float) {  system.psSpread = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "directionSpread", "Spread",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psSpreadEnabled = enabled ; updateParticleParams(project, system)  }
		)
	}

	do {
		guiState.onRefresh.speedMin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psSpeedEnabled
			slider.value          = system.psSpeedMin
		}
		guiState.onRefresh.speedMax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psSpeedEnabled
			slider.value          = system.psSpeedMax
		}
		addEventHandlersForSlider(forSystem=true, "speedMin", "Speed",
			(project:Project, system:System, value:float) {  system.psSpeedMin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "speedMax", "Speed",
			(project:Project, system:System, value:float) {  system.psSpeedMax = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "speedMin", "Speed",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psSpeedEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("speedMax")  }
		)
		addToggleEventHandler(forSystem=true, "speedMax", "Speed",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psSpeedEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("speedMin")  }
		)
	}

	do {
		guiState.onRefresh.accLinearXmin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psLinearAccelerationXEnabled
			slider.value          = system.psLinearAccelerationXmin
		}
		guiState.onRefresh.accLinearXmax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psLinearAccelerationXEnabled
			slider.value          = system.psLinearAccelerationXmax
		}
		guiState.onRefresh.accLinearYmin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psLinearAccelerationYEnabled
			slider.value          = system.psLinearAccelerationYmin
		}
		guiState.onRefresh.accLinearYmax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psLinearAccelerationYEnabled
			slider.value          = system.psLinearAccelerationYmax
		}
		addEventHandlersForSlider(forSystem=true, "accLinearXmin", "Linear acceleration X",
			(project:Project, system:System, value:float) {  system.psLinearAccelerationXmin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "accLinearXmax", "Linear acceleration X",
			(project:Project, system:System, value:float) {  system.psLinearAccelerationXmax = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "accLinearYmin", "Linear acceleration Y",
			(project:Project, system:System, value:float) {  system.psLinearAccelerationYmin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "accLinearYmax", "Linear acceleration Y",
			(project:Project, system:System, value:float) {  system.psLinearAccelerationYmax = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "accLinearXmin", "Linear acceleration X",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psLinearAccelerationXEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accLinearXmax")  }
		)
		addToggleEventHandler(forSystem=true, "accLinearXmax", "Linear acceleration X",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psLinearAccelerationXEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accLinearXmin")  }
		)
		addToggleEventHandler(forSystem=true, "accLinearYmin", "Linear acceleration Y",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psLinearAccelerationYEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accLinearYmax")  }
		)
		addToggleEventHandler(forSystem=true, "accLinearYmax", "Linear acceleration Y",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psLinearAccelerationYEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accLinearYmin")  }
		)
	}

	do {
		guiState.onRefresh.accRadialMin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psRadialAccelerationEnabled
			slider.value          = system.psRadialAccelerationMin
		}
		guiState.onRefresh.accRadialMax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psRadialAccelerationEnabled
			slider.value          = system.psRadialAccelerationMax
		}
		addEventHandlersForSlider(forSystem=true, "accRadialMin", "Radial acceleration",
			(project:Project, system:System, value:float) {  system.psRadialAccelerationMin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "accRadialMax", "Radial acceleration",
			(project:Project, system:System, value:float) {  system.psRadialAccelerationMax = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "accRadialMin", "Radial acceleration",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psRadialAccelerationEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accRadialMax")  }
		)
		addToggleEventHandler(forSystem=true, "accRadialMax", "Radial acceleration",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psRadialAccelerationEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accRadialMin")  }
		)
	}

	do {
		guiState.onRefresh.accTangentMin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psTangentialAccelerationEnabled
			slider.value          = system.psTangentialAccelerationMin
		}
		guiState.onRefresh.accTangentMax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psTangentialAccelerationEnabled
			slider.value          = system.psTangentialAccelerationMax
		}
		addEventHandlersForSlider(forSystem=true, "accTangentMin", "Tangential acceleration",
			(project:Project, system:System, value:float) {  system.psTangentialAccelerationMin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "accTangentMax", "Tangential acceleration",
			(project:Project, system:System, value:float) {  system.psTangentialAccelerationMax = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "accTangentMin", "Tangential acceleration",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psTangentialAccelerationEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accTangentMax")  }
		)
		addToggleEventHandler(forSystem=true, "accTangentMax", "Tangential acceleration",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psTangentialAccelerationEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("accTangentMin")  }
		)
	}

	do {
		guiState.onRefresh.linearDampingMin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psLinearDampingEnabled
			slider.value          = system.psLinearDampingMin
		}
		guiState.onRefresh.linearDampingMax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psLinearDampingEnabled
			slider.value          = system.psLinearDampingMax
		}
		addEventHandlersForSlider(forSystem=true, "linearDampingMin", "Linear damping",
			(project:Project, system:System, value:float) {  system.psLinearDampingMin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "linearDampingMax", "Linear damping",
			(project:Project, system:System, value:float) {  system.psLinearDampingMax = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "linearDampingMin", "Linear damping",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psLinearDampingEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("linearDampingMax")  }
		)
		addToggleEventHandler(forSystem=true, "linearDampingMax", "Linear damping",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psLinearDampingEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("linearDampingMin")  }
		)
	}

	do {
		guiState.onRefresh.rotationMin = (direction:gui.Direction) {
			local project, system = getCurrentProjectAndSystem()
			direction.enabled     = system.psRotationEnabled
			direction.angle       = system.psRotationMin
		}
		guiState.onRefresh.rotationMax = (direction:gui.Direction) {
			local project, system = getCurrentProjectAndSystem()
			direction.enabled     = system.psRotationEnabled
			direction.angle       = system.psRotationMax
		}
		addEventHandlersForDirection(forSystem=true, "rotationMin", "Rotation",
			(project:Project, system:System, value:float) {  system.psRotationMin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForDirection(forSystem=true, "rotationMax", "Rotation",
			(project:Project, system:System, value:float) {  system.psRotationMax = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "rotationMin", "Rotation",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psRotationEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("rotationMax")  }
		)
		addToggleEventHandler(forSystem=true, "rotationMax", "Rotation",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psRotationEnabled = enabled ; updateParticleParams(project, system)  },
			finalize = (project:Project, system:System              ) {  guiState.refreshRecursively!("rotationMin")  }
		)

		guiState.onRefresh.rotationRelative = (checkbox:gui.Checkbox) {
			local project, system = getCurrentProjectAndSystem()
			checkbox.checked      = system.psRelativeRotation
		}
		addEventHandlersForCheckbox("rotationRelative", "Relative rotation",
			(project:Project, system:System, value:bool) {  system.psRelativeRotation = value ; updateParticleParams(project, system)  }
		)
	}

	do {
		guiState.onRefresh.spinMin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psSpinMinEnabled
			slider.value          = system.psSpinMin
		}
		guiState.onRefresh.spinMax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psSpinMaxEnabled
			slider.value          = system.psSpinMax
		}
		addEventHandlersForSlider(forSystem=true, "spinMin", "Spin at start",
			(project:Project, system:System, value:float) {  system.psSpinMin = value ; updateParticleParams(project, system)  }
		)
		addEventHandlersForSlider(forSystem=true, "spinMax", "Spin at end",
			(project:Project, system:System, value:float) {  system.psSpinMax = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "spinMin", "Spin at start",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psSpinMinEnabled = enabled ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "spinMax", "Spin at end",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psSpinMaxEnabled = enabled ; updateParticleParams(project, system)  }
		)

		guiState.onRefresh.spinVariation = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psSpinVariationEnabled
			slider.value          = system.psSpinVariation
		}
		addEventHandlersForSlider(forSystem=true, "spinVariation", "Spin variation",
			(project:Project, system:System, value:float) {  system.psSpinVariation = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "spinVariation", "Spin variation",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psSpinVariationEnabled = enabled ; updateParticleParams(project, system)  }
		)
	}

	-- Sizes.
	do {
		guiState.onRefresh.sizesSection = (section:gui.Section) {
			local project, system = getCurrentProjectAndSystem()
			for 1, 8  guiState.setActive!(format("sizeContainer%d", it), (system.psSizes[it] ~= NULL))
		}
		guiState.onAction.sizeAdd = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local i               = cast(int) buttons.data

			if system.psSizes[8] ~= NULL {
				setErrorText("Max 8 sizes")
				return
			}

			recordChange("", "Add size", nil,
				[system, i] (project:Project) {  insert(system.psSizes, i, system.psSizes[i])  },
				[system, i] (project:Project) {  remove(system.psSizes, i)  },
				[system, i] (project:Project) {
					updateParticleParams(project, system)
					if isSystemCurrent(system)  for j = i, 8 {
						local name   = format("sizeContainer%d", j)
						local active = j <= #system.psSizes
						guiState.setActive!(name, active)
						if active  guiState.refreshRecursively!(name)
					}
				}
			)
		}
		guiState.onAction.sizeRemove = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local i               = cast(int) buttons.data
			local valueOld        = system.psSizes[i]
			local removingLast    = #system.psSizes == 1

			if removingLast and valueOld == 1  return

			if removingLast {
				recordChange("", "Remove size", nil,
					[system          ] (project:Project) {  system.psSizes[1] = 1         },
					[system, valueOld] (project:Project) {  system.psSizes[1] = valueOld  },
					[system          ] (project:Project) {  updateParticleParams(project, system) ; guiState.refreshRecursively!("sizeContainer1")  }
				)
			} else {
				recordChange("", "Remove size", nil,
					[system, i          ] (project:Project) {  remove(system.psSizes, i)  },
					[system, i, valueOld] (project:Project) {  insert(system.psSizes, i, valueOld)  },
					[system, i          ] (project:Project) {
						updateParticleParams(project, system)
						if isSystemCurrent(system)  for j = i, 8 {
							local name   = format("sizeContainer%d", j)
							local active = j <= #system.psSizes
							guiState.setActive!(name, active)
							if active  guiState.refreshRecursively!(name)
						}
					}
				)
			}
		}
		for i = 1, 8 {
			local name = format("size%d", i)
			guiState.onRefresh[name] = [i] (slider:gui.Slider) {
				local project, system = getCurrentProjectAndSystem()
				slider.value          = system.psSizes[i]
				if slider.value == NULL  errorf("Size #%d", i)
			}
			addEventHandlersForSlider(forSystem=true, name, "Size",
				[i] (project:Project, system:System, value:float) {  system.psSizes[i] = value ; updateParticleParams(project, system)  }
			)
		}

		guiState.onRefresh.sizeVariation = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.enabled        = system.psSizeVariationEnabled
			slider.value          = system.psSizeVariation
		}
		addEventHandlersForSlider(forSystem=true, "sizeVariation", "Size variation",
			(project:Project, system:System, value:float) {  system.psSizeVariation = value ; updateParticleParams(project, system)  }
		)
		addToggleEventHandler(forSystem=true, "sizeVariation", "Size variation",
			onToggle = (project:Project, system:System, enabled:bool) {  system.psSizeVariationEnabled = enabled ; updateParticleParams(project, system)  }
		)
	}

	-- Colors.
	guiState.onRefresh.colors = (box:gui.Vbox) {
		local project, system = getCurrentProjectAndSystem()
		local colors          = system.colors
		for 1, 8  guiState.setActive!(format("colorContainer%d", it), (colors[it*4] ~= NULL))
	}
	guiState.onAction.colorAdd = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project, system = getCurrentProjectAndSystem()
		local i               = cast(int) buttons.data

		if system.colors[8*4] ~= NULL {
			setErrorText("Max 8 colors")
			return
		}

		recordChange("", "Add color", nil,
			[system, i] (project:Project) {
				local i1 = i*4 - 3
				local h  = system.colors[i1  ]
				local s  = system.colors[i1+1]
				local v  = system.colors[i1+2]
				local a  = system.colors[i1+3]
				insert(system.colors, i1,   h)
				insert(system.colors, i1+1, s)
				insert(system.colors, i1+2, v)
				insert(system.colors, i1+3, a)
			},
			[system, i] (project:Project) {
				local i1 = i*4 - 3
				remove(system.colors, i1+3)
				remove(system.colors, i1+2)
				remove(system.colors, i1+1)
				remove(system.colors, i1)
			},
			[system, i] (project:Project) {
				updateParticleColors(system)
				if isSystemCurrent(system)  for j = i, 8 {
					local name   = format("colorContainer%d", j)
					local active = j*4 <= #system.colors
					guiState.setActive!(name, active)
					if active  guiState.refreshRecursively!(name)
				}
			}
		)
	}
	guiState.onAction.colorRemove = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		local project, system = getCurrentProjectAndSystem()
		local i               = cast(int) buttons.data
		local i1              = i*4 - 3
		local hOld            = system.colors[i1]
		local sOld            = system.colors[i1+1]
		local vOld            = system.colors[i1+2]
		local aOld            = system.colors[i1+3]
		local removingLast    = #system.colors == 4

		if removingLast and hOld == 0 and sOld == 0 and vOld == 1 and aOld == 1  return

		if removingLast {
			recordChange("", "Remove color", nil,
				[system] (project:Project) {
					system.colors[1] = 0
					system.colors[2] = 0
					system.colors[3] = 1
					system.colors[4] = 1
				},
				[system, hOld, sOld, vOld, aOld] (project:Project) {
					system.colors[1] = hOld
					system.colors[2] = sOld
					system.colors[3] = vOld
					system.colors[4] = aOld
				},
				[system] (project:Project) {
					updateParticleColors(system) ; guiState.refreshRecursively!("colorContainer1")
				}
			)
		} else {
			recordChange("", "Remove color", nil,
				[system, i] (project:Project) {
					local i1 = i*4 - 3
					remove(system.colors, i1+3)
					remove(system.colors, i1+2)
					remove(system.colors, i1+1)
					remove(system.colors, i1  )
				},
				[system, i, hOld, sOld, vOld, aOld] (project:Project) {
					local i1 = i*4 - 3
					insert(system.colors, i1,   hOld)
					insert(system.colors, i1+1, sOld)
					insert(system.colors, i1+2, vOld)
					insert(system.colors, i1+3, aOld)
				},
				[system, i] (project:Project) {
					updateParticleColors(system)
					if isSystemCurrent(system)  for j = i, 8 {
						local name   = format("colorContainer%d", j)
						local active = j*4 <= #system.colors
						guiState.setActive!(name, active)
						if active  guiState.refreshRecursively!(name)
					}
				}
			)
		}
	}
	static colorsBeforeDragging: []float = NULL
	guiState.onDragBegin.colorMove = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		colorsBeforeDragging  = system.colors
		system.colors         = {unpack(system.colors)}
	}
	guiState.onDrag.colorMove = (buttons:gui.Buttons, buttonIndex:int, mx,my:int) {
		local dragContainer = guiState.getElement!("colors", gui.Vbox)

		local project, system = getCurrentProjectAndSystem()
		local colors          = system.colors
		local i               = cast(int) buttons.data
		local targetIndex     = math.clamp(math.floor(1 + (my - (dragContainer.layoutY + guiState.getScrollOffset!(dragContainer))) / (dragContainer[1].layoutHeight + gui.SPACING)), 1, #colors//4)
		if targetIndex == i  return

		local dir = math.getSign(targetIndex-i)

		for j = i, targetIndex-dir, dir {
			colors[j*4-3], colors[(j+dir)*4-3] = colors[(j+dir)*4-3], colors[j*4-3]
			colors[j*4-2], colors[(j+dir)*4-2] = colors[(j+dir)*4-2], colors[j*4-2]
			colors[j*4-1], colors[(j+dir)*4-1] = colors[(j+dir)*4-1], colors[j*4-1]
			colors[j*4  ], colors[(j+dir)*4  ] = colors[(j+dir)*4  ], colors[j*4  ]
		}

		updateParticleColors(system)

		guiState.activeId  = dragContainer[targetIndex][1].id -- @Volatile
		guiState.hoveredId = guiState.activeId

		guiState.refreshRecursively!(dragContainer)
	}
	guiState.onDragEnd.colorMove = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		local colorsOld       = colorsBeforeDragging
		local colorsNew       = system.colors
		local newOrder        = false

		for colorsNew {
			if it ~= colorsOld[itIndex] {
				newOrder = true
				break
			}
		}
		if not newOrder  return

		recordChange("", "Reorder colors", nil,
			[system, colorsNew] (project:Project) {  system.colors = colorsNew  },
			[system, colorsOld] (project:Project) {  system.colors = colorsOld  },
			[system           ] (project:Project) {
				if isSystemCurrent(system)  guiState.refreshRecursively!("colors")
				updateParticleColors(system)
			}
		)
	}
	for i = 1, 8 {
		guiState.onRefresh[format("color%d", i)] = [i] (colorEl:gui.Color) {
			local project, system = getCurrentProjectAndSystem()
			local colors          = system.colors
			local i1              = i*4 - 3
			colorEl.color[1]      = colors[i1+0]
			colorEl.color[2]      = colors[i1+1]
			colorEl.color[3]      = colors[i1+2]
			colorEl.color[4]      = colors[i1+3]
		}
		addEventHandlersForColor(forSystem=true, format("color%d", i), "Color",
			[i] (project:Project, system:System, component:int, value:float) {  system.colors[(i-1)*4+component] = value ; updateParticleColors(system)  }
		)
	}

	guiState.onRefresh.colorPreview = (preview:gui.ColorPreview) {
		local project, system = getCurrentProjectAndSystem()
		preview.blendMode     = system.blendMode
	}

	guiState.onRefresh.blendMode = (radio:gui.Radio) {
		local project, system = getCurrentProjectAndSystem()
		local found, i        = indexWith(radio.buttons, "value", system.blendMode)
		assert(found)
		radio.index = i
	}
	addEventHandlersForRadio("blendMode", LG.BlendMode, "Blend mode",
		(project:Project, system:System, value:LG.BlendMode) {
			system.blendMode = value
			updateParticleParams(project, system)
			guiState.getElement!("colorPreview", gui.ColorPreview).blendMode = value
		}
	)

	-- Shader.
	do {
		guiState.onRefresh.shaderPath = (input:gui.InputText) {
			local project, system = getCurrentProjectAndSystem()
			input.value           = system.shaderPath
		}
		guiState.onAction.shaderPath = (input:gui.InputText, _:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			setShaderPath(project, system, Path(trim(input.value)).toString!())
		}
		guiState.onOption.shaderPath = (input:gui.InputText, _:int) {
			showRecentFilesContextMenu("Recent shaders", app.recentShaders, (path:string) {
				local project, system = getCurrentProjectAndSystem()
				setShaderPath(project, system, path)
			})
		}

		guiState.onAction.shaderChoose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()

			local ok, path = getFullPathToShader(project, system)
			local dir: string
			if ok      ok, dir  = Path(path).getDirectory!()
			if not ok  ok, dir  = Path(project.path).getDirectory!()
			if not ok  dir      = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"
			local ^ok, filename = Path(system.shaderPath).getFilename!()
			if not ok  filename = ""

			showFileDialog(.OPEN, "Choose shader", dir, filename, filenameHidePattern="%.hotparticles$",
				-- onHighlight = (pathObj:Path, pathAbsoluteObj:Path) {
				-- 	-- @UX: Preview shader.
				-- },
				onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
					local ok, dir, filename = pathAbsoluteObj.getDirectoryAndFilename!()
					if not ok  return -- @UX: Show error message.

					if not connectToRemoteDirectory(dir) {
						setErrorText("Could not access folder '%s'", dir)
						return
					}
					defer disconnectFromRemoteDirectory()

					addRecent(app.recentFolders, dir, app.maxRecentFiles)

					local shader = pcall_newShader(filename)
					if shader == NULL {
						setErrorText("'%s' is not a valid shader file", filename)
						return
					}

					local project, system = getCurrentProjectAndSystem()
					setShaderPath(project, system, pathObj.toString!())
					popPanel()
				}
			)
		}

		guiState.onAction.shaderRelative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local ok, path = toggleRelativePath(project, system.shaderPath, [*] () -> (success:bool, path:string) {
				local ok, path = getFullPathToShader(project, system)
				return ok, path
			})
			if ok  setShaderPath(project, system, path)
		}

		guiState.onAction.shaderReload = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			if system.shaderPath  updateParticleShader(project, system)
		}
	}

	guiState.onRefresh.customDataSystem = (input:gui.InputText) {
		local project, system = getCurrentProjectAndSystem()
		input.value           = system.customData
	}
	guiState.onAction.customDataSystem = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local project, system = getCurrentProjectAndSystem()
		local dataOld         = system.customData
		local dataNew         = input.value

		recordChange("", "Particle system custom data", nil,
			[system, dataNew] (project:Project) {  system.customData = dataNew  },
			[system, dataOld] (project:Project) {  system.customData = dataOld  },
			--[[           ]] (project:Project) {  guiState.refreshRecursively!("customDataSystem")  }
		)
	}

	--==============================================================
	--= File dialog
	--==============================================================
	do {
		local Item :: struct { isDir=false, name="" }
		static dirCurrent:  string = NULL
		static dirFallback: string = NULL

		local setSelectionToBasename :: (input:gui.InputText, filename:string) {
			local basename = splitBasenameAndExtension(filename)
			input.field.setSelection!(0, utf8.getLength(basename))
		}

		guiState.onActive.fileDialog = (frame:gui.Frame) {
			dirCurrent  = fileDialog_dir
			dirFallback = getSaveDirectory()

			do {
				local buttons   = guiState.getElement!("fileDialog_buttons", gui.Buttons)
				local _, button = itemWith(buttons.buttons, "name", "fileDialog_choose")

				button.label
					= fileDialog_type == .OPEN ? "Open"
					: fileDialog_type == .SAVE ? "Save"
					:                            "Choose"
			}

			local filenameInput = guiState.getElement!("fileDialog_filename", gui.InputText)
			filenameInput.value = fileDialog_filename

			guiState.refreshRecursively!("fileDialog_bookmarks")
			guiState.refreshRecursively!("fileDialog_items")
			guiState.setFocus!(filenameInput)
			setSelectionToBasename(filenameInput, fileDialog_filename)

			if fileDialog_filename {
				local itemsButtons = guiState.getElement!("fileDialog_items", gui.Buttons)

				for button: itemsButtons.buttons {
					local item = cast(Item) button.value
					if item.name ~= fileDialog_filename  continue

					local x, y, w, h      = guiState.getButtonLayout!(itemsButtons, itIndex)
					local itemsScrollable = guiState.getElement!("fileDialog_itemsSrollable", gui.Scrollable)
					guiState.scrollTo!(itemsScrollable, -math.round(y-itemsScrollable.layoutY-(itemsScrollable.layoutHeight-h)/2), limit=true)
					break
				}
			}
		}

		guiState.onInactive.fileDialog = (frame:gui.Frame) {
			if fileDialog_onClose ~= NULL  fileDialog_onClose()
		}

		-- Bookmarks.
		guiState.onRefresh.fileDialog_bookmarks = (buttons:gui.Buttons) {
			buttons.buttons = {}
			for app.bookmarkedFolders {
				insert(buttons.buttons, cast(gui.Button){ value=it, label=it, image="iconFolder" })
			}
		}

		guiState.onAction.fileDialog_bookmarks = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			dirCurrent = app.bookmarkedFolders[buttonIndex]
			guiState.refreshRecursively!("fileDialog_items")
		}

		guiState.onOption.fileDialog_bookmarks = (buttons:gui.Buttons, indexToRemove:int) {
			local ITEMS :: {"Remove bookmark"}

			guiState.showContextMenu!(ITEMS, [indexToRemove] (choice:int) {
				if choice == {
					case 1:
						remove(app.bookmarkedFolders, indexToRemove)
						guiState.refreshRecursively!("fileDialog_bookmarks")
				}
			})
		}

		guiState.onAction.fileDialog_addBookmark = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			if not insertIfUnique(app.bookmarkedFolders, dirCurrent)  return
			sort(app.bookmarkedFolders)
			guiState.refreshRecursively!("fileDialog_bookmarks")
		}

		-- Directory.
		guiState.onRefresh.fileDialog_directory = (input:gui.InputText, _:int) {
			input.value = dirCurrent
		}

		guiState.onSubmit.fileDialog_directory = (input:gui.InputText, _:int) {
			local dirObj = Path(trim(input.value))
			if not dirObj.isAbsolute  return

			dirCurrent = dirObj.toString!()
			guiState.refreshRecursively!("fileDialog_items")
		}

		guiState.onOption.fileDialog_directory = (input:gui.InputText, _:int) {
			showRecentFilesContextMenu("Recent folders", app.recentFolders, (dir:string) {
				dirCurrent = dir
				guiState.refreshRecursively!("fileDialog_items")
			})
		}

		-- Directory items.
		guiState.onRefresh.fileDialog_items = (buttons:gui.Buttons) {
			local dir = dirCurrent

			if not connectToRemoteDirectory(dir) {
				dir = dirFallback
				if not connectToRemoteDirectory(dir) {
					dir = fileDialog_lastDirectory
					if not (dir and connectToRemoteDirectory(dir)) {
						dir = getSaveDirectory().."/projects"
						if not connectToRemoteDirectory(dir) {
							dir = getSaveDirectory()
							if not connectToRemoteDirectory(dir) {
								dir = getCwd()
								assert(connectToRemoteDirectory(dir))
							}
						}
					}
				}
			}
			defer disconnectFromRemoteDirectory()
			dirCurrent  = dir
			dirFallback = dir -- Last successfully connected directory.

			local dirs:      []string
			local filenames: []string

			for LF.getDirectoryItems("") {
				static info: LF.FileInfo

				if LF.getInfo(it, info) == nil {
					-- void  The file may be a system file or something.
				} elseif info.type == .DIRECTORY {
					if not findPattern(it, "^%$")  insert(dirs, it)
				} elseif info.type == .FILE {
					if (
						not fileDialog_chooseFolder
						and (not fileDialog_filenamePattern or findPattern(it, fileDialog_filenamePattern))
						and not (fileDialog_filenameHidePattern and findPattern(it, fileDialog_filenameHidePattern))
					) {
						insert(filenames, it)
					}
				}
			}

			sort(dirs,      compareFilenames)
			sort(filenames, compareFilenames)

			buttons.buttons = {}

			if Path(dir).path {
				insert(buttons.buttons, cast(gui.Button){ value=cast(Item){isDir=true,name=".."}, label="..", image="iconFolder" })
			}

			for dirs {
				insert(buttons.buttons, cast(gui.Button){
					value = cast(Item) {isDir=true, name=it},
					label = it,
					image = "iconFolder",
				})
			}
			for filenames {
				local EXT_TO_ICON: struct { !key:string, !value:string } : {
					[".hotparticles"] = "iconFileHotparticles",

					[".jpg"]  = "iconFileImage",
					[".jpeg"] = "iconFileImage",
					[".png"]  = "iconFileImage",
					[".bmp"]  = "iconFileImage",
					[".tga"]  = "iconFileImage",
					[".hdr"]  = "iconFileImage",
					[".pic"]  = "iconFileImage",
					[".exr"]  = "iconFileImage",

					[".gl"]   = "iconFileShader",
					[".glh"]  = "iconFileShader",
					[".glsl"] = "iconFileShader",
					[".frag"] = "iconFileShader",
					[".vert"] = "iconFileShader",

					[".lua"]  = "iconFileLua",
					[".wlua"] = "iconFileLua",
				}

				local basename, ext = splitBasenameAndExtension(it, keepDot=true)

				insert(buttons.buttons, cast(gui.Button){
					value  = cast(Item) {isDir=false, name=it},
					label  = basename,
					suffix = ext,
					image  = EXT_TO_ICON[ext] ~= NULL ? EXT_TO_ICON[ext] : "",
				})
			}

			guiState.scrollTo!(guiState.getElement!("fileDialog_itemsSrollable", gui.Scrollable), 0)
			guiState.refreshRecursively!("fileDialog_directory")
		}

		local makeRelativeOrClone :: (pathObj:Path) -> Path {
			if not app.preferRelativePaths or fileDialog_type == .SAVE  return pathObj.clone!()

			local dir: string = NULL

			if fileDialog_relativeTo {
				dir = fileDialog_relativeTo

			} else {
				local projectPath = app.projects[app.currentProjectIndex].path
				if not projectPath  return pathObj.clone!()

				_, dir = Path(projectPath).getDirectory!()
			}

			local ok, pathRelativeObj = pathObj.getRelativeTo!(dir)
			if ok  return pathRelativeObj

			return pathObj.clone!()
		}

		guiState.onAction.fileDialog_items = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local item = cast(Item) buttons.buttons[buttonIndex].value

			if item.isDir and (item.name == ".." or not fileDialog_chooseFolder)  return

			local input = guiState.getElement!("fileDialog_filename", gui.InputText)
			input.value = item.name

			if fileDialog_onHighlight ~= NULL {
				local pathObj = Path(dirCurrent)
				insert(pathObj.path, item.name)
				fileDialog_onHighlight(makeRelativeOrClone(pathObj), pathObj)
			}
		}

		-- Choice.
		guiState.onDouble.fileDialog_items = (buttons:gui.Buttons, buttonIndex:int) {
			local item = cast(Item) buttons.buttons[buttonIndex].value

			if not item.isDir {
				choosePath()
				return
			}

			-- Note: We don't care about chooseFolder here - we always navigate folders on double-click!

			local dirObj = Path(dirCurrent)

			if item.name == ".." {
				dirObj.pop!()
			} else {
				insert(dirObj.path, item.name)
			}

			dirCurrent = dirObj.toString!()
			guiState.refreshRecursively!(buttons)
		}

		static autocompletePrefix = "" -- @Incomplete: Reset this on input blur.

		guiState.onBeforeKeyPressed.fileDialog_filename = (input:gui.InputText, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (ignore:bool) {
			if key ~= "tab" {
				autocompletePrefix = ""
				return false
			}

			local currentPrefix = toLower(input.field.getText!())
			if not currentPrefix  return true

			autocompletePrefix = autocompletePrefix ?: currentPrefix

			local filenames: []string
			do {
				if not connectToRemoteDirectory(dirCurrent)  return true
				defer disconnectFromRemoteDirectory()

				for LF.getDirectoryItems("")  insert(filenames, it)
				if not filenames  return true

				sort(filenames, compareFilenames)
			}

			local startIndex = 0

			for filenames {
				if toLower(it) == currentPrefix {
					startIndex = itIndex
					break
				}
			}

			if startIndex == 0  for filenames {
				local found, pos = find(toLower(it), currentPrefix)

				if found and pos == 1 {
					startIndex = itIndex
					break
				}
			}

			if startIndex == 0  return true -- No match.

			for offset = 1, #filenames {
				local i          = (startIndex + offset - 1) % #filenames + 1
				local filename   = filenames[i]
				local found, pos = find(toLower(filename), autocompletePrefix)

				if found and pos == 1 {
					input.field.setText!(filename)
					input.field.selectAll!()
					break
				}
			}

			return true
		}
		guiState.onBeforeTextInput.fileDialog_filename = (input:gui.InputText, text:string) -> (ignore:bool) {
			autocompletePrefix = ""
			return false
		}

		guiState.onSubmit.fileDialog_filename = (input:gui.InputText)                                           {  choosePath()  }
		guiState.onAction.fileDialog_choose   = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {  choosePath()  }

		local choosePath :: () {
			local input = guiState.getElement!("fileDialog_filename", gui.InputText)
			input.value = trim(input.value)

			if input.value == "." and fileDialog_chooseFolder {
				if fileDialog_onChoose ~= NULL {
					local pathObj = Path(dirCurrent)
					fileDialog_onChoose(makeRelativeOrClone(pathObj), pathObj)
				}
				return
			}

			local dotdot  = (input.value == ".." or findPattern(input.value, "[/\\]%.%.$"))
			local pathObj = Path(input.value)
			input.value   = pathObj.toString!()

			if pathObj.isEmpty!() {
				guiState.setFocus!("fileDialog_filename")
				return
			}

			pathObj.prepend!(dirCurrent) -- Fails if pathObj is absolute.

			local tryNavigate :: (pathObj:Path) -> (success:bool) {
				local path = pathObj.toString!()

				if not connectToRemoteDirectory(path)  return false -- Succeeds if the path exists AND is a folder.
				disconnectFromRemoteDirectory()

				dirCurrent = path

				local input = guiState.getElement!("fileDialog_filename", gui.InputText)
				input.value = fileDialog_filename

				guiState.refreshRecursively!("fileDialog_items")
				guiState.setFocus!(input)
				input.field.selectAll!()--setSelectionToBasename(input, fileDialog_filename)

				return true
			}

			if not fileDialog_chooseFolder or dotdot {
				if tryNavigate(pathObj)  return
				if dotdot                return -- Never trigger onChoose with ".."!
			}

			if fileDialog_type ~= .OPEN {
				local ok, filename = pathObj.getFilename!()
				if not ok {
					guiState.setFocus!("fileDialog_filename")
					return
				}
			}

			if fileDialog_onChoose ~= NULL {
				fileDialog_onChoose(makeRelativeOrClone(pathObj), pathObj)
			}
		}
	}

	--==============================================================
	--= Export project
	--==============================================================

	guiState.onActive.exportProject = (frame:gui.Frame) {
		guiState.refreshRecursively!("exportProject")
	}

	-- Files.
	do {
		guiState.onRefresh.exportProject_baseDirectory = (input:gui.InputText) {
			local project = app.projects[app.currentProjectIndex]
			input.value   = project.exportBaseDirectory
		}
		guiState.onAction.exportProject_baseDirectory = (input:gui.InputText, _:int, source:gui.ActionSource) {
			local project = app.projects[app.currentProjectIndex]
			input.value   = Path(trim(input.value)).toString!()

			project.exportBaseDirectory = input.value
			markEdited(project)

			guiState.refreshRecursively!("exportProject_baseDirectoryResult")
			guiState.refreshRecursively!("exportProject_baseDirectoryResultInfo")
			guiState.refreshRecursively!("exportProject_particles_path")
			guiState.refreshRecursively!("exportProject_particles_pathResult")
			guiState.refreshRecursively!("exportProject_particles_pathResultInfo")
			guiState.refreshRecursively!("exportProject_textures_directory")
			guiState.refreshRecursively!("exportProject_textures_pathResults")
			guiState.refreshRecursively!("exportProject_textures_pathResultsInfo")
		}
		guiState.onRefresh.exportProject_baseDirectoryResult = (textEl:gui.Text) {
			local project  = app.projects[app.currentProjectIndex]
			local ok, path = resolveBaseOuputPath(project)

			if not ok {
				textEl.text = "Missing/invalid path!"
				return
			}

			textEl.text = path
		}
		guiState.onRefresh.exportProject_baseDirectoryResultInfo = (buttons:gui.Buttons) {
			buttons.tooltip = guiState.getElement!("exportProject_baseDirectoryResult", gui.Text).text
		}

		guiState.onAction.exportProject_baseDirectory_choose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project = app.projects[app.currentProjectIndex]

			local filename    = ""
			local dir: string = NULL

			local ok, fullPath = resolveBaseOuputPath(project)
			if ok {
				ok, dir, filename = Path(fullPath).getDirectoryAndFilename!()
				if not ok  dir, filename = fullPath, "."
			} else {
				dir = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"
			}

			showFileDialog(floating=true, .CHOOSE, chooseFolder=true, "Choose base folder", dir, filename,
				onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
					local ok, parentDir = pathAbsoluteObj.getDirectory!()
					if ok  addRecent(app.recentFolders, parentDir, app.maxRecentFiles)

					local project               = app.projects[app.currentProjectIndex]
					project.exportBaseDirectory = pathObj.toString!()
					markEdited(project)

					guiState.refreshRecursively!("exportProject_baseDirectory")
					guiState.refreshRecursively!("exportProject_baseDirectoryResult")
					guiState.refreshRecursively!("exportProject_baseDirectoryResultInfo")
					guiState.refreshRecursively!("exportProject_particles_path")
					guiState.refreshRecursively!("exportProject_particles_pathResult")
					guiState.refreshRecursively!("exportProject_particles_pathResultInfo")
					guiState.refreshRecursively!("exportProject_textures_directory")
					guiState.refreshRecursively!("exportProject_textures_pathResults")
					guiState.refreshRecursively!("exportProject_textures_pathResultsInfo")

					popPanel()
				}
			)
		}

		guiState.onAction.exportProject_baseDirectory_relative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project = app.projects[app.currentProjectIndex]

			local ok, path = toggleRelativePath(project, project.exportBaseDirectory,
				fullPathGetter = [*] () -> (success:bool, fullPath:string) {
					local ok, fullPath = resolveBaseOuputPath(project)
					return ok, fullPath
				}
			)
			if not ok  return

			project.exportBaseDirectory = path
			markEdited(project)

			guiState.refreshRecursively!("exportProject_baseDirectory")
			-- Shouldn't be needed, but just to be safe:
			guiState.refreshRecursively!("exportProject_baseDirectoryResult")
			guiState.refreshRecursively!("exportProject_baseDirectoryResultInfo")
			guiState.refreshRecursively!("exportProject_particles_path")
			guiState.refreshRecursively!("exportProject_particles_pathResult")
			guiState.refreshRecursively!("exportProject_particles_pathResultInfo")
			guiState.refreshRecursively!("exportProject_textures_directory")
			guiState.refreshRecursively!("exportProject_textures_pathResults")
			guiState.refreshRecursively!("exportProject_textures_pathResultsInfo")
		}
	}

	-- Particles file.

	do {
		guiState.onRefresh.exportProject_particles_writeFile = (checkbox:gui.Checkbox) {
			local project    = app.projects[app.currentProjectIndex]
			checkbox.checked = project.exportParticles
		}
		guiState.onAction.exportProject_particles_writeFile = (checkbox:gui.Checkbox, _:int, source:gui.ActionSource) {
			local project           = app.projects[app.currentProjectIndex]
			project.exportParticles = checkbox.checked
			markEdited(project)
			guiState.refreshRecursively!("exportProject_particles_pathResult")
			guiState.refreshRecursively!("exportProject_particles_pathResultInfo")
		}

		guiState.onRefresh.exportProject_particles_overwrite = (checkbox:gui.Checkbox) {
			local project    = app.projects[app.currentProjectIndex]
			checkbox.checked = project.exportParticlesOverwrite
		}
		guiState.onAction.exportProject_particles_overwrite = (checkbox:gui.Checkbox, _:int, source:gui.ActionSource) {
			local project                    = app.projects[app.currentProjectIndex]
			project.exportParticlesOverwrite = checkbox.checked
			markEdited(project)
		}
	}

	do {
		guiState.onRefresh.exportProject_particles_path = (input:gui.InputText) {
			local project = app.projects[app.currentProjectIndex]
			input.value   = project.exportParticlesPath
			-- input.placeholder = getExportedParticlesDefaultFilename(project)
		}
		guiState.onAction.exportProject_particles_path = (input:gui.InputText, _:int, source:gui.ActionSource) {
			local project               = app.projects[app.currentProjectIndex]
			input.value                 = Path(trim(input.value)).toString!()
			project.exportParticlesPath = input.value
			markEdited(project)
			guiState.refreshRecursively!("exportProject_particles_pathResult")
			guiState.refreshRecursively!("exportProject_particles_pathResultInfo")
		}
		guiState.onRefresh.exportProject_particles_pathResult = (textEl:gui.Text) {
			local project = app.projects[app.currentProjectIndex]

			if not project.exportParticles {
				textEl.text = ""
				return
			}

			local ok, path = resolveParticlesOuputPath(project)

			if not ok {
				textEl.text = "Missing/invalid path!"
				return
			}

			textEl.text = path
		}
		guiState.onRefresh.exportProject_particles_pathResultInfo = (buttons:gui.Buttons) {
			buttons.tooltip = guiState.getElement!("exportProject_particles_pathResult", gui.Text).text
		}

		guiState.onAction.exportProject_particles_path_choose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project             = app.projects[app.currentProjectIndex]
			local hasBaseDir, baseDir = resolveBaseOuputPath(project)

			local filename    = "?.lua"
			local dir: string = NULL

			local ok, fullPath = resolveParticlesOuputPath(project)
			if ok
				_, dir, filename = Path(fullPath).getDirectoryAndFilename!()
			else
				dir = hasBaseDir ? baseDir : (fileDialog_lastDirectory ?: getSaveDirectory().."/projects")

			showFileDialog(floating=true, .CHOOSE, "Choose particles file", dir, filename, relativeTo=(hasBaseDir ? baseDir : ""),
				onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
					local ok, dir = pathAbsoluteObj.getDirectory!()
					if not ok  return -- @UX: Show error message.

					addRecent(app.recentFolders, dir, app.maxRecentFiles)

					local project               = app.projects[app.currentProjectIndex]
					project.exportParticlesPath = pathObj.toString!()
					markEdited(project)

					guiState.refreshRecursively!("exportProject_particles_path")
					guiState.refreshRecursively!("exportProject_particles_pathResult")
					guiState.refreshRecursively!("exportProject_particles_pathResultInfo")

					popPanel()
				}
			)
		}

		guiState.onAction.exportProject_particles_path_relative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project             = app.projects[app.currentProjectIndex]
			local hasBaseDir, baseDir = resolveBaseOuputPath(project)

			local ok, path = toggleRelativePath(project, project.exportParticlesPath, relativeTo=(hasBaseDir ? baseDir : ""),
				fullPathGetter = [*] () -> (success:bool, fullPath:string) {
					local ok, fullPath = resolveParticlesOuputPath(project)
					return ok, fullPath
				}
			)
			if not ok  return

			project.exportParticlesPath = path
			markEdited(project)

			guiState.refreshRecursively!("exportProject_particles_path")
			-- Shouldn't be needed, but just to be safe:
			guiState.refreshRecursively!("exportProject_particles_pathResult")
			guiState.refreshRecursively!("exportProject_particles_pathResultInfo")
		}
	}

	local showTemplateDropdownMenu :: (buttons:gui.Buttons, customPath:string, cb:(templateName:string, templatePath:string)) {
		local templateNames: []string

		for LF.getDirectoryItems(EXPORT_TEMPLATES_DIRECTORY) {
			static info: LF.FileInfo

			if findPattern(it, "%.lua$") and LF.getInfo(EXPORT_TEMPLATES_DIRECTORY.."/"..it, info) ~= nil and info.type == .FILE {
				insert(templateNames, getSubstring(it, 1, -5))
			}
		}
		if not templateNames  return

		local x = buttons.layoutX
		local y = buttons.layoutY + buttons.layoutHeight + guiState.getScrollOffset!(buttons)

		guiState.showContextMenuWithInput!(x, y, minWidth=buttons.layoutWidth, customPath, inputTooltip="Path to a template in a custom location", templateNames,
			cb = [templateNames,cb] (choice:int) {
				if choice > 0  cb(templateNames[choice], "")
			},
			cbSubmit = [cb] (value:string) {
				cb("", value)
			}--[[,
			cbOption = [cb] () {
				showRecentFilesContextMenu("Recent templates", app.recentTemplates, keepExistingMenus=true, [cb] (path:string) {
					cb("", path)
				})
			}]]
		)
	}

	do {
		guiState.onRefresh.exportProject_particles_template = (buttons:gui.Buttons) {
			local project            = app.projects[app.currentProjectIndex]
			buttons.buttons[1].label = project.exportParticlesTemplate ?: project.exportParticlesTemplatePath
		}
		guiState.onAction.exportProject_particles_template = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			showTemplateDropdownMenu(buttons, app.projects[app.currentProjectIndex].exportParticlesTemplatePath, (templateName:string, templatePath:string) {
				local project = app.projects[app.currentProjectIndex]

				project.exportParticlesTemplate = templateName
				if not templateName  setCustomParticlesTemplatePath(project, Path(templatePath).toString!(), saveRecent=true)

				markEdited(project)
				guiState.refreshRecursively!("exportProject_particles_template")
			})
		}
		guiState.onOption.exportProject_particles_template = (buttons:gui.Buttons, buttonIndex:int) {
			showRecentFilesContextMenu("Recent templates", app.recentTemplates, (templatePath:string) {
				local project = app.projects[app.currentProjectIndex]

				if project.exportParticlesTemplate {
					project.exportParticlesTemplate = ""
					markEdited(project)
				}
				setCustomParticlesTemplatePath(project, templatePath, saveRecent=true)

				guiState.refreshRecursively!("exportProject_particles_template")
			})
		}

		guiState.onAction.exportProject_particles_templateChoose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project = app.projects[app.currentProjectIndex]
			local pathObj = Path(project.exportParticlesTemplatePath)
			local ok, dir = pathObj.getDirectory!()

			if not ok {
				dir = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"

			} else {
				local dirObj = Path(dir)

				if not dirObj.isAbsolute {
					ok, dir = Path(project.path).getDirectory!()
					dirObj.prepend!(ok ? dir : (fileDialog_lastDirectory ?: getSaveDirectory().."/projects"))
					dir = dirObj.toString!()
				}
			}

			local ^ok, filename = pathObj.getFilename!()
			if not ok  filename = ""

			showFileDialog(floating=true, .OPEN, "Choose template", dir, filename, filenamePattern="%.lua$",
				onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
					local ok, dir = pathAbsoluteObj.getDirectory!()
					if not ok  return -- @UX: Show error message.

					addRecent(app.recentFolders, dir, app.maxRecentFiles)

					local project = app.projects[app.currentProjectIndex]

					if project.exportParticlesTemplate {
						project.exportParticlesTemplate = ""
						markEdited(project)
					}
					setCustomParticlesTemplatePath(project, pathObj.toString!(), saveRecent=true)
					guiState.refreshRecursively!("exportProject_particles_template")
					popPanel()
				}
			)
		}

		guiState.onAction.exportProject_particles_templateRelative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project = app.projects[app.currentProjectIndex]
			if project.exportParticlesTemplate  return

			local ok, path = toggleRelativePath(project, project.exportParticlesTemplatePath, [*] () -> (success:bool, path:string) {
				local ok, path = getFullPathToCustomParticlesTemplate(project)
				return ok, path
			})
			if not ok  return

			setCustomParticlesTemplatePath(project, path)
			guiState.refreshRecursively!("exportProject_particles_template")
		}
	}

	-- Texture files.
	do {
		guiState.onRefresh.exportProject_textures_copyFiles = (checkbox:gui.Checkbox) {
			local project    = app.projects[app.currentProjectIndex]
			checkbox.checked = project.exportTextures
		}
		guiState.onAction.exportProject_textures_copyFiles = (checkbox:gui.Checkbox, _:int, source:gui.ActionSource) {
			local project          = app.projects[app.currentProjectIndex]
			project.exportTextures = checkbox.checked
			markEdited(project)
			guiState.refreshRecursively!("exportProject_textures_pathResults")
			guiState.refreshRecursively!("exportProject_textures_pathResultsInfo")
		}

		guiState.onRefresh.exportProject_textures_overwrite = (checkbox:gui.Checkbox) {
			local project    = app.projects[app.currentProjectIndex]
			checkbox.checked = project.exportTexturesOverwrite
		}
		guiState.onAction.exportProject_textures_overwrite = (checkbox:gui.Checkbox, _:int, source:gui.ActionSource) {
			local project                   = app.projects[app.currentProjectIndex]
			project.exportTexturesOverwrite = checkbox.checked
			markEdited(project)
		}
	}

	do {
		guiState.onRefresh.exportProject_textures_directory = (input:gui.InputText) {
			local project = app.projects[app.currentProjectIndex]
			input.value   = project.exportTexturesDirectory
		}
		guiState.onAction.exportProject_textures_directory = (input:gui.InputText, _:int, source:gui.ActionSource) {
			local project                   = app.projects[app.currentProjectIndex]
			input.value                     = Path(trim(input.value)).toString!()
			project.exportTexturesDirectory = input.value
			markEdited(project)
			guiState.refreshRecursively!("exportProject_textures_pathResults")
			guiState.refreshRecursively!("exportProject_textures_pathResultsInfo")
		}
		guiState.onRefresh.exportProject_textures_pathResults = (textEl:gui.Text) {
			local project = app.projects[app.currentProjectIndex]

			if not project.exportTextures {
				textEl.text = ""
				return
			}

			local paths: []string
			local pathSet: struct { !key:string, !value:bool }

			for project.systems {
				local ok, path = resolveTextureOutputPath(project, it)

				if not ok {
					textEl.text = "Missing/invalid paths!"
					return
				}

				if not pathSet[path] {
					pathSet[path] = true
					insert(paths, path)
				}
			}

			textEl.text = concatinate(paths, "\n")
		}
		guiState.onRefresh.exportProject_textures_pathResultsInfo = (buttons:gui.Buttons) {
			buttons.tooltip = guiState.getElement!("exportProject_textures_pathResults", gui.Text).text
		}

		guiState.onAction.exportProject_textures_directory_choose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project             = app.projects[app.currentProjectIndex]
			local hasBaseDir, baseDir = resolveBaseOuputPath(project)

			local filename    = ""
			local dir: string = NULL

			local ok, fullPath = resolveTextureOutputDirectory(project)
			if ok {
				ok, dir, filename = Path(fullPath).getDirectoryAndFilename!()
				if not ok  dir, filename = fullPath, "."
			} else {
				dir = hasBaseDir ? baseDir : (fileDialog_lastDirectory ?: getSaveDirectory().."/projects")
			}

			showFileDialog(floating=true, .CHOOSE, chooseFolder=true, "Choose texture folder", dir, filename, relativeTo=(hasBaseDir ? baseDir : ""),
				onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
					local ok, parentDir = pathAbsoluteObj.getDirectory!()
					if ok  addRecent(app.recentFolders, parentDir, app.maxRecentFiles)

					local project                   = app.projects[app.currentProjectIndex]
					project.exportTexturesDirectory = pathObj.toString!()
					markEdited(project)

					guiState.refreshRecursively!("exportProject_textures_directory")
					guiState.refreshRecursively!("exportProject_textures_pathResults")
					guiState.refreshRecursively!("exportProject_textures_pathResultsInfo")

					popPanel()
				}
			)
		}

		guiState.onAction.exportProject_textures_directory_relative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project             = app.projects[app.currentProjectIndex]
			local hasBaseDir, baseDir = resolveBaseOuputPath(project)

			local ok, path = toggleRelativePath(project, project.exportTexturesDirectory, relativeTo=(hasBaseDir ? baseDir : ""),
				fullPathGetter = [*] () -> (success:bool, fullPath:string) {
					local ok, fullPath = resolveTextureOutputDirectory(project)
					return ok, fullPath
				}
			)
			if not ok  return

			project.exportTexturesDirectory = path
			markEdited(project)

			guiState.refreshRecursively!("exportProject_textures_directory")
			-- Shouldn't be needed, but just to be safe:
			guiState.refreshRecursively!("exportProject_textures_pathResults")
			guiState.refreshRecursively!("exportProject_textures_pathResultsInfo")
		}
	}

	guiState.onAction.exportProject_exportFiles = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
		tryExportFiles()
	}

	-- Clipboard.
	do {
		guiState.onRefresh.exportProject_clipboard_template = (buttons:gui.Buttons) {
			local project            = app.projects[app.currentProjectIndex]
			buttons.buttons[1].label = project.exportClipboardTemplate ?: project.exportClipboardTemplatePath
		}
		guiState.onAction.exportProject_clipboard_template = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			showTemplateDropdownMenu(buttons, app.projects[app.currentProjectIndex].exportClipboardTemplatePath, (templateName:string, templatePath:string) {
				local project = app.projects[app.currentProjectIndex]

				project.exportClipboardTemplate = templateName
				if not templateName  setCustomClipboardTemplatePath(project, Path(templatePath).toString!(), saveRecent=true)

				markEdited(project)
				guiState.refreshRecursively!("exportProject_clipboard_template")
			})
		}
		guiState.onOption.exportProject_clipboard_template = (buttons:gui.Buttons, buttonIndex:int) {
			showRecentFilesContextMenu("Recent templates", app.recentTemplates, (templatePath:string) {
				local project = app.projects[app.currentProjectIndex]

				if project.exportClipboardTemplate {
					project.exportClipboardTemplate = ""
					markEdited(project)
				}
				setCustomClipboardTemplatePath(project, templatePath, saveRecent=true)

				guiState.refreshRecursively!("exportProject_clipboard_template")
			})
		}

		guiState.onAction.exportProject_clipboard_templateChoose = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project = app.projects[app.currentProjectIndex]
			local pathObj = Path(project.exportClipboardTemplatePath)
			local ok, dir = pathObj.getDirectory!()

			if not ok {
				dir = fileDialog_lastDirectory ?: getSaveDirectory().."/projects"

			} else {
				local dirObj = Path(dir)

				if not dirObj.isAbsolute {
					ok, dir = Path(project.path).getDirectory!()
					dirObj.prepend!(ok ? dir : (fileDialog_lastDirectory ?: getSaveDirectory().."/projects"))
					dir = dirObj.toString!()
				}
			}

			local ^ok, filename = pathObj.getFilename!()
			if not ok  filename = ""

			showFileDialog(floating=true, .OPEN, "Choose template", dir, filename, filenamePattern="%.lua$",
				onChoose = (pathObj:Path, pathAbsoluteObj:Path) {
					local ok, dir = pathAbsoluteObj.getDirectory!()
					if not ok  return -- @UX: Show error message.

					addRecent(app.recentFolders, dir, app.maxRecentFiles)

					local project = app.projects[app.currentProjectIndex]

					if project.exportClipboardTemplate {
						project.exportClipboardTemplate = ""
						markEdited(project)
					}
					setCustomClipboardTemplatePath(project, pathObj.toString!(), saveRecent=true)
					guiState.refreshRecursively!("exportProject_clipboard_template")
					popPanel()
				}
			)
		}

		guiState.onAction.exportProject_clipboard_templateRelative = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project = app.projects[app.currentProjectIndex]
			if project.exportClipboardTemplate  return

			local ok, path = toggleRelativePath(project, project.exportClipboardTemplatePath, [*] () -> (success:bool, path:string) {
				local ok, path = getFullPathToCustomClipboardTemplate(project)
				return ok, path
			})
			if not ok  return

			setCustomClipboardTemplatePath(project, path)
			guiState.refreshRecursively!("exportProject_clipboard_template")
		}

		guiState.onAction.exportProject_clipboard_export = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project      = app.projects[app.currentProjectIndex]
			local data: string = NULL

			if project.exportClipboardTemplate {
				local ok, ^data = generateDataToExportFromTemplate(project.exportClipboardTemplate, "")
				if not ok  return -- Error already reported.
			} else {
				local ok, fullPath = getFullPathToCustomClipboardTemplate(project)
				if not ok {
					setErrorText("Possibly invalid template path")
					return
				}
				ok, data = generateDataToExportFromTemplate("", fullPath)
				if not ok  return -- Error already reported.
			}

			love.system.setClipboardText(data)
			setMessageText("Exported to clipboard")
		}
	}

	--==============================================================
	--= Animation
	--==============================================================
	do {
		local GUI_VALUE_ELEMENTS :: {
			"animation_sequence_areaPosition",
			"animation_sequence_areaSize",
			"animation_sequence_framePadding",
			"animation_sequence_frameSpacing",
			"animation_sequence_frameSize",
			"animation_sequence_rows",
			"animation_sequence_columns",
		}

		static savedEdited: bool             = NULL
		static savedFrames: []AnimationFrame = NULL
		static savedLifetimeMin: float       = NULL
		static savedLifetimeMax: float       = NULL

		guiState.onActive.animation = (frame:gui.Frame) {
			local project, system = getCurrentProjectAndSystem()
			savedEdited           = project.edited
			savedFrames           = system.frames
			savedLifetimeMin      = system.psParticleLifetimeMin
			savedLifetimeMax      = system.psParticleLifetimeMax
			system.frames         = copyArray(system.frames)

			for GUI_VALUE_ELEMENTS {
				local input     = guiState.getElement!(it, gui.InputText)
				local ok, value = getGuiValue(system, it)
				if ok  input.value = value
			}

			guiState.refreshRecursively!(frame)
		}

		guiState.onAction.animation_ok = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project,        system         = getCurrentProjectAndSystem()
			local framesOld,      framesNew      = savedFrames,      system.frames
			local lifetimeMinOld, lifetimeMinNew = savedLifetimeMin, system.psParticleLifetimeMin
			local lifetimeMaxOld, lifetimeMaxNew = savedLifetimeMax, system.psParticleLifetimeMax

			recordChange("", "Animation", nil,
				[system, framesNew, lifetimeMinNew, lifetimeMaxNew] (project:Project) {
					system.frames                = framesNew
					system.psParticleLifetimeMin = lifetimeMinNew
					system.psParticleLifetimeMax = lifetimeMaxNew
				},
				[system, framesOld, lifetimeMinOld, lifetimeMaxOld] (project:Project) {
					system.frames                = framesOld
					system.psParticleLifetimeMin = lifetimeMinOld
					system.psParticleLifetimeMax = lifetimeMaxOld
				},
				[system] (project:Project) {
					updateParticleAnimation(system)
					updateParticleParams(project, system)
					guiState.refreshRecursively!("particleLifetimeMin")
					guiState.refreshRecursively!("particleLifetimeMax")
				}
			)

			popPanel()
		}
		guiState.onAction.animation_cancel = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system        = getCurrentProjectAndSystem()
			project.edited               = savedEdited
			system.frames                = savedFrames
			system.psParticleLifetimeMin = savedLifetimeMin
			system.psParticleLifetimeMax = savedLifetimeMax

			updateParticleAnimation(system)
			updateParticleParams(project, system)
			popPanel()
			guiState.refreshRecursively!("particleLifetimeMin")
			guiState.refreshRecursively!("particleLifetimeMax")
			guiState.refreshRecursively!("projects") -- For the modification indicator.
			updateWindowTitle()
		}

		guiState.onDraw.animation_preview = (canvasEl:gui.Canvas, cw,ch:int) {
			local PADDING :: 5
			local project, system = getCurrentProjectAndSystem()
			local image           = system.currentImage.image
			local iw, ih          = image.getDimensions!()

			local r, g, b = hsvToRgb(project.bgColor)
			LG.clear(r, g, b)

			if system.frames {
				local quads                             = system.particles.getQuads!()
				local quad, progress, progressInSeconds = getAnimationPreviewQuad(system.particles, quads)
				local _, _, qw, qh                      = quads[1].getViewport!()

				local w = math.round(qw)
				local h = math.round(qh)

				local scale = math.min((cw-2*PADDING)/w, (ch-2*PADDING)/h)

				local x = (cw - w*scale) // 2
				local y = (ch - h*scale) // 2

				LG.draw(image, quad, x, y, 0, scale)

				local progressW = math.round((cw-2)*progress)
				LG.setColor(1, 1, 1, .2)
				LG.rectangle(LG.DrawMode.FILL, 1, 1, progressW, 1)
				LG.rectangle(LG.DrawMode.FILL, 1+progressW-1, 1, 1, 1)

				LG.setColor(1, 1, 1, gui.TEXT_OPACITY)
				LG.print(format("%.3f", progressInSeconds), 3, 3)

			} else {
				local scale = math.min((cw-2*PADDING)/iw, (ch-2*PADDING)/ih)

				local x = (cw - iw*scale) // 2
				local y = (ch - ih*scale) // 2

				LG.draw(image, x, y, 0, scale)
			}
		}

		guiState.onRefresh.animation_particleLifetimeMin = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.value          = system.psParticleLifetimeMin
		}
		guiState.onAction.animation_particleLifetimeMin = (slider:gui.Slider, _:int, source:gui.ActionSource) {
			local project, system        = getCurrentProjectAndSystem()
			system.psParticleLifetimeMin = slider.value
			updateParticleParams(project, system)
		}
		guiState.onRefresh.animation_particleLifetimeMax = (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.value          = system.psParticleLifetimeMax
		}
		guiState.onAction.animation_particleLifetimeMax = (slider:gui.Slider, _:int, source:gui.ActionSource) {
			local project, system        = getCurrentProjectAndSystem()
			system.psParticleLifetimeMax = slider.value
			updateParticleParams(project, system)
		}

		guiState.onAction.animation_empty = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			if not system.frames  return

			system.frames = {}

			markEdited(project)
			guiState.refreshRecursively!("animation_frames")
			updateParticleAnimation(system)
		}

		local parseTwoInts :: (s:string) -> bool, int, int {
			s = trim(s)

			local ok, xStr, yStr = matchPattern(s, "^(%-?%d+) +(%-?%d+)$")
			if not ok  return false, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)

			return true, x, y
		}

		local parseFourInts :: (s:string) -> bool, int, int, int, int {
			s = trim(s)

			local ok, xStr, yStr, zStr, wStr = matchPattern(s, "^(%-?%d+) +(%-?%d+) +(%-?%d+) +(%-?%d+)$")
			if not ok  return false, 0, 0, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)
			local _, z = stringToInt(cast(string) zStr)
			local _, w = stringToInt(cast(string) wStr)

			return true, x, y, z, w
		}

		local parseOneOrTwoInts :: (s:string) -> bool, int, int {
			s = trim(s)

			local        ok, xStr, yStr = matchPattern(s, "^(%-?%d+) +(%-?%d+)$")
			if not ok  { ok, xStr       = matchPattern(s, "^%-?%d+$") ; yStr = xStr }
			if not ok  return false, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)

			return true, x, y
		}

		guiState.onAction.animation_sequence_generateFromSize = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local iw, ih          = system.currentImage.image.getDimensions!()

			local areaPosStr   = trim(guiState.getElement!("animation_sequence_areaPosition", gui.InputText).value)
			local areaSizeStr  = trim(guiState.getElement!("animation_sequence_areaSize",     gui.InputText).value)
			local paddingStr   = trim(guiState.getElement!("animation_sequence_framePadding", gui.InputText).value)
			local spacingStr   = trim(guiState.getElement!("animation_sequence_frameSpacing", gui.InputText).value)
			local frameSizeStr = trim(guiState.getElement!("animation_sequence_frameSize",    gui.InputText).value)

			local ok, areaX, areaY = parseTwoInts(areaPosStr)
			if not ok { setErrorText("Invalid area position format") ; return }
			if areaX < 0  areaX += iw
			if areaY < 0  areaY += ih

			local ^ok, areaW, areaH = parseOneOrTwoInts(areaSizeStr)
			if not ok { setErrorText("Invalid area size format") ; return }
			if areaW <= 0  areaW += iw-areaX
			if areaH <= 0  areaH += ih-areaY

			local ^ok, padX, padY = parseOneOrTwoInts(paddingStr)
			if not ok { setErrorText("Invalid padding format") ; return }

			local ^ok, spacingX, spacingY = parseOneOrTwoInts(spacingStr)
			if not ok { setErrorText("Invalid spacing format") ; return }

			local ^ok, frameW, frameH = parseOneOrTwoInts(frameSizeStr)
			if not ok { setErrorText("Invalid frame size format") ; return }

			if frameW == 0  frameW = iw
			if frameH == 0  frameH = ih
			if not (frameW > 0 and frameH > 0) { setErrorText("Frame size must be positive") ; return }

			local paddedW = frameW + 2*padX
			local paddedH = frameH + 2*padY
			local cols    = (areaW + spacingX) // (paddedW + spacingX)
			local rows    = (areaH + spacingY) // (paddedH + spacingY)

			local frameCount = cols * rows
			if frameCount < 1 { setErrorText("Animation frame count results in zero") ; return }

			setMessageText("")
			system.frames = {}

			for row = 1, rows {
				for col = 1, cols {
					local x = areaX + (col-1) * (paddedW + spacingX) + padX
					local y = areaY + (row-1) * (paddedH + spacingY) + padY

					local animFrame: AnimationFrame = {x=x, y=y, w=frameW, h=frameH}
					insert(system.frames, animFrame)
				}
			}

			for GUI_VALUE_ELEMENTS {
				local input = guiState.getElement!(it, gui.InputText)
				setGuiValue(system, it, input.value)
			}

			markEdited(project)
			updateParticleAnimation(system)
			guiState.refreshRecursively!("animation_frames")
		}

		guiState.onAction.animation_sequence_generateFromDivision = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local iw, ih          = system.currentImage.image.getDimensions!()

			local areaPosStr   = trim(guiState.getElement!("animation_sequence_areaPosition", gui.InputText).value)
			local areaSizeStr  = trim(guiState.getElement!("animation_sequence_areaSize",     gui.InputText).value)
			local paddingStr   = trim(guiState.getElement!("animation_sequence_framePadding", gui.InputText).value)
			local spacingStr   = trim(guiState.getElement!("animation_sequence_frameSpacing", gui.InputText).value)
			local rowsStr      = trim(guiState.getElement!("animation_sequence_rows",         gui.InputText).value)
			local colsStr      = trim(guiState.getElement!("animation_sequence_columns",      gui.InputText).value)

			local ok, areaX, areaY = parseTwoInts(areaPosStr)
			if not ok { setErrorText("Invalid area position format") ; return }
			if areaX < 0  areaX += iw
			if areaY < 0  areaY += ih

			local ^ok, areaW, areaH = parseOneOrTwoInts(areaSizeStr)
			if not ok { setErrorText("Invalid area size format") ; return }
			if areaW <= 0  areaW += iw-areaX
			if areaH <= 0  areaH += ih-areaY

			local ^ok, padX, padY = parseOneOrTwoInts(paddingStr)
			if not ok { setErrorText("Invalid padding format") ; return }

			local ^ok, spacingX, spacingY = parseOneOrTwoInts(spacingStr)
			if not ok { setErrorText("Invalid spacing format") ; return }

			local ^ok, rows = stringToInt(rowsStr)
			if not ok   { setErrorText("Invalid row count format") ; return }
			if rows < 1 { setErrorText("Row count must be positive") ; return }

			local ^ok, cols = stringToInt(colsStr)
			if not ok   { setErrorText("Invalid column count format") ; return }
			if cols < 1 { setErrorText("Column count must be positive") ; return }

			local unitW   = (areaW + spacingX) // cols
			local unitH   = (areaH + spacingY) // rows
			local paddedW = unitW - spacingX
			local paddedH = unitH - spacingY
			local frameW  = paddedW - 2*padX
			local frameH  = paddedH - 2*padY

			if frameW < 1 or frameH < 1 { setErrorText("Animation frame size results in zero") ; return }

			setMessageText("")
			system.frames = {}

			for row = 1, rows {
				for col = 1, cols {
					local x = areaX + (col-1) * (paddedW + spacingX) + padX
					local y = areaY + (row-1) * (paddedH + spacingY) + padY

					local animFrame: AnimationFrame = {x=x, y=y, w=frameW, h=frameH}
					insert(system.frames, animFrame)
				}
			}

			for GUI_VALUE_ELEMENTS {
				local input = guiState.getElement!(it, gui.InputText)
				setGuiValue(system, it, input.value)
			}

			markEdited(project)
			updateParticleAnimation(system)
			guiState.refreshRecursively!("animation_frames")
		}

		guiState.onRefresh.animation_frames = (vbox:gui.Vbox) {
			local project, system = getCurrentProjectAndSystem()

			for < vbox  guiState.delete!(it, updateInteractions=false)

			for system.frames {
				local inputValue = format("%s %s %s %s", it.x, it.y, it.w, it.h)

				insert(vbox, guiState.hbox!({ name="animation_frame", data=itIndex, labelLeft=format("#%d", itIndex),
					guiState.buttons!({ buttons={
						{name="animation_delete", image="iconDelete", tooltip="Remove frame"},
						{name="animation_add",    image="iconAdd",    tooltip="Add/duplicate frame"},
						{name="animation_move",   image="iconMoveV",  tooltip="Move frame (drag)", draggable=true},
					} }),
					guiState.inputText!({ name="animation_xywh", weight=1, value=inputValue, tooltip="Format: [x y width height]" }),
					guiState.text!({ name=format("animation_message%d", itIndex), width=50 }),
				}))
			}
		}

		local getAnimationFrame :: (el:gui.Element) -> AnimationFrame, int {
			local project, system = getCurrentProjectAndSystem()
			local _, parent       = guiState.findParent!(el, "animation_frame")
			local i               = cast(int) parent.data

			return system.frames[i], i
		}
		guiState.onAction.animation_delete = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(buttons)

			remove(system.frames, i)

			markEdited(project)
			updateParticleAnimation(system)
			guiState.refreshRecursively!("animation_frames")
		}
		guiState.onAction.animation_add = (buttons:gui.Buttons, buttonIndex:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(buttons)

			local animFrameNew: AnimationFrame = {
				x = animFrame.x,
				y = animFrame.y,
				w = animFrame.w,
				h = animFrame.h,
			}
			insert(system.frames, i+1, animFrameNew)

			markEdited(project)
			updateParticleAnimation(system)
			guiState.refreshRecursively!("animation_frames")
		}
		guiState.onAction.animation_xywh = (input:gui.InputText, _:int, source:gui.ActionSource) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(input)

			local ok, x, y, w, h = parseFourInts(input.value)
			if not ok {
				setErrorText("Invalid frame values format")
				guiState.getElement!(format("animation_message%d", i), gui.Text).text = "Error!"
				return
			}

			animFrame.x = x
			animFrame.y = y
			animFrame.w = w
			animFrame.h = h

			markEdited(project)
			updateParticleAnimation(system)
			guiState.getElement!(format("animation_message%d", i), gui.Text).text = ""
		}
		guiState.onDrag.animation_move = (buttons:gui.Buttons, buttonIndex:int, mx,my:int) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(buttons)

			local dragContainer = guiState.getElement!("animation_frames", gui.Vbox)

			local frames      = system.frames
			local targetIndex = math.clamp(math.floor(1 + (my - (dragContainer.layoutY + guiState.getScrollOffset!(dragContainer))) / (dragContainer[1].layoutHeight + gui.SPACING)), 1, #frames)
			if targetIndex == i  return

			local dir = math.getSign(targetIndex-i)

			for j = i, targetIndex-dir, dir {
				frames[j], frames[j+dir] = frames[j+dir], frames[j]
			}

			markEdited(project)
			updateParticleAnimation(system)
			guiState.refreshRecursively!(dragContainer)

			guiState.activeId  = dragContainer[targetIndex][1].id -- Must happen after refreshRecursively() as all elements are replaced! @Volatile
			guiState.hoveredId = guiState.activeId
		}
	}

	--==============================================================
	--= Preferences
	--==============================================================

	guiState.onActive.preferences = (frame:gui.Frame) {
		guiState.refreshRecursively!(frame)
	}

	guiState.onRefresh.preferences_preferRelativePaths = (checkbox:gui.Checkbox) {
		checkbox.checked = app.preferRelativePaths
	}
	guiState.onAction.preferences_preferRelativePaths = (checkbox:gui.Checkbox, _:int, source:gui.ActionSource) {
		app.preferRelativePaths = checkbox.checked
		scheduleSaveWorkspace()
	}

	guiState.onRefresh.preferences_maxBufferSize = (input:gui.InputText) {
		input.value = format("%.0f", app.maxBufferSize)
	}
	guiState.onAction.preferences_maxBufferSize = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n                 = math.clamp(n, 1000, 2^52)
		app.maxBufferSize = n
		input.value       = format("%.0f", n)
		scheduleSaveWorkspace()

		for project: app.projects {
			for project.systems  updateBufferSize(it)
		}
	}

	guiState.onRefresh.preferences_maxRecentFiles = (input:gui.InputText) {
		input.value = format("%.0f", app.maxRecentFiles)
	}
	guiState.onAction.preferences_maxRecentFiles = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n                  = math.clamp(n, 0, 100)
		app.maxRecentFiles = n
		input.value        = format("%.0f", n)
		scheduleSaveWorkspace()
	}
	--[[
	guiState.onRefresh.preferences_maxRecentFolders = (input:gui.InputText) {
		input.value = format("%.0f", app.maxRecentFiles)
	}
	guiState.onAction.preferences_maxRecentFolders = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n                  = math.clamp(n, 0, 20)
		app.maxRecentFiles = n
		input.value        = format("%.0f", n)
		scheduleSaveWorkspace()
	}
	--]]

	guiState.onRefresh.preferences_maxChanges = (input:gui.InputText) {
		input.value = format("%.0f", app.maxChanges)
	}
	guiState.onAction.preferences_maxChanges = (input:gui.InputText, _:int, source:gui.ActionSource) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n              = math.clamp(n, 1, 2^52)
		app.maxChanges = n
		input.value    = format("%.0f", n)
		scheduleSaveWorkspace()
	}

	guiState.onRefresh.preferences_initializeSystemInNewProjects = (checkbox:gui.Checkbox) {
		checkbox.checked = app.initializeSystemInNewProjects
	}
	guiState.onAction.preferences_initializeSystemInNewProjects = (checkbox:gui.Checkbox, _:int, source:gui.ActionSource) {
		app.initializeSystemInNewProjects = checkbox.checked
		scheduleSaveWorkspace()
	}

	--==============================================================
	--= Log
	--==============================================================

	guiState.onActive.log = (frame:gui.Frame) {
		guiState.refreshRecursively!(frame)
	}

	guiState.onRefresh.log_text = (textEl:gui.Text) {
		local s          = concatinate(logStrings, "\n")
		local _, lines   = fontNormal.getWrap!(s, DIALOG_WIDTH_LOG-20) -- @Ugly?
		textEl.textLines = lines
	}

	--==============================================================
	--= Utils
	--==============================================================

	guiState.onAction.util_pushPanel = (el:gui.Element, _:int, source:gui.ActionSource) {
		pushPanel(cast(string) el.data)
	}
	guiState.onAction.util_popPanel = (el:gui.Element, _:int, source:gui.ActionSource) {
		popPanel()
	}
}


