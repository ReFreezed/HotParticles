--[[============================================================
--=
--=  GUI setup
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

local BIG_BUTTON_HEIGHT    :: 40
local MEDIUM_BUTTON_HEIGHT :: 16

local EXPORT_TEMPLATES_DIRECTORY :: "exportTemplates"



export setupGuiFrames :: () {
	guiState.frames = {
		guiState.frame!({ name="main", width=MAIN_PANEL_WIDTH,
			guiState.hbox!({
				guiState.buttons!({ name="buttonsWithSettingsButton", buttons={{name="menu",label="File"},{name="toggleProjectSettings",label="Project",tooltip="Toggle project settings"}} }),
				guiState.buttons!({ buttons={{name="undo",image="iconLeft",tooltip="Undo  (Ctrl+Z)"},{name="redo",image="iconRight",tooltip="Redo  (Ctrl+Shift+Z)"}} }),
				guiState.text!({ name="undoRedoText", text="0/0", size=1 }),
			}),
			guiState.separator!({ thick=true }),

			guiState.tabs!({ name="projects", specialLastTab=true }),
			guiState.text!({ height=1 }), -- Spacer.

			guiState.vbox!({ name="projectSettings",
				guiState.section!({ label="Pixelate",
					guiState.hbox!({
						guiState.checkbox!({ name="pixelateWorld",    label="world"    }),
						guiState.checkbox!({ name="pixelateTextures", label="textures" }),
					}),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ name="backgroundSection", label="Background", icon16="background",
					guiState.hbox!({
						guiState.color!({ name="bgColor", alpha=false, weight=1 }),
						guiState.colorPreview!({ linkColors={"bgColor"} }),
					}),
					guiState.slider!({ name="bgChecker", labelLeft="pattern", min=-1, max=1, exponential=true, readoutMulti=100, readout="%d%%" }),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ name="emitterMovementSection", label="EmitterMovem.", icon16="movement",
					guiState.radio!({ name="emitterMovement",
						buttons = {
							{value=Movement.NONE,      label="none",      tooltip="No movement"},
							{value=Movement.CIRCLE,    label="circle",    tooltip="Circle, or back and forth"},
							{value=Movement.EIGHT,     label="eight",     tooltip="Numeral eight, on the side"},
							{value=Movement.IRREGULAR, label="irregular", tooltip="Irregular movement"},
						}
					}),
					guiState.hbox!({
						guiState.vbox!({ weight=1,
							guiState.slider!({ name="emitterMovementSx", labelLeft="scale x", min=0, max=2, limitName="emitterMovementScale", readoutMulti=100, readout="%d%%", linkMultiDrag={"emitterMovementSy"} }),
							guiState.slider!({ name="emitterMovementSy", labelLeft="scale y", min=0, max=2, limitName="emitterMovementScale", readoutMulti=100, readout="%d%%", linkMultiDrag={"emitterMovementSx"} }),
						}),
						guiState.slider!({ name="emitterMovementSpeed", labelLeft="speed", inset=40, min=-8, max=8, limitName="emitterMovementSpeed", readoutMulti=100, readout="%d%%", weight=1.5 }),
					}),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ name="scaleGlobalSection", label="GlobalScale", icon16="scale",
					guiState.slider!({ name="scaleGlobalTime",  labelLeft="time",  min=0, max=4, exponential=true, limitName="scaleGlobalTime",  readoutMulti=100, readout="%d%%" }),
					guiState.slider!({ name="scaleGlobalSpace", labelLeft="space", min=0, max=4, exponential=true, limitName="scaleGlobalSpace", readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleGlobalSize"} }),
					guiState.slider!({ name="scaleGlobalSize",  labelLeft="size",  min=0, max=4, exponential=true, limitName="scaleGlobalSize",  readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleGlobalSpace"} }),
				}),

				guiState.separator!({ thick=true }),
			}),

			guiState.vbox!({ name="system",
				guiState.tabs!({ name="systems", specialLastTab=true }),

				guiState.scrollable!({
					guiState.section!({ name="textureSection", label="Texture", icon16="texture",
						guiState.radio!({ name="textureName", labelLeft="preset" }),
						guiState.hbox!({
							guiState.inputText!({ name="texturePath", labelLeft="path", tooltip="Absolute path, or relative to the saved .hotparticles file", weight=1 }),
							guiState.buttons!({ name="reloadTexture", buttons={{image="iconReload",tooltip="Reload texture"}} }),
						}),
						guiState.hbox!({
							guiState.slider!({ name="textureOffsetX", value=.5, min=0, max=1, limitName="textureOffset", limitCenter=.5, readoutMulti=100, readout="%d%%", weight=1, labelLeft="offset x/y" }),
							guiState.slider!({ name="textureOffsetY", value=.5, min=0, max=1, limitName="textureOffset", limitCenter=.5, readoutMulti=100, readout="%d%%", weight=1 }),
							guiState.buttons!({ name="util_pushPanel", data="animation", buttons={{label="Animation",tooltip="Create/edit particle animation"}} }),
						}),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="scaleAllSection", label="ScaleAll", icon16="scale",
						guiState.slider!({ name="scaleTime",  labelLeft="time",  min=0, max=4, exponential=true, limitName="scaleTime",  readoutMulti=100, readout="%d%%" }),
						guiState.slider!({ name="scaleSpace", labelLeft="space", min=0, max=4, exponential=true, limitName="scaleSpace", readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleSize"} }),
						guiState.slider!({ name="scaleSize",  labelLeft="size",  min=0, max=4, exponential=true, limitName="scaleSize",  readoutMulti=100, readout="%d%%", linkMultiDrag={"scaleSpace"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="spawnSection", label="Spawn", icon16="spawn",
						guiState.radio!({ name="insertMode", labelLeft="layer", buttons={
							{value=LG.ParticleInsertMode.TOP,    label="front",  tooltip="Insert at top"},
							{value=LG.ParticleInsertMode.BOTTOM, label="back",   tooltip="Insert at bottom"},
							{value=LG.ParticleInsertMode.RANDOM, label="random", tooltip="Insert randomly"},
						}}),
						guiState.slider!({ name="emissionRate",   labelLeft="rate",             min=0, max=512,  exponential=true,             limitName="emissionRate",   readout="%.1f / sec" }),
						guiState.slider!({ name="kickStartEmit",  labelLeft="emit at start",    min=0, max=1024, exponential=true, isInt=true, limitName="kickStartEmit",  readout="%.0f" }),
						guiState.slider!({ name="kickStartSteps", labelLeft="kick-start steps", min=0, max=128,  exponential=true, isInt=true, limitName="kickStartSteps", readout="%.0f", readoutZero="no kick-start" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="lifetimeSection", label="Lifetime", icon16="time",
						guiState.hbox!({ labelLeft="emitter",
							guiState.slider!({ name="emitterLifetime", min=0, max=16, exponential=true, limitName="emitterLifetime", readout="%.2f sec"--[[, readoutZero="∞"]], weight=1 }),
							guiState.checkbox!({ name="emitterContinuous", label="continuous", tooltip="Infinite lifetime" }),
						}),
						guiState.slider!({ name="particleLifetimeMin", labelLeft="particle min", min=0, max=16, exponential=true, limitName="particleLifetime", readout="%.2f sec", linkMultiDrag={"particleLifetimeMax"} }),
						guiState.slider!({ name="particleLifetimeMax", labelLeft="particle max", min=0, max=16, exponential=true, limitName="particleLifetime", readout="%.2f sec", linkMultiDrag={"particleLifetimeMin"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="areaSection", label="Area", icon16="areaSize",
						guiState.radio!({ name="areaDistribution", labelLeft="distribution", buttons={
							{value=LG.AreaSpreadDistribution.NONE,             label="none",    tooltip="None"},
							{value=LG.AreaSpreadDistribution.ELLIPSE,          label="ellip",   tooltip="Ellipse"},
							{value=LG.AreaSpreadDistribution.UNIFORM,          label="rect",    tooltip="Rectangle/uniform"},
							{value=LG.AreaSpreadDistribution.BORDER_ELLIPSE,   label="b.ellip", tooltip="Border ellipse"},
							{value=LG.AreaSpreadDistribution.BORDER_RECTANGLE, label="b.rect",  tooltip="Border rectangle"},
							{value=LG.AreaSpreadDistribution.NORMAL,           label="norm",    tooltip="Normal distribution"},
						}}),
						guiState.hbox!({ name="areaParams", active=false,
							guiState.direction!({ name="areaAngle", labelLeft="angle" }),
							guiState.vbox!({ weight=1,
								guiState.slider!({ name="areaDx", labelLeft="dx", inset=30, min=0, max=1000, exponential=true, limitName="areaSize", readout="%.0f", linkMultiDrag={"areaDy"} }),
								guiState.slider!({ name="areaDy", labelLeft="dy", inset=30, min=0, max=1000, exponential=true, limitName="areaSize", readout="%.0f", linkMultiDrag={"areaDx"} }),
								guiState.checkbox!({ name="areaRelative", label="direction relative to area center", inset=14, weight=1 }),
							}),
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="directionSection", label="Direction", icon16="direction",
						guiState.hbox!({
							guiState.direction!({ name="direction", linkSpread="directionSpread" }),
							guiState.slider!({ name="directionSpread", labelLeft="spread", min=0, max=math.TAU, readoutMulti=360/math.TAU, readout="%d°", weight=1, inset=50 }),
						}),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="speedSection", label="Speed", icon16="speed",
						guiState.slider!({ name="speedMin", labelLeft="min", min=-2000, max=2000, exponential=true, limitName="speed", readout="%.0f / sec", linkMultiDrag={"speedMax"} }),
						guiState.slider!({ name="speedMax", labelLeft="max", min=-2000, max=2000, exponential=true, limitName="speed", readout="%.0f / sec", linkMultiDrag={"speedMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="accelerationLinearSection", label="AccLinear", icon16="accelerationLinear",
						guiState.slider!({ name="accLinearXmin", labelLeft="xmin", min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearXmax"} }),
						guiState.slider!({ name="accLinearXmax", labelLeft="xmax", min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearXmin"} }),
						guiState.slider!({ name="accLinearYmin", labelLeft="ymin", min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearYmax"} }),
						guiState.slider!({ name="accLinearYmax", labelLeft="ymax", min=-5000, max=5000, exponential=true, limitName="accLinear", readout="%.0f / sec²", linkMultiDrag={"accLinearYmin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="accelerationRadialSection", label="AccRadial", icon16="accelerationRadial",
						guiState.slider!({ name="radialAccelerationMin", labelLeft="min", min=-10000, max=10000, exponential=true, limitName="radialAcceleration", readout="%.0f / sec²", linkMultiDrag={"radialAccelerationMax"} }),
						guiState.slider!({ name="radialAccelerationMax", labelLeft="max", min=-10000, max=10000, exponential=true, limitName="radialAcceleration", readout="%.0f / sec²", linkMultiDrag={"radialAccelerationMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="accelerationTangentSection", label="AccTangent", icon16="accelerationTangent",
						guiState.slider!({ name="tangentialAccelerationMin", labelLeft="min", min=-10000, max=10000, exponential=true, limitName="tangentialAcceleration", readout="%.0f / sec²", linkMultiDrag={"tangentialAccelerationMax"} }),
						guiState.slider!({ name="tangentialAccelerationMax", labelLeft="max", min=-10000, max=10000, exponential=true, limitName="tangentialAcceleration", readout="%.0f / sec²", linkMultiDrag={"tangentialAccelerationMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="dampingSection", label="Damping", icon16="damping",
						guiState.slider!({ name="linearDampingMin", labelLeft="min", min=-20, max=20, exponential=true, limitName="linearDamping", readout="%.2f", linkMultiDrag={"linearDampingMax"} }),
						guiState.slider!({ name="linearDampingMax", labelLeft="max", min=-20, max=20, exponential=true, limitName="linearDamping", readout="%.2f", linkMultiDrag={"linearDampingMin"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="rotationSection", label="Rotation", icon16="rotation",
						guiState.hbox!({
							guiState.direction!({ name="rotationMin", linkOther="rotationMax", linkMultiDrag={"rotationMax"}, labelLeft="min/max" }),
							guiState.direction!({ name="rotationMax", linkOther="rotationMin", linkMultiDrag={"rotationMin"}, }),
							guiState.checkbox!({ name="rotationRelative", label="rotation relative to direction", inset=10 }),
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ name="spinSection", label="Spin", icon16="spin",
						guiState.slider!({ name="spinMin", labelLeft="at start", min=-8*math.TAU, max=8*math.TAU, exponential=true, limitName="spin", readoutMulti=1/math.TAU, readout="%.2f turns / sec", linkMultiDrag={"spinMax"} }),
						guiState.slider!({ name="spinMax", labelLeft="at end",   min=-8*math.TAU, max=8*math.TAU, exponential=true, limitName="spin", readoutMulti=1/math.TAU, readout="%.2f turns / sec", linkMultiDrag={"spinMin"} }),
						guiState.slider!({ name="spinVariation", labelLeft="variation", min=0, max=1, readoutMulti=100, readout="%d%%" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="sizesSection", label="Size", icon16="size",
						guiState.hbox!({ name="sizeContainer1", data=1, labelLeft="#1",
							guiState.buttons!({ data=1, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size1", data=1, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer2", data=2, labelLeft="#2", active=false,
							guiState.buttons!({ data=2, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size2", data=2, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer3", data=3, labelLeft="#3", active=false,
							guiState.buttons!({ data=3, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size3", data=3, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer4", data=4, labelLeft="#4", active=false,
							guiState.buttons!({ data=4, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size4", data=4, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer5", data=5, labelLeft="#5", active=false,
							guiState.buttons!({ data=5, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size5", data=5, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer6", data=6, labelLeft="#6", active=false,
							guiState.buttons!({ data=6, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size6", data=6, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer7", data=7, labelLeft="#7", active=false,
							guiState.buttons!({ data=7, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size7", data=7, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer8", data=8, labelLeft="#8", active=false,
							guiState.buttons!({ data=8, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size8", data=8, min=0, max=8, exponential=true, limitName="size", readout="%.2f", weight=1 }),
						}),
						guiState.slider!({ name="sizeVariation", labelLeft="variation", min=0, max=1, readoutMulti=100, readout="%d%%" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="colorSection", label="Color", icon16="brush",
						guiState.hbox!({
							guiState.vbox!({ name="colors", weight=1,
								guiState.hbox!({ name="colorContainer1", labelLeft="#1",
									guiState.buttons!({ data=1, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=1, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color1", data=1, weight=1, linkMultiDrag={"color2","color3","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer2", labelLeft="#2", active=false,
									guiState.buttons!({ data=2, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=2, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color2", data=2, weight=1, linkMultiDrag={"color1","color3","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer3", labelLeft="#3", active=false,
									guiState.buttons!({ data=3, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=3, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color3", data=3, weight=1, linkMultiDrag={"color1","color2","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer4", labelLeft="#4", active=false,
									guiState.buttons!({ data=4, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=4, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color4", data=4, weight=1, linkMultiDrag={"color1","color2","color3","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer5", labelLeft="#5", active=false,
									guiState.buttons!({ data=5, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=5, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color5", data=5, weight=1, linkMultiDrag={"color1","color2","color3","color4","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer6", labelLeft="#6", active=false,
									guiState.buttons!({ data=6, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=6, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color6", data=6, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer7", labelLeft="#7", active=false,
									guiState.buttons!({ data=7, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=7, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color7", data=7, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color6","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer8", labelLeft="#8", active=false,
									guiState.buttons!({ data=8, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=8, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color8", data=8, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color6","color7"} }),
								}),
							}),
							guiState.colorPreview!({ name="colorPreview", linkColors={"color1","color2","color3","color4","color5","color6","color7","color8"} }),
						}),
						guiState.radio!({ name="blendMode", labelLeft="blend mode",
							buttons = {
								{value=LG.BlendMode.ALPHA,    label="alpha"},
								{value=LG.BlendMode.ADD,      label="add"},
								{value=LG.BlendMode.SUBTRACT, label="subtract"},
								{value=LG.BlendMode.SCREEN,   label="screen"},
							},
						}),
					}),
				}),
			}),
		}),

		guiState.frame!({ name="openProject", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ text="Open", size=3 }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Recent", weight=1 }),
				guiState.buttons!({ name="openProject_clearRecent", buttons={{label="Clear",tooltip="Clear history"}} }),
			}),
			guiState.separator!({ thick=false }),
			guiState.buttons!({ name="openProject_recent", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Bookmarks", weight=1 }),
				guiState.buttons!({ name="openProject_addBookmark", buttons={{image="iconAdd",tooltip="Add current folder to bookmarks"}} }),
			}),
			guiState.scrollable!({ height=80,
				guiState.buttons!({ name="openProject_bookmarks", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="openProject_directory" }),
			guiState.scrollable!({
				guiState.buttons!({ name="openProject_items", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST, buttonMinHeight=MEDIUM_BUTTON_HEIGHT }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="openProject_filename" }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="openProject_open",label="Open"},{name="util_popPanel",label="Cancel"}},
			}),
		}),

		guiState.frame!({ name="saveProjectAs", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ text="Save as", size=3 }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Recent", weight=1 }),
				guiState.buttons!({ name="saveProjectAs_clearRecent", buttons={{label="Clear",tooltip="Clear history"}} }),
			}),
			guiState.separator!({ thick=false }),
			guiState.buttons!({ name="saveProjectAs_recent", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Bookmarks", weight=1 }),
				guiState.buttons!({ name="saveProjectAs_addBookmark", buttons={{image="iconAdd",tooltip="Add current folder to bookmarks"}} }),
			}),
			guiState.scrollable!({ height=80,
				guiState.buttons!({ name="saveProjectAs_bookmarks", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="saveProjectAs_directory" }),
			guiState.scrollable!({
				guiState.buttons!({ name="saveProjectAs_items", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST, buttonMinHeight=MEDIUM_BUTTON_HEIGHT }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="saveProjectAs_filename" }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="saveProjectAs_save",label="Save"},{name="util_popPanel",label="Cancel"}},
			}),
		}),

		guiState.frame!({ name="exportProject", width=DIALOG_WIDTH, modal=true, layout=gui.Layout.FLOATING, active=false,
			guiState.text!({ text="Export", size=3 }),

			guiState.separator!({ thick=false }),
			guiState.section!({ name="exportProject_baseDirectorySection", label="Base folder", icon16="folder",
				guiState.inputText!({ name="exportProject_baseDirectory", tooltip="Absolute path, or relative to the .hotparticles file" }),
				guiState.hbox!({ labelLeft="resulting path",
					guiState.text!({ name="exportProject_baseDirectoryResult", weight=1 }),
					guiState.buttons!({ name="exportProject_baseDirectoryResultInfo", buttons={{image="iconEye"}} }),
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ name="exportProject_particlesSection", label="Particles", icon16="particles",
				guiState.hbox!({
					guiState.checkbox!({ name="exportProject_particles_writeFile", label="export particle systems" }),
					guiState.checkbox!({ name="exportProject_particles_overwrite", label="overwrite existing", tooltip="Overwrite existing files without confirmation" }),
				}),
				guiState.inputText!({ name="exportProject_particles_path", labelLeft="output filename", tooltip="Absolute path, or relative to base folder" }),
				guiState.hbox!({ labelLeft="resulting path",
					guiState.text!({ name="exportProject_particles_pathResult", weight=1 }),
					guiState.buttons!({ name="exportProject_particles_pathResultInfo", buttons={{image="iconEye"}} }),
				}),
				guiState.buttons!({ name="exportProject_particles_template", labelLeft="template", vertical=true, align=gui.Alignment.LEFT, buttonMinHeight=MEDIUM_BUTTON_HEIGHT,
					buttons={{image="iconDown",label="defaultLuaModule"}},
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ name="exportProject_texturesSection", label="Textures", icon16="texture",
				guiState.hbox!({
					guiState.checkbox!({ name="exportProject_textures_copyFiles", label="copy texture files" }),
					guiState.checkbox!({ name="exportProject_textures_overwrite", label="overwrite existing", tooltip="Overwrite existing files without confirmation" }),
				}),
				guiState.inputText!({ name="exportProject_textures_directory", labelLeft="output folder", tooltip="Absolute path, or relative to base folder" }),
				guiState.hbox!({ labelLeft="resulting paths",
					guiState.text!({ name="exportProject_textures_pathResults", weight=1 }),
					guiState.buttons!({ name="exportProject_textures_pathResultsInfo", buttons={{image="iconEye"}} }),
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.section!({ name="exportProject_clipboardSection", label="Clipboard", icon16="clipboard",
				guiState.buttons!({ align=gui.Alignment.LEFT, buttonMinHeight=MEDIUM_BUTTON_HEIGHT, buttons={{name="exportProject_clipboard_export",label="Export to clipboard"}}}),
				guiState.buttons!({ name="exportProject_clipboard_template", labelLeft="template", align=gui.Alignment.LEFT, buttonMinHeight=MEDIUM_BUTTON_HEIGHT,
					buttons={{image="iconDown",label="defaultLuaClipboard"}},
				}),
			}),

			guiState.separator!({ thick=true }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="exportProject_exportFiles",label="Export files"},{name="util_popPanel",label="Close"}},
			}),
		}),

		guiState.frame!({ name="preferences", width=DIALOG_WIDTH, modal=true, layout=gui.Layout.FLOATING, active=false,
			guiState.text!({ text="Preferences", size=3 }),

			guiState.separator!({ thick=false }),
			guiState.section!({ label="Max buffer size",
				guiState.inputText!({ name="preferences_maxBufferSize", tooltip="Default: 16000" }),
			}),

			guiState.separator!({ thick=false }),
			guiState.section!({ label="Max recent",
				guiState.hbox!({
					guiState.inputText!({ name="preferences_maxRecentFiles",   labelLeft="files",   tooltip="Default: 15", weight=1}),
					guiState.inputText!({ name="preferences_maxRecentFolders", labelLeft="folders", tooltip="Default: 4",  weight=1, inset=45 }),
				}),
			}),

			guiState.separator!({ thick=false }),
			guiState.section!({ label="Undo history",
				guiState.inputText!({ name="preferences_maxChanges", tooltip="Default: 100" }),
			}),

			guiState.separator!({ thick=true }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT, buttons={{name="util_popPanel",label="Close"}} }),
		}),

		guiState.frame!({ name="animation", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ text="Animation", size=3 }),
			guiState.canvas!({ name="animation_preview", width=100, height=100 }),
			guiState.separator!({ thick=true }),
			guiState.buttons!({ buttons={{name="animation_empty",label="Remove all frames"}} }),
			guiState.separator!({ thick=true }),
			guiState.section!({ label="Sequence", icon16="sequence",
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_areaPosition", labelLeft="area x/y",  value="0 0", inset=15, weight=1, tooltip="Top/left corner of first frame. Negative means offset from bottom/right corner of texture. Format: [x y]" }),
					guiState.inputText!({ name="animation_sequence_areaSize",     labelLeft="area size", value="0 0", inset=50, weight=1, tooltip="Size of area containing frames. Non-positive means offset from bottom/right corner of texture. Format: [width height] or [size]" }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_framePadding", labelLeft="padding", value="0", inset=15, weight=1, tooltip="Padding around each frame. Format: [paddingX paddingY] or [padding]" }),
					guiState.inputText!({ name="animation_sequence_frameSpacing", labelLeft="spacing", value="0", inset=50, weight=1, tooltip="Space between frames. Format: [spacingX spacingY] or [spacing]" }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_frameSize", labelLeft="frame size", value="10 10", inset=15, weight=1, tooltip="Format: [width height] or [size]" }),
					guiState.buttons!({ width=200, buttons={{name="animation_sequence_generateFromSize",label="Generate using frame size"}} }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_rows",    labelLeft="rows",    value="1", inset=15, weight=1 }),
					guiState.inputText!({ name="animation_sequence_columns", labelLeft="columns", value="1", inset=50, weight=1 }),
					guiState.buttons!({ width=200, buttons={{name="animation_sequence_generateFromDivision",label="Generate using rows+columns"}} }),
				}),
			}),
			guiState.scrollable!({
				guiState.vbox!({ name="animation_frames", inset=25 }),
			}),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="util_popPanel",label="Close"}},
			}),
		}),
	}
}



export panelStack: []string

export pushPanel :: (name:string) {
	assert(not indexOf(panelStack, name))
	if not gui.setActive(guiState, name, true)  return

	insert(panelStack, name)
}

export pushTempChoiceDialog :: (title:string, text:string, buttonList:[]gui.Button, cb:(choice:int), submitIndex=0, extraContent:gui.Element=NULL) {
	static tempN = 0 ; tempN += 1

	local name        = format("temp%d", tempN)
	local nameButtons = name.."_buttons"

	local frame = guiState.frame!({ name=name, temp=true, layout=gui.Layout.FLOATING, modal=true, width=DIALOG_WIDTH, active=false })
	insert(guiState.frames, frame)

	if title {
		insert(frame, guiState.text!({ text=title, size=3 }))
		insert(frame, guiState.separator!({ thick=true }))
	}
	if text {
		insert(frame, guiState.text!({ text=text }))
		insert(frame, guiState.separator!({ thick=false }))
	}
	if extraContent ~= NULL {
		insert(frame, extraContent)
		insert(frame, guiState.separator!({ thick=false }))
	}
	insert(frame, guiState.buttons!({ name=nameButtons, height=BIG_BUTTON_HEIGHT, buttons={ unpack(buttonList) } }))

	local cleanUp = [name,nameButtons] () {
		guiState.onSubmit[name]        = NULL
		guiState.onAction[nameButtons] = NULL
		guiState.onInactive[name]      = NULL
	}

	if submitIndex {
		guiState.onSubmit[name] = [cb,cleanUp,submitIndex] (frame:gui.Frame) {
			cleanUp()
			popPanel()
			cb(submitIndex)
		}
	}
	guiState.onAction[nameButtons] = [cb,cleanUp] (buttons:gui.Buttons, choice:int) {
		cleanUp()
		popPanel()
		cb(choice)
	}
	guiState.onInactive[name] = [cb,cleanUp] (frame:gui.Frame) {
		cleanUp()
		cb(0)
	}

	pushPanel(name)
}

export popPanel :: (nameForAssert="") -> (success:bool) {
	local ok, name = remove(panelStack)
	if nameForAssert  assert(name == nameForAssert)
	if not ok  return false

	local frame = gui.getElement(guiState, name, gui.Frame)
	gui.setActive(guiState, frame, false)

	if frame.temp  gui.delete(guiState, frame)
	return true
}



export setupGuiCallbacks :: () {
	--==============================================================
	--= Main/project
	--==============================================================

	-- Tabs.
	guiState.onRefresh.projects = (tabs:gui.Tabs) {
		tabs.buttons = {}

		for app.projects {
			local label = (it.edited ? format("%s •", it.displayedName) : it.displayedName)
			insert(tabs.buttons, cast(gui.Button){ label=label, tooltip=it.path, draggable=true })
		}
		insert(tabs.buttons, cast(gui.Button){ image="iconAdd", tooltip="New project  (Ctrl+N)" })

		tabs.index = app.currentProjectIndex
	}
	guiState.onAction.projects = (tabs:gui.Tabs, buttonIndex:int) {
		if buttonIndex < #tabs.buttons {
			setCurrentProject(buttonIndex)
			return
		}

		local project = addNewProject()

		insert(tabs.buttons, #tabs.buttons, cast(gui.Button){ label=project.displayedName, draggable=true })
		guiState.layoutNeedsUpdate = true

		setCurrentProject(#app.projects)
	}
	guiState.onOption.projects = (tabs:gui.Tabs, projectIndex:int) {
		if projectIndex == #tabs.buttons  return

		gui.showContextMenu(guiState, {"Close\tCtrl+W","Duplicate"}, [projectIndex] (choice:int) {
			if choice == {
				case 1:
					confirmCloseProject(projectIndex)

				case 2:
					local project = app.projects[projectIndex].clone!()
					insert(app.projects, projectIndex+1, project)

					gui.refreshRecursively(guiState, "projects")
					setCurrentProject(projectIndex+1, force=true)
			}
		})
	}
	guiState.onClose.projects = (tabs:gui.Tabs, buttonIndex:int) {
		if buttonIndex < #tabs.buttons  confirmCloseProject(buttonIndex)
	}
	guiState.onDrag.projects = (tabs:gui.Tabs, buttonIndex:int, mx,my:int) {
		local targetIndex = math.clamp(math.floor(1 + (mx - tabs.layoutX) / tabs.buttonWidth), 1, #app.projects)
		if targetIndex == buttonIndex  return

		local isCurrent = (buttonIndex == app.currentProjectIndex)

		local _, project = remove(app.projects, buttonIndex)
		local _, button  = remove(tabs.buttons, buttonIndex)
		insert(app.projects, targetIndex, project)
		insert(tabs.buttons, targetIndex, button)

		if isCurrent
			app.currentProjectIndex = targetIndex
		elseif buttonIndex > app.currentProjectIndex and targetIndex <= app.currentProjectIndex
			app.currentProjectIndex += 1
		elseif buttonIndex < app.currentProjectIndex and targetIndex >= app.currentProjectIndex
			app.currentProjectIndex -= 1

		tabs.index = app.currentProjectIndex

		guiState.activeSubid  = targetIndex
		guiState.hoveredSubid = targetIndex
	}

	-- Menu.
	guiState.onRefresh.buttonsWithSettingsButton = (buttons:gui.Buttons) {
		local _, button = itemWith(buttons.buttons, "name", "toggleProjectSettings")
		button.image    = app.showProjectSettings ? "iconUp" : "iconDown"
		gui.setActive(guiState, "projectSettings", app.showProjectSettings)
	}
	guiState.onAction.menu = (buttons:gui.Buttons, buttonIndex:int) {
		local recentItems: []gui.MenuItem
		insert(recentItems, cast(gui.MenuItem) {name="openLast",label="Reopen closed file",shortcut="Ctrl+Shift+T"})
		insert(recentItems, cast(gui.MenuItem) {label="-"})

		if app.recentFiles {
			for app.recentFiles  insert(recentItems, cast(gui.MenuItem) {name="openRecent",data=it,label=it})
		} else {
			insert(recentItems, cast(gui.MenuItem) {label="(no recent files)"})
		}

		insert(recentItems, cast(gui.MenuItem) {label="-"})
		insert(recentItems, cast(gui.MenuItem) {name="clearRecent",label="Clear items"})

		local items: []gui.MenuItem = {
			{label="Open project...",     name="open",        shortcut="Ctrl+O"},
			{label="Open recent",         submenu=recentItems},
			{label="-"},
			{label="Save project",        name="save",        shortcut="Ctrl+S"},
			{label="Save new project...", name="saveAs",      shortcut="Ctrl+Shift+S"},
			{label="Export...",           name="export",      shortcut="Ctrl+E"},
			{label="-"},
			{label="Preferences",         name="preferences", shortcut="Ctrl+K"},
			{label="-"},
			{label="Exit",                name="exit",        shortcut="Ctrl+Q"},
		}

		gui.showMenu(guiState, buttons.layoutX, buttons.layoutY+buttons.layoutHeight, items, (choice:string, data:any) {
			local project = app.projects[app.currentProjectIndex]
			if choice == {
				case "open":        pushPanel("openProject")
				case "openLast":    openRecentProject()
				case "openRecent":  openProject(cast(string)data)
				case "clearRecent": app.recentFiles = {}
				case "save":        if project.fileIsSaved  saveProject(project, overwrite=true)  else  pushPanel("saveProjectAs")
				case "saveAs":      pushPanel("saveProjectAs")
				case "export":      pushPanel("exportProject")
				case "preferences": pushPanel("preferences")
				case "exit":        pushQuitEvent()
			}
		})
	}
	guiState.onAction.toggleProjectSettings = (buttons:gui.Buttons, buttonIndex:int) {
		app.showProjectSettings = not app.showProjectSettings
		local _, button         = itemWith(buttons.buttons, "name", "toggleProjectSettings")
		button.image            = app.showProjectSettings ? "iconUp" : "iconDown"
		gui.setActive(guiState, "projectSettings", app.showProjectSettings)
	}

	-- Undo/redo.
	guiState.onAction.undo = (buttons:gui.Buttons, buttonIndex:int) {
		undo()
	}
	guiState.onAction.redo = (buttons:gui.Buttons, buttonIndex:int) {
		redo()
	}
	guiState.onRefresh.undoRedoText = (textEl:gui.Text) {
		local project = app.projects[app.currentProjectIndex]

		if not project.changes {
			textEl.text = "0/0"
			return
		}

		local change        = project.changes[project.changeIndex-1] -- Note: changeIndex points at the next entry.
		local bundleCurrent = change ~= NULL ? change.bundle : -1

		local bundleCount = 0
		local bundleIndex = 0
		local lastBundle  = -1

		local labels: []string
		local labelsAdded: struct { !key:string, !value:bool }

		for project.changes {
			if it.bundle ~= lastBundle {
				bundleCount += 1
				lastBundle   = it.bundle
			}

			if it.bundle == bundleCurrent {
				bundleIndex = bundleCount

				if not labelsAdded[it.label] {
					labelsAdded[it.label] = true
					insert(labels, it.label)
				}
			}
		}

		textEl.text = format("%d/%d  %s", bundleIndex, bundleCount, concatinate(labels, ", "))
	}

	-- Project settings.
	local addEventHandlersForDirection :: (name:string, changeLabel:string, onUpdateValue:(project:Project, system:System, angle:float), finalize:(project:Project, system:System)=NULL) {
		guiState.onBegin[name] = (direction:gui.Direction, _:int) {
			direction.dataTemp = direction.angle
		}
		guiState.onAction[name] = [onUpdateValue] (direction:gui.Direction, _:int) {
			local project, system = getCurrentProjectAndSystem()
			onUpdateValue(project, system, direction.angle)
		}
		guiState.onEnd[name] = [name, changeLabel, onUpdateValue, finalize] (direction:gui.Direction, _:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(float) direction.dataTemp
			local valueNew        = direction.angle
			if valueNew == valueOld  return

			recordChange(changeLabel,
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueNew)  },
				[system, valueOld, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueOld)  },
				[system, name,     finalize]      (project:Project) {
					if gui.isElementVisible(guiState, name)  gui.refreshRecursively(guiState, name)
					if finalize ~= NULL  finalize(project, system)
				}
			)
		}
	}

	local addEventHandlersForSlider :: (name:string, changeLabel:string,
		onUpdateValue: (project:Project, system:System, value:float),
		finalize:      (project:Project, system:System) = NULL,
		onBegin:       (project:Project, system:System) = NULL,
		onEnd:         (project:Project, system:System) = NULL,
		forSystem = false
	) {
		guiState.onBegin[name] = [onBegin] (slider:gui.Slider, _:int) {
			slider.dataTemp = slider.value

			if onBegin ~= NULL {
				local project, system = getCurrentProjectAndSystem()
				onBegin(project, system)
			}
		}
		guiState.onAction[name] = [onUpdateValue] (slider:gui.Slider, _:int) {
			local project, system = getCurrentProjectAndSystem()
			onUpdateValue(project, system, slider.value)
		}
		guiState.onEnd[name] = [name, changeLabel, onUpdateValue, finalize, onEnd, forSystem] (slider:gui.Slider, _:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(float) slider.dataTemp
			local valueNew        = slider.value

			if valueNew ~= valueOld  recordChange(changeLabel,
				[system, valueNew, onUpdateValue  ] (project:Project) {  onUpdateValue(project, system, valueNew)  },
				[system, valueOld, onUpdateValue  ] (project:Project) {  onUpdateValue(project, system, valueOld)  },
				[system, name, finalize, forSystem] (project:Project) {
					if not (forSystem and not isSystemCurrent(system)) {
						if gui.isElementVisible(guiState, name)  gui.refreshRecursively(guiState, name)
					}
					if finalize ~= NULL  finalize(project, system)
				}
			)

			if onEnd ~= NULL  onEnd(project, system)
		}
	}

	local addEventHandlersForColor :: (name:string, changeLabel:string,
		onUpdateValue: (project:Project, system:System, component:int, value:float),
		finalize:      (project:Project, system:System) = NULL,
		onBegin:       (project:Project, system:System) = NULL,
		onEnd:         (project:Project, system:System) = NULL,
		forSystem = false
	) {
		guiState.onBegin[name] = [onBegin] (colorEl:gui.Color, component:int) {
			colorEl.dataTemp = colorEl.color[component]

			if onBegin ~= NULL {
				local project, system = getCurrentProjectAndSystem()
				onBegin(project, system)
			}
		}
		guiState.onAction[name] = [onUpdateValue] (colorEl:gui.Color, component:int) {
			local project, system = getCurrentProjectAndSystem()
			onUpdateValue(project, system, component, colorEl.color[component])
		}
		guiState.onEnd[name] = [name, changeLabel, onUpdateValue, finalize, onEnd, forSystem] (colorEl:gui.Color, component:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(float) colorEl.dataTemp
			local valueNew        = colorEl.color[component]

			if valueNew ~= valueOld  recordChange(changeLabel,
				[system, valueNew, component, onUpdateValue] (project:Project) {  onUpdateValue(project, system, component, valueNew)  },
				[system, valueOld, component, onUpdateValue] (project:Project) {  onUpdateValue(project, system, component, valueOld)  },
				[system, name, finalize, forSystem         ] (project:Project) {
					if not (forSystem and not isSystemCurrent(system)) {
						if gui.isElementVisible(guiState, name)  gui.refreshRecursively(guiState, name)
					}
					if finalize ~= NULL  finalize(project, system)
				}
			)

			if onEnd ~= NULL  onEnd(project, system)
		}
	}

	local addEventHandlersForRadio :: (name:string, $ValueType:Type, changeLabel:string, onUpdateValue:(project:Project, system:System, value:ValueType)) {
		guiState.onBegin[name] = (radio:gui.Radio, buttonIndex:int) {
			radio.dataTemp = radio.buttons[radio.index].value
		}
		guiState.onAction[name] = [name, changeLabel, onUpdateValue] (radio:gui.Radio, buttonIndex:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueOld        = cast(ValueType) radio.dataTemp
			local valueNew        = cast(ValueType) radio.buttons[buttonIndex].value
			if valueNew == valueOld  return

			recordChange(changeLabel,
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueNew)  },
				[system, valueOld, onUpdateValue] (project:Project) {  onUpdateValue(project, system, valueOld)  },
				[name                           ] (project:Project) {  if gui.isElementVisible(guiState, name)  gui.refreshRecursively(guiState, name)  }
			)
		}
	}

	local addEventHandlersForCheckbox :: (name:string, changeLabel:string, onUpdateValue:(project:Project, system:System, value:bool)) {
		guiState.onAction[name] = [name, changeLabel, onUpdateValue] (checkbox:gui.Checkbox, _:int) {
			local project, system = getCurrentProjectAndSystem()
			local valueNew        = checkbox.checked

			recordChange(changeLabel,
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system,     valueNew)  },
				[system, valueNew, onUpdateValue] (project:Project) {  onUpdateValue(project, system, not valueNew)  },
				[name                           ] (project:Project) {  if gui.isElementVisible(guiState, name)  gui.refreshRecursively(guiState, name)  }
			)
		}
	}

	guiState.onRefresh.pixelateWorld = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.pixelateWorld
	}
	addEventHandlersForCheckbox("pixelateWorld", "Toggled pixelate world",
		(project:Project, system:System, value:bool) {  project.pixelateWorld = value ; limitZoomLevel(project) ; scheduleRecreateCanvases = true  }
	)
	guiState.onRefresh.pixelateTextures = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.pixelateTextures
	}
	addEventHandlersForCheckbox("pixelateTextures", "Toggled pixelate textures",
		(project:Project, system:System, value:bool) {  project.pixelateTextures = value  }
	)

	guiState.onRefresh.bgColor = (colorEl:gui.Color) {
		local project    = app.projects[app.currentProjectIndex]
		colorEl.color[1] = project.bgColor[1]
		colorEl.color[2] = project.bgColor[2]
		colorEl.color[3] = project.bgColor[3]
	}
	addEventHandlersForColor("bgColor", "Changed background color",
		(project:Project, system:System, component:int, value:float) {  project.bgColor[component] = value  }
	)

	guiState.onRefresh.bgChecker = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.bgChecker
	}
	addEventHandlersForSlider("bgChecker", "Changed background color",
		(project:Project, system:System, value:float) {  project.bgChecker = value  }
	)

	guiState.onRefresh.emitterMovement = (radio:gui.Radio) {
		local project  = app.projects[app.currentProjectIndex]
		local found, i = indexWith(radio.buttons, "value", project.movementPreset)
		assert(found)
		radio.index = i
	}
	addEventHandlersForRadio("emitterMovement", Movement, "Changed emitter movement",
		(project:Project, system:System, value:Movement) {  project.movementPreset = value  }
	)
	guiState.onRefresh.emitterMovementSx = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.movementScaleX
	}
	addEventHandlersForSlider("emitterMovementSx", "Changed emitter movement scale x",
		(project:Project, system:System, value:float) {  project.movementScaleX = value  }
	)
	guiState.onRefresh.emitterMovementSy = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.movementScaleY
	}
	addEventHandlersForSlider("emitterMovementSy", "Changed emitter movement scale y",
		(project:Project, system:System, value:float) {  project.movementScaleY = value  }
	)
	guiState.onRefresh.emitterMovementSpeed = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.movementSpeed
	}
	addEventHandlersForSlider("emitterMovementSpeed", "Changed emitter movement speed",
		(project:Project, system:System, value:float) {  project.movementSpeed = value  }
	)

	-- Scale global.
	guiState.onRefresh.scaleGlobalTime = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.scaleGlobalTime
	}
	addEventHandlersForSlider("scaleGlobalTime", "Changed global time scale",
		(project:Project, system:System, value:float) {
			project.scaleGlobalTime = value
			for project.systems  updateParticleParams(project, it)
		}
	)

	guiState.onRefresh.scaleGlobalSpace = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.scaleGlobalSpace
	}
	addEventHandlersForSlider("scaleGlobalSpace", "Changed global space scale",
		(project:Project, system:System, value:float) {
			project.scaleGlobalSpace = value
			for project.systems  updateParticleParams(project, it)
		}
	)

	guiState.onRefresh.scaleGlobalSize = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.scaleGlobalSize
	}
	addEventHandlersForSlider("scaleGlobalSize", "Changed global size scale",
		(project:Project, system:System, value:float) {
			project.scaleGlobalSize = value
			for project.systems  updateParticleParams(project, it)
		}
	)

	-- Systems.
	guiState.onRefresh.systems = (tabs:gui.Tabs) {
		local project = app.projects[app.currentProjectIndex]
		tabs.buttons  = {}

		for project.systems {
			insert(tabs.buttons, cast(gui.Button){ system=it, draggable=true, tooltip=format("Particle system #%d (Ctrl+click to toggle)", itIndex) })
		}
		insert(tabs.buttons, cast(gui.Button){ image="iconAdd", tooltip="New particle system" })

		tabs.index = project.systemIndex
	}
	guiState.onBeforeAction.systems = (tabs:gui.Tabs, buttonIndex:int) -> (ignore:bool) {
		if buttonIndex == #tabs.buttons  return false
		if not LK.isDown(lctrl,rctrl)    return false

		local project                        = app.projects[app.currentProjectIndex]
		project.systems[buttonIndex].visible = not project.systems[buttonIndex].visible

		return true
	}
	guiState.onAction.systems = (tabs:gui.Tabs, buttonIndex:int) {
		local project = app.projects[app.currentProjectIndex]

		if buttonIndex < #tabs.buttons {
			setCurrentSystem(buttonIndex)
			return
		}

		local system = newSystem(project)

		recordChange("Added particle system",
			[system] (project:Project) {  insert(project.systems, system) ; setCurrentSystem(#project.systems)  },
			--[[  ]] (project:Project) {  remove(project.systems)         ; setCurrentSystem(math.min(project.systemIndex, #project.systems))  },
			--[[  ]] (project:Project) {  gui.refreshRecursively(guiState, "systems")  }
		)
	}
	guiState.onOption.systems = (tabs:gui.Tabs, systemIndex:int) {
		if systemIndex == #tabs.buttons  return

		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[systemIndex]

		gui.showContextMenuWithInput(guiState, system.title, inputTooltip="Particle system title", {"Delete\tCtrl+Delete","Duplicate\tCtrl+D"},
			[systemIndex] (choice:int) {
				if choice == {
					case 1: confirmDeleteSystem(systemIndex)
					case 2: duplicateSystem(systemIndex)
				}
			},
			[system] (valueNew:string) {
				local valueOld = system.title
				if valueNew == valueOld  return

				recordChange("Changed particle system title",
					[system, valueNew] (project:Project) {  system.title = valueNew  },
					[system, valueOld] (project:Project) {  system.title = valueOld  }
				)
			}
		)
	}
	guiState.onClose.systems = (tabs:gui.Tabs, buttonIndex:int) {
		if buttonIndex < #tabs.buttons  confirmDeleteSystem(buttonIndex)
	}
	guiState.onDragBegin.systems = (tabs:gui.Tabs, buttonIndex:int) {
		local project   = app.projects[app.currentProjectIndex]
		tabs.dataTemp   = project.systems
		project.systems = {unpack(project.systems)}
	}
	guiState.onDrag.systems = (tabs:gui.Tabs, buttonIndex:int, mx,my:int) {
		local project     = app.projects[app.currentProjectIndex]
		local targetIndex = math.clamp(math.floor(1 + (mx - tabs.layoutX) / tabs.buttonWidth), 1, #project.systems)
		if targetIndex == buttonIndex  return

		local isCurrent = (buttonIndex == project.systemIndex)

		local _, system = remove(project.systems, buttonIndex)
		local _, button = remove(tabs.buttons, buttonIndex)
		insert(project.systems, targetIndex, system)
		insert(tabs.buttons,    targetIndex, button)

		if isCurrent
			project.systemIndex = targetIndex
		elseif buttonIndex > project.systemIndex and targetIndex <= project.systemIndex
			project.systemIndex += 1
		elseif buttonIndex < project.systemIndex and targetIndex >= project.systemIndex
			project.systemIndex -= 1

		tabs.index = project.systemIndex

		guiState.activeSubid  = targetIndex
		guiState.hoveredSubid = targetIndex
	}
	guiState.onDragEnd.systems = (tabs:gui.Tabs, buttonIndex:int) {
		local project    = app.projects[app.currentProjectIndex]
		local systemsOld = cast([]System) tabs.dataTemp
		local systemsNew = project.systems
		local newOrder   = false

		for systemsNew {
			if it ~= systemsOld[itIndex] {
				newOrder = true
				break
			}
		}
		if not newOrder  return

		recordChange("Reordered particle systems",
			[systemsNew, systemsOld] (project:Project) {  _, project.systemIndex = indexOf(systemsNew, project.systems[project.systemIndex]) ; project.systems = systemsNew  },
			[systemsNew, systemsOld] (project:Project) {  _, project.systemIndex = indexOf(systemsOld, project.systems[project.systemIndex]) ; project.systems = systemsOld  },
			--[[                  ]] (project:Project) {  gui.refreshRecursively(guiState, "systems") ; setCurrentSystem(project.systemIndex, force=true)  }
		)
	}

	-- Texture.
	guiState.onRefresh.textureName = (radio:gui.Radio) {
		local project, system = getCurrentProjectAndSystem()
		radio.buttons         = {}

		for particleImageNames {
			insert(radio.buttons, cast(gui.Button){ value=it, tooltip=it, image=it })
		}

		local found, i = indexOf(particleImageNames, system.textureName)
		assert(found)
		radio.index = i
	}
	addEventHandlersForRadio("textureName", string, "Changed texture preset",
		(project:Project, system:System, value:string) {  system.textureName = value ; updateParticleTexture(project, system)  }
	)

	local setTexturePath :: (path:string) {
		local project, system = getCurrentProjectAndSystem()
		local valueOld        = system.texturePath
		local valueNew        = path

		if valueNew == valueOld  return

		recordChange("Changed texture path",
			[system, valueNew] (project:Project) {  system.texturePath = valueNew  },
			[system, valueOld] (project:Project) {  system.texturePath = valueOld  },
			[system          ] (project:Project) {  updateParticleTexture(project, system, saveRecent=true) ; gui.refreshRecursively(guiState, "texturePath")  }
		)
	}
	guiState.onRefresh.texturePath = (input:gui.InputText) {
		local project, system = getCurrentProjectAndSystem()
		input.value           = system.texturePath
	}
	guiState.onAction.texturePath = (input:gui.InputText) {
		setTexturePath(Path(trim(input.value)).toString!())
	}
	guiState.onOption.texturePath = (input:gui.InputText, _:int) {
		local items = {"Recent textures:"}

		if app.recentTextures {
			for app.recentTextures  insert(items, it)
			insert(items, "Clear history")
		} else {
			insert(items, "(no recent files)")
		}

		gui.showContextMenu(guiState, items, [items] (choice:int) {
			if choice <= 1 or not app.recentTextures {
				-- void
			} elseif choice == #items {
				app.recentTextures = {}
			} else {
				local path = items[choice]
				setTexturePath(path)
			}
		})
	}

	guiState.onAction.reloadTexture = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		if system.texturePath  updateParticleTexture(project, system)
	}

	guiState.onRefresh.textureOffsetX = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.offsetX
	}
	addEventHandlersForSlider(forSystem=true, "textureOffsetX", "Changed texture offset x",
		(project:Project, system:System, value:float) {  system.offsetX = value ; updateParticleTextureOffset(system)  }
	)

	guiState.onRefresh.textureOffsetY = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.offsetY
	}
	addEventHandlersForSlider(forSystem=true, "textureOffsetY", "Changed texture offset y",
		(project:Project, system:System, value:float) {  system.offsetY = value ; updateParticleTextureOffset(system)  }
	)

	-- Scale all.
	guiState.onRefresh.scaleTime = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.scaleTime
	}
	addEventHandlersForSlider(forSystem=true, "scaleTime", "Changed time scale",
		(project:Project, system:System, value:float) {  system.scaleTime = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.scaleSpace = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.scaleSpace
	}
	addEventHandlersForSlider(forSystem=true, "scaleSpace", "Changed space scale",
		(project:Project, system:System, value:float) {  system.scaleSpace = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.scaleSize = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.scaleSize
	}
	addEventHandlersForSlider(forSystem=true, "scaleSize", "Changed size scale",
		(project:Project, system:System, value:float) {  system.scaleSize = value ; updateParticleParams(project, system)  }
	)
	--

	guiState.onRefresh.insertMode = (radio:gui.Radio) {
		local project, system = getCurrentProjectAndSystem()
		local found, i        = indexWith(radio.buttons, "value", system.psInsertMode)
		assert(found)
		radio.index = i
	}
	addEventHandlersForRadio("insertMode", LG.ParticleInsertMode, "Changed spawn layer",
		(project:Project, system:System, value:LG.ParticleInsertMode) {  system.psInsertMode = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.emitterContinuous = (checkbox:gui.Checkbox) {
		local project, system = getCurrentProjectAndSystem()
		checkbox.checked      = system.psEmitterContinuous
	}
	addEventHandlersForCheckbox("emitterContinuous", "Toggled continuous emitter",
		(project:Project, system:System, value:bool) {
			system.psEmitterContinuous = value
			updateParticleParams(project, system)
			if system.psEmitterContinuous  system.particles.start!()
		}
	)

	guiState.onRefresh.emitterLifetime = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psEmitterLifetime
	}
	static lastContinuousChange: Change = NULL
	addEventHandlersForSlider(forSystem=true, "emitterLifetime", "Changed emitter lifetime",
		onBegin = (project:Project, system:System) {
			if not system.psEmitterContinuous {
				lastContinuousChange = NULL
				return
			}
			lastContinuousChange = recordChange("Toggled continuous emitter",
				[system] (project:Project) {  system.psEmitterContinuous = false  },
				[system] (project:Project) {  system.psEmitterContinuous = true   },
				[system] (project:Project) {
					updateParticleParams(project, system)
					if system.psEmitterContinuous  system.particles.start!()
					gui.refreshRecursively(guiState, "emitterContinuous")
				}
			)
		},
		(project:Project, system:System, value:float) {
			system.psEmitterLifetime = value
			updateParticleParams(project, system)
			system.particles.start!()
		},
		onEnd = (project:Project, system:System) {
			if lastContinuousChange ~= NULL  lastContinuousChange.bundle = project.changes[#project.changes].bundle
		}
	)
	guiState.onRefresh.particleLifetimeMin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psParticleLifetimeMin
	}
	addEventHandlersForSlider(forSystem=true, "particleLifetimeMin", "Changed min particle lifetime",
		(project:Project, system:System, value:float) {  system.psParticleLifetimeMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.particleLifetimeMax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psParticleLifetimeMax
	}
	addEventHandlersForSlider(forSystem=true, "particleLifetimeMax", "Changed max particle lifetime",
		(project:Project, system:System, value:float) {  system.psParticleLifetimeMax = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.emissionRate = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psEmissionRate
	}
	addEventHandlersForSlider(forSystem=true, "emissionRate", "Changed spawn rate",
		(project:Project, system:System, value:float) {  system.psEmissionRate = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.kickStartEmit = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.kickStartEmit
	}
	addEventHandlersForSlider(forSystem=true, "kickStartEmit", "Changed emit at start",
		(project:Project, system:System, value:float) {  system.kickStartEmit = math.round(value) ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.kickStartSteps = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.kickStartSteps
	}
	addEventHandlersForSlider(forSystem=true, "kickStartSteps", "Changed kick-start steps",
		(project:Project, system:System, value:float) {  system.kickStartSteps = math.round(value) ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.areaDistribution = (radio:gui.Radio) {
		local project, system = getCurrentProjectAndSystem()
		local found, i        = indexWith(radio.buttons, "value", system.psEmissionAreaDistribution)
		assert(found)
		radio.index = i
		gui.setActive(guiState, "areaParams", (i > 1))
	}
	addEventHandlersForRadio("areaDistribution", LG.AreaSpreadDistribution, "Changed distribution",
		(project:Project, system:System, value:LG.AreaSpreadDistribution) {
			system.psEmissionAreaDistribution = value
			updateParticleParams(project, system)
			gui.setActive(guiState, "areaParams", (value == LG.AreaSpreadDistribution.NONE))
			if value ~= LG.AreaSpreadDistribution.NONE  gui.refreshRecursively(guiState, "areaParams")
		}
	)
	guiState.onRefresh.areaAngle = (direction:gui.Direction) {
		local project, system = getCurrentProjectAndSystem()
		direction.angle       = system.psEmissionAreaAngle
	}
	addEventHandlersForDirection("areaAngle", "Changed area angle",
		(project:Project, system:System, value:float) {  system.psEmissionAreaAngle = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.areaDx = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psEmissionAreaDx
	}
	addEventHandlersForSlider(forSystem=true, "areaDx", "Changed area dx",
		(project:Project, system:System, value:float) {  system.psEmissionAreaDx = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.areaDy = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psEmissionAreaDy
	}
	addEventHandlersForSlider(forSystem=true, "areaDy", "Changed area dy",
		(project:Project, system:System, value:float) {  system.psEmissionAreaDy = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.areaRelative = (checkbox:gui.Checkbox) {
		local project, system = getCurrentProjectAndSystem()
		checkbox.checked      = system.psEmissionAreaRelative
	}
	addEventHandlersForCheckbox("areaRelative", "Toggled relative direction",
		(project:Project, system:System, value:bool) {  system.psEmissionAreaRelative = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.direction = (direction:gui.Direction) {
		local project, system = getCurrentProjectAndSystem()
		direction.angle       = system.psDirection
	}
	addEventHandlersForDirection("direction", "Changed direction",
		(project:Project, system:System, value:float) {  system.psDirection = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.directionSpread = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psSpread
	}
	addEventHandlersForSlider(forSystem=true, "directionSpread", "Changed spread",
		(project:Project, system:System, value:float) {  system.psSpread = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.speedMin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psSpeedMin
	}
	addEventHandlersForSlider(forSystem=true, "speedMin", "Changed min speed",
		(project:Project, system:System, value:float) {  system.psSpeedMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.speedMax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psSpeedMax
	}
	addEventHandlersForSlider(forSystem=true, "speedMax", "Changed max speed",
		(project:Project, system:System, value:float) {  system.psSpeedMax = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.accLinearXmin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psLinearAccelerationXmin
	}
	addEventHandlersForSlider(forSystem=true, "accLinearXmin", "Changed min linear acceleration x",
		(project:Project, system:System, value:float) {  system.psLinearAccelerationXmin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.accLinearXmax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psLinearAccelerationXmax
	}
	addEventHandlersForSlider(forSystem=true, "accLinearXmax", "Changed max linear acceleration x",
		(project:Project, system:System, value:float) {  system.psLinearAccelerationXmax = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.accLinearYmin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psLinearAccelerationYmin
	}
	addEventHandlersForSlider(forSystem=true, "accLinearYmin", "Changed min linear acceleration y",
		(project:Project, system:System, value:float) {  system.psLinearAccelerationYmin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.accLinearYmax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psLinearAccelerationYmax
	}
	addEventHandlersForSlider(forSystem=true, "accLinearYmax", "Changed max linear acceleration y",
		(project:Project, system:System, value:float) {  system.psLinearAccelerationYmax = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.radialAccelerationMin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psRadialAccelerationMin
	}
	addEventHandlersForSlider(forSystem=true, "radialAccelerationMin", "Changed min radial acceleration",
		(project:Project, system:System, value:float) {  system.psRadialAccelerationMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.radialAccelerationMax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psRadialAccelerationMax
	}
	addEventHandlersForSlider(forSystem=true, "radialAccelerationMax", "Changed max radial acceleration",
		(project:Project, system:System, value:float) {  system.psRadialAccelerationMax = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.tangentialAccelerationMin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psTangentialAccelerationMin
	}
	addEventHandlersForSlider(forSystem=true, "tangentialAccelerationMin", "Changed min tangential acceleration",
		(project:Project, system:System, value:float) {  system.psTangentialAccelerationMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.tangentialAccelerationMax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psTangentialAccelerationMax
	}
	addEventHandlersForSlider(forSystem=true, "tangentialAccelerationMax", "Changed max tangential acceleration",
		(project:Project, system:System, value:float) {  system.psTangentialAccelerationMax = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.linearDampingMin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psLinearDampingMin
	}
	addEventHandlersForSlider(forSystem=true, "linearDampingMin", "Changed min linear damping",
		(project:Project, system:System, value:float) {  system.psLinearDampingMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.linearDampingMax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psLinearDampingMax
	}
	addEventHandlersForSlider(forSystem=true, "linearDampingMax", "Changed max linear damping",
		(project:Project, system:System, value:float) {  system.psLinearDampingMax = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.rotationMin = (direction:gui.Direction) {
		local project, system = getCurrentProjectAndSystem()
		direction.angle       = system.psRotationMin
	}
	addEventHandlersForDirection("rotationMin", "Changed min rotation",
		(project:Project, system:System, value:float) {  system.psRotationMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.rotationMax = (direction:gui.Direction) {
		local project, system = getCurrentProjectAndSystem()
		direction.angle       = system.psRotationMax
	}
	addEventHandlersForDirection("rotationMax", "Changed max rotation",
		(project:Project, system:System, value:float) {  system.psRotationMax = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.rotationRelative = (checkbox:gui.Checkbox) {
		local project, system = getCurrentProjectAndSystem()
		checkbox.checked      = system.psRelativeRotation
	}
	addEventHandlersForCheckbox("rotationRelative", "Toggled relative rotation",
		(project:Project, system:System, value:bool) {  system.psRelativeRotation = value ; updateParticleParams(project, system)  }
	)

	guiState.onRefresh.spinMin = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psSpinMin
	}
	addEventHandlersForSlider(forSystem=true, "spinMin", "Changed spin at start",
		(project:Project, system:System, value:float) {  system.psSpinMin = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.spinMax = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psSpinMax
	}
	addEventHandlersForSlider(forSystem=true, "spinMax", "Changed spin at end",
		(project:Project, system:System, value:float) {  system.psSpinMax = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.spinVariation = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psSpinVariation
	}
	addEventHandlersForSlider(forSystem=true, "spinVariation", "Changed spin variation",
		(project:Project, system:System, value:float) {  system.psSpinVariation = value ; updateParticleParams(project, system)  }
	)
	guiState.onRefresh.sizeVariation = (slider:gui.Slider) {
		local project, system = getCurrentProjectAndSystem()
		slider.value          = system.psSizeVariation
	}

	-- Sizes.
	guiState.onRefresh.sizesSection = (section:gui.Section) {
		local project, system = getCurrentProjectAndSystem()
		for 1, 8  gui.setActive(guiState, format("sizeContainer%d", it), (system.psSizes[it] ~= NULL))
	}
	guiState.onAction.sizeAdd = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		local i               = cast(int) buttons.data

		if system.psSizes[8] ~= NULL {
			setErrorText("Max 8 sizes")
			return
		}

		recordChange("Added size",
			[system, i] (project:Project) {  insert(system.psSizes, i, system.psSizes[i])  },
			[system, i] (project:Project) {  remove(system.psSizes, i)  },
			[system, i] (project:Project) {
				updateParticleParams(project, system)
				if isSystemCurrent(system)  for j = i, 8 {
					local name   = format("sizeContainer%d", j)
					local active = j <= #system.psSizes
					gui.setActive(guiState, name, active)
					if active  gui.refreshRecursively(guiState, name)
				}
			}
		)
	}
	guiState.onAction.sizeRemove = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		local i               = cast(int) buttons.data
		local valueOld        = system.psSizes[i]
		local removingLast    = #system.psSizes == 1

		if removingLast and valueOld == 1  return

		if removingLast {
			recordChange("Removed size",
				[system          ] (project:Project) {  system.psSizes[1] = 1         },
				[system, valueOld] (project:Project) {  system.psSizes[1] = valueOld  },
				[system          ] (project:Project) {  updateParticleParams(project, system) ; gui.refreshRecursively(guiState, "sizeContainer1")  }
			)
		} else {
			recordChange("Removed size",
				[system, i          ] (project:Project) {  remove(system.psSizes, i)  },
				[system, i, valueOld] (project:Project) {  insert(system.psSizes, i, valueOld)  },
				[system, i          ] (project:Project) {
					updateParticleParams(project, system)
					if isSystemCurrent(system)  for j = i, 8 {
						local name   = format("sizeContainer%d", j)
						local active = j <= #system.psSizes
						gui.setActive(guiState, name, active)
						if active  gui.refreshRecursively(guiState, name)
					}
				}
			)
		}
	}
	for i = 1, 8 {
		local name = format("size%d", i)
		guiState.onRefresh[name] = [i] (slider:gui.Slider) {
			local project, system = getCurrentProjectAndSystem()
			slider.value          = system.psSizes[i]
			if slider.value == NULL  errorf("Size #%d", i)
		}
		addEventHandlersForSlider(forSystem=true, name, "Changed size",
			[i] (project:Project, system:System, value:float) {  system.psSizes[i] = value ; updateParticleParams(project, system)  }
		)
	}
	addEventHandlersForSlider(forSystem=true, "sizeVariation", "Changed size variation",
		(project:Project, system:System, value:float) {  system.psSizeVariation = value ; updateParticleParams(project, system)  }
	)

	-- Colors.
	guiState.onRefresh.colors = (box:gui.Vbox) {
		local project, system = getCurrentProjectAndSystem()
		local colors          = system.colors
		for 1, 8  gui.setActive(guiState, format("colorContainer%d", it), (colors[it*4] ~= NULL))
	}
	guiState.onAction.colorAdd = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		local i               = cast(int) buttons.data

		if system.colors[8*4] ~= NULL {
			setErrorText("Max 8 colors")
			return
		}

		recordChange("Added color",
			[system, i] (project:Project) {
				local i1 = i*4 - 3
				local h  = system.colors[i1  ]
				local s  = system.colors[i1+1]
				local v  = system.colors[i1+2]
				local a  = system.colors[i1+3]
				insert(system.colors, i1,   h)
				insert(system.colors, i1+1, s)
				insert(system.colors, i1+2, v)
				insert(system.colors, i1+3, a)
			},
			[system, i] (project:Project) {
				local i1 = i*4 - 3
				remove(system.colors, i1+3)
				remove(system.colors, i1+2)
				remove(system.colors, i1+1)
				remove(system.colors, i1)
			},
			[system, i] (project:Project) {
				updateParticleColors(system)
				if isSystemCurrent(system)  for j = i, 8 {
					local name   = format("colorContainer%d", j)
					local active = j*4 <= #system.colors
					gui.setActive(guiState, name, active)
					if active  gui.refreshRecursively(guiState, name)
				}
			}
		)
	}
	guiState.onAction.colorRemove = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		local i               = cast(int) buttons.data
		local i1              = i*4 - 3
		local hOld            = system.colors[i1]
		local sOld            = system.colors[i1+1]
		local vOld            = system.colors[i1+2]
		local aOld            = system.colors[i1+3]
		local removingLast    = #system.colors == 4

		if removingLast and hOld == 0 and sOld == 0 and vOld == 1 and aOld == 1  return

		if removingLast {
			recordChange("Removed color",
				[system] (project:Project) {
					system.colors[1] = 0
					system.colors[2] = 0
					system.colors[3] = 1
					system.colors[4] = 1
				},
				[system, hOld, sOld, vOld, aOld] (project:Project) {
					system.colors[1] = hOld
					system.colors[2] = sOld
					system.colors[3] = vOld
					system.colors[4] = aOld
				},
				[system] (project:Project) {
					updateParticleColors(system) ; gui.refreshRecursively(guiState, "colorContainer1")
				}
			)
		} else {
			recordChange("Removed color",
				[system, i] (project:Project) {
					local i1 = i*4 - 3
					remove(system.colors, i1+3)
					remove(system.colors, i1+2)
					remove(system.colors, i1+1)
					remove(system.colors, i1  )
				},
				[system, i, hOld, sOld, vOld, aOld] (project:Project) {
					local i1 = i*4 - 3
					insert(system.colors, i1,   hOld)
					insert(system.colors, i1+1, sOld)
					insert(system.colors, i1+2, vOld)
					insert(system.colors, i1+3, aOld)
				},
				[system, i] (project:Project) {
					updateParticleColors(system)
					if isSystemCurrent(system)  for j = i, 8 {
						local name   = format("colorContainer%d", j)
						local active = j*4 <= #system.colors
						gui.setActive(guiState, name, active)
						if active  gui.refreshRecursively(guiState, name)
					}
				}
			)
		}
	}
	static colorsBeforeDragging: []float = NULL
	guiState.onDragBegin.colorMove = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		colorsBeforeDragging  = system.colors
		system.colors         = {unpack(system.colors)}
	}
	guiState.onDrag.colorMove = (buttons:gui.Buttons, buttonIndex:int, mx,my:int) {
		local dragContainer = gui.getElement(guiState, "colors", gui.Vbox)

		local project, system = getCurrentProjectAndSystem()
		local colors          = system.colors
		local i               = cast(int) buttons.data
		local targetIndex     = math.clamp(math.floor(1 + (my - (dragContainer.layoutY + gui.getScrollOffset(dragContainer))) / (dragContainer[1].layoutHeight + gui.SPACING)), 1, #colors//4)
		if targetIndex == i  return

		local dir = math.getSign(targetIndex-i)

		for j = i, targetIndex-dir, dir {
			colors[j*4-3], colors[(j+dir)*4-3] = colors[(j+dir)*4-3], colors[j*4-3]
			colors[j*4-2], colors[(j+dir)*4-2] = colors[(j+dir)*4-2], colors[j*4-2]
			colors[j*4-1], colors[(j+dir)*4-1] = colors[(j+dir)*4-1], colors[j*4-1]
			colors[j*4  ], colors[(j+dir)*4  ] = colors[(j+dir)*4  ], colors[j*4  ]
		}

		updateParticleColors(system)

		guiState.activeId  = dragContainer[targetIndex][1].id -- @Volatile
		guiState.hoveredId = guiState.activeId

		gui.refreshRecursively(guiState, dragContainer)
	}
	guiState.onDragEnd.colorMove = (buttons:gui.Buttons, buttonIndex:int) {
		local project, system = getCurrentProjectAndSystem()
		local colorsOld       = colorsBeforeDragging
		local colorsNew       = system.colors
		local newOrder        = false

		for colorsNew {
			if it ~= colorsOld[itIndex] {
				newOrder = true
				break
			}
		}
		if not newOrder  return

		recordChange("Reordered colors",
			[system, colorsNew] (project:Project) {  system.colors = colorsNew  },
			[system, colorsOld] (project:Project) {  system.colors = colorsOld  },
			[system           ] (project:Project) {
				if isSystemCurrent(system)  gui.refreshRecursively(guiState, "colors")
				updateParticleColors(system)
			}
		)
	}
	for i = 1, 8 {
		guiState.onRefresh[format("color%d", i)] = [i] (colorEl:gui.Color) {
			local project, system = getCurrentProjectAndSystem()
			local colors          = system.colors
			local i1              = i*4 - 3
			colorEl.color[1]      = colors[i1+0]
			colorEl.color[2]      = colors[i1+1]
			colorEl.color[3]      = colors[i1+2]
			colorEl.color[4]      = colors[i1+3]
		}
		addEventHandlersForColor(forSystem=true, format("color%d", i), "Changed color",
			[i] (project:Project, system:System, component:int, value:float) {  system.colors[(i-1)*4+component] = value ; updateParticleColors(system)  }
		)
	}

	guiState.onRefresh.colorPreview = (preview:gui.ColorPreview) {
		local project, system = getCurrentProjectAndSystem()
		preview.blendMode     = system.blendMode
	}

	guiState.onRefresh.blendMode = (radio:gui.Radio) {
		local project, system = getCurrentProjectAndSystem()
		local found, i        = indexWith(radio.buttons, "value", system.blendMode)
		assert(found)
		radio.index = i
	}
	addEventHandlersForRadio("blendMode", LG.BlendMode, "Changed blend mode",
		(project:Project, system:System, value:LG.BlendMode) {
			system.blendMode = value
			updateParticleParams(project, system)
			gui.getElement(guiState, "colorPreview", gui.ColorPreview).blendMode = value
		}
	)

	--==============================================================
	--= Save/open project
	--==============================================================
	do {
		local Item :: struct { isDir=false, name="" }
		static dirCurrent:  string = NULL
		static dirFallback: string = NULL
		static projectBeingSaved: Project = NULL

		static lastProjectBeforeTemp: Project = NULL

		local loadPreview :: (path:string) {
			local lastIndex = app.currentProjectIndex

			local ok, project = openProject(path, asPreview=true)
			if not ok  return

			if lastProjectBeforeTemp == NULL {
				lastProjectBeforeTemp = app.projects[lastIndex]
			}
		}

		local unloadPreview :: () {
			local currentProject = app.projects[app.currentProjectIndex]

			for < app.projects  if it.preview {
				remove(app.projects, itIndex)
			}

			local ok, i = indexOf(app.projects, (currentProject.preview ? lastProjectBeforeTemp : currentProject))
			assert(ok)
			gui.refreshRecursively(guiState, "projects")
			setCurrentProject(i, force=true)

			lastProjectBeforeTemp = NULL
			scheduleSaveWorkspace()
		}

		guiState.onActive.saveProjectAs = (frame:gui.Frame) {
			local isSave  = (frame.name == "saveProjectAs")
			local project = app.projects[app.currentProjectIndex]
			local pathObj = Path(project.path)

			if isSave  projectBeingSaved = project -- Needed as we load previews even in the save dialog, which means app.currentProjectIndex may change.

			local ok, dir, filename = pathObj.getDirectoryAndFilename!()
			if not ok {
				dir      = getSaveDirectory().."/projects"
				filename = "untitled.hotparticles"
			}

			if not isSave  filename = ""

			dirCurrent  = dir
			dirFallback = getSaveDirectory()

			local filenameInput = gui.getElement(guiState, (isSave ? "saveProjectAs_filename" : "openProject_filename"), gui.InputText)
			filenameInput.value = filename

			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_bookmarks" : "openProject_bookmarks"))
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_recent"    : "openProject_recent"))
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items"     : "openProject_items"))
			gui.setFocus(guiState, filenameInput)

			local basename, ext = splitBasenameAndExtension(filename)
			filenameInput.field.setSelection!(0, utf8.getLength(basename))
		}
		guiState.onActive.openProject = guiState.onActive.saveProjectAs

		guiState.onInactive.saveProjectAs = (frame:gui.Frame) {
			unloadPreview()
			projectBeingSaved = NULL
		}
		guiState.onInactive.openProject = guiState.onInactive.saveProjectAs

		-- Bookmarks.
		guiState.onRefresh.saveProjectAs_bookmarks = (buttons:gui.Buttons) {
			buttons.buttons = {}
			for app.bookmarkedFolders {
				insert(buttons.buttons, cast(gui.Button){ value=it, label=it, image="iconFolder" })
			}
		}
		guiState.onRefresh.openProject_bookmarks = guiState.onRefresh.saveProjectAs_bookmarks

		guiState.onAction.saveProjectAs_bookmarks = (buttons:gui.Buttons, buttonIndex:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			dirCurrent   = app.bookmarkedFolders[buttonIndex]
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))
		}
		guiState.onAction.openProject_bookmarks = guiState.onAction.saveProjectAs_bookmarks

		guiState.onOption.saveProjectAs_bookmarks = (buttons:gui.Buttons, indexToRemove:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")

			gui.showContextMenu(guiState, {"Remove bookmark"}, [indexToRemove,isSave] (choice:int) {
				if choice == {
					case 1:
						remove(app.bookmarkedFolders, indexToRemove)
						gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_bookmarks" : "openProject_bookmarks"))
				}
			})
		}
		guiState.onOption.openProject_bookmarks = guiState.onOption.saveProjectAs_bookmarks

		guiState.onAction.saveProjectAs_addBookmark = (buttons:gui.Buttons, buttonIndex:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")

			if insertIfUnique(app.bookmarkedFolders, dirCurrent) {
				sort(app.bookmarkedFolders)
				gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_bookmarks" : "openProject_bookmarks"))
			}
		}
		guiState.onAction.openProject_addBookmark = guiState.onAction.saveProjectAs_addBookmark

		-- Recent.
		guiState.onRefresh.saveProjectAs_recent = (buttons:gui.Buttons) {
			buttons.buttons = {}
			for app.recentFolders {
				insert(buttons.buttons, cast(gui.Button){ value=it, label=it, image="iconFolder" })
			}
		}
		guiState.onRefresh.openProject_recent = guiState.onRefresh.saveProjectAs_recent

		guiState.onAction.saveProjectAs_recent = (buttons:gui.Buttons, buttonIndex:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			dirCurrent   = app.recentFolders[buttonIndex]
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))
		}
		guiState.onAction.openProject_recent = guiState.onAction.saveProjectAs_recent

		guiState.onAction.saveProjectAs_clearRecent = (buttons:gui.Buttons, buttonIndex:int) {
			local isSave      = (buttons.frame.name == "saveProjectAs")
			app.recentFolders = {}
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_recent" : "openProject_recent"))
		}
		guiState.onAction.openProject_clearRecent = guiState.onAction.saveProjectAs_clearRecent

		-- Directory.
		guiState.onRefresh.saveProjectAs_directory = (input:gui.InputText, buttonIndex:int) {
			input.value = dirCurrent
		}
		guiState.onRefresh.openProject_directory = guiState.onRefresh.saveProjectAs_directory

		guiState.onSubmit.saveProjectAs_directory = (input:gui.InputText, buttonIndex:int) {
			local isSave = (input.frame.name == "saveProjectAs")
			local dirObj = Path(trim(input.value))
			if not dirObj.isAbsolute  return

			dirCurrent = dirObj.toString!()
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))
		}
		guiState.onSubmit.openProject_directory = guiState.onSubmit.saveProjectAs_directory

		-- Directory items.
		guiState.onRefresh.saveProjectAs_items = (buttons:gui.Buttons) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			local dir    = dirCurrent

			if not connectToRemoteDirectory(dir) {
				dir = dirFallback
				if not connectToRemoteDirectory(dir) {
					dir = getSaveDirectory().."/projects"
					if not connectToRemoteDirectory(dir) {
						dir = getSaveDirectory()
						if not connectToRemoteDirectory(dir) {
							dir = getCwd()
							assert(connectToRemoteDirectory(dir))
						}
					}
				}
			}
			defer disconnectFromRemoteDirectory()
			dirCurrent  = dir
			dirFallback = dir -- Last successfully connected directory.

			local dirs:      []string
			local filenames: []string

			for LF.getDirectoryItems("") {
				static info: LF.FileInfo

				if LF.getInfo(it, info) == nil {
					-- void  The file may be a system file or something.
				} elseif info.type == LF.FileType.DIRECTORY {
					if not findPattern(it, "^%$")  insert(dirs, it)
				} elseif info.type == LF.FileType.FILE {
					if findPattern(it, "%.hotparticles$")  insert(filenames, it)
				}
			}

			sort(dirs,      compareFilenames)
			sort(filenames, compareFilenames)

			buttons.buttons = {}
			insert(buttons.buttons, cast(gui.Button){ value=cast(Item){isDir=true,name=".."}, label="..", image="iconFolder" })

			for dirs {
				insert(buttons.buttons, cast(gui.Button){
					value = cast(Item) {isDir=true, name=it},
					label = it,
					image = "iconFolder",
				})
			}
			for filenames {
				local basename, ext = splitBasenameAndExtension(it, keepDot=true)
				insert(buttons.buttons, cast(gui.Button){
					value  = cast(Item) {isDir=false, name=it},
					label  = basename,
					suffix = ext,
				})
			}

			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_directory" : "openProject_directory"))
		}
		guiState.onRefresh.openProject_items = guiState.onRefresh.saveProjectAs_items

		guiState.onAction.saveProjectAs_items = (buttons:gui.Buttons, buttonIndex:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			local item   = cast(Item) buttons.buttons[buttonIndex].value

			if not item.isDir {
				local input   = gui.getElement(guiState, (isSave ? "saveProjectAs_filename" : "openProject_filename"), gui.InputText)
				input.value   = item.name
				local pathObj = Path(dirCurrent)
				insert(pathObj.path, item.name)
				loadPreview(pathObj.toString!())

				local ok, filename = pathObj.getFilename!()
				if isSave and ok {
					local basename, ext = splitBasenameAndExtension(filename)
					gui.setFocus(guiState, input)
					input.field.setSelection!(0, utf8.getLength(basename))
				}

			} elseif item.name == ".." {
				local dirObj = Path(dirCurrent)
				dirObj.pop!()
				dirCurrent = dirObj.toString!()
				gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))

			} else {
				local dirObj = Path(dirCurrent)
				insert(dirObj.path, item.name)
				dirCurrent = dirObj.toString!()
				gui.refreshRecursively(guiState, buttons)
			}
		}
		guiState.onAction.openProject_items = guiState.onAction.saveProjectAs_items

		-- Save.
		guiState.onDouble.saveProjectAs_items    = (buttons:gui.Buttons, buttonIndex:int) { if not (cast(Item) buttons.buttons[buttonIndex].value).isDir  save() }
		guiState.onSubmit.saveProjectAs_filename = (input:gui.InputText)                  { save() }
		guiState.onAction.saveProjectAs_save     = (buttons:gui.Buttons, buttonIndex:int) { save() }
		local save :: () {
			local input   = gui.getElement(guiState, "saveProjectAs_filename", gui.InputText)
			input.value   = trim(input.value)
			local pathObj = Path(input.value)
			input.value   = pathObj.toString!()

			if pathObj.isEmpty!() {
				gui.setFocus(guiState, input)
				return
			}

			pathObj.prepend!(dirCurrent) -- Fails if pathObj is absolute.

			local ok, filename = pathObj.getFilename!()
			if not ok {
				gui.setFocus(guiState, input)
				return
			}

			if not findPattern(filename, "%.hotparticles$") {
				filename    = filename..".hotparticles"
				input.value = input.value..".hotparticles"
				pathObj.setFilename!(filename)
			}

			projectBeingSaved.path = pathObj.toString!()

			local ^ok, fileExists = saveProject(projectBeingSaved)
			if ok {
				updateParticleTextures(projectBeingSaved) -- In case any texture uses a relative path.
				popPanel()

			} elseif fileExists {
				local BUTTONS: []gui.Button : {{label="Overwrite"},{label="Cancel"}}

				pushTempChoiceDialog("Confirm save as", filename.." already exists. Overwite it?", BUTTONS, submitIndex=1, (choice:int) {
					if choice ~= 1  return

					saveProject(projectBeingSaved, overwrite=true)

					updateParticleTextures(projectBeingSaved) -- In case any texture uses a relative path.
					popPanel("saveProjectAs")
				})

			} else {
				-- void  Stay in the dialog.
			}
		}

		-- Open.
		guiState.onDouble.openProject_items    = (buttons:gui.Buttons, buttonIndex:int) { if not (cast(Item) buttons.buttons[buttonIndex].value).isDir  open() }
		guiState.onSubmit.openProject_filename = (input:gui.InputText)                  { open() }
		guiState.onAction.openProject_open     = (buttons:gui.Buttons, buttonIndex:int) { open() }
		local open :: () {
			local input   = gui.getElement(guiState, "openProject_filename", gui.InputText)
			input.value   = trim(input.value)
			local pathObj = Path(input.value)
			input.value   = pathObj.toString!()

			if pathObj.isEmpty!() {
				gui.setFocus(guiState, input)
				return
			}

			pathObj.prepend!(dirCurrent) -- Fails if pathObj is absolute.

			local path        = pathObj.toString!()
			local ok, project = openProject(pathObj.toString!())
			if not ok {
				gui.setFocus(guiState, input)
				return
			}

			project.preview = false -- In case the project was already opened as a preview (which it probably always is).
			popPanel()

			local _, dir = pathObj.getDirectory!()
			addRecent(app.recentFolders, dir,  app.maxRecentFolders)
			addRecent(app.recentFiles,   path, app.maxRecentFiles)

			-- Make sure the loaded project replaces any single empty project.
			if #app.projects == 2 and isProjectEmpty(app.projects[1]) {
				remove(app.projects, 1)

				gui.refreshRecursively(guiState, "projects")
				setCurrentProject(1)
			}
		}
	}

	--==============================================================
	--= Export project
	--==============================================================

	guiState.onActive.exportProject = (frame:gui.Frame) {
		gui.refreshRecursively(guiState, "exportProject")
	}

	-- Files.
	local replaceQuestionMarks :: (project:Project, path:string) -> string {
		if not find(path, "?")  return path

		local filename = "untitled"

		if project.path {
			_, filename = Path(project.path).getFilename!()
			filename    = replacePatternWithPattern(filename, "(.)%.[^.]+", "%1") ?: "untitled"
		}

		return (replace(path, "?", filename))
	}
	local resolveBaseOuputPath :: (project:Project) -> (success:bool, dir:string) {
		local dirObj = Path(replaceQuestionMarks(project, project.exportBaseDirectory))

		if not dirObj.isAbsolute {
			local ok, dir = Path(project.path).getDirectory!()
			if not ok  return false, NULL
			dirObj.prepend!(dir)
		}

		return true, dirObj.toString!()
	}
	local resolveParticlesOuputPath :: (project:Project) -> (success:bool, path:string) {
		local pathObj      = Path(replaceQuestionMarks(project, project.exportParticlesPath))
		local ok, filename = pathObj.getFilename!()

		if not ok {
			if not project.path  return false, NULL

			_, filename = Path(project.path).getFilename!()
			filename    = replacePatternWithPattern(filename, "(.)%.[^.]+", "%1") ?: "untitled"
			filename    = filename..".lua"

			pathObj.setFilename!(filename)

		} elseif filename == "." or filename == ".." {
			return false, NULL
		}

		if not pathObj.isAbsolute  pathObj.prepend!(replaceQuestionMarks(project, project.exportBaseDirectory))

		if not pathObj.isAbsolute {
			local ^ok, dir = Path(project.path).getDirectory!()
			if not ok  return false, NULL
			pathObj.prepend!(dir)
		}

		return true, pathObj.toString!()
	}
	local resolveTextureOuputPath :: (project:Project, system:System) -> (success:bool, path:string, sameAsInput:bool) {
		local pathObj = Path(system.texturePath ?: format("%s/gfx/particles/%s.png", getAppDirectory(), system.textureName))

		-- Resolve to current path.
		if not pathObj.isAbsolute {
			local ok, dir = Path(project.path).getDirectory!()
			if ok  pathObj.prepend!(dir)
		}

		local hasBaseDir, baseDir = resolveBaseOuputPath(project)

		if hasBaseDir {
			local baseDirObj = Path(baseDir)
			assert(baseDirObj.isAbsolute)

			if not baseDirObj.contains!(pathObj) {
				pathObj = Path(pathObj.path[#pathObj.path])
			}
		}

		-- Resolve to generated path or the current path isn't in the base directory.
		if not pathObj.isAbsolute {
			pathObj.prepend!(replaceQuestionMarks(project, project.exportTexturesDirectory))

			if not pathObj.isAbsolute and hasBaseDir  pathObj.prepend!(baseDir)

			if not pathObj.isAbsolute  return false, NULL, NULL
		}

		local ok, inputPath = getTextureFullPath(project, system)
		if not ok  inputPath = ""

		local path = pathObj.toString!()

		--[[ DEBUG
		printf(
			"%-40s  %-40s  %-40s  %s",
			(system.texturePath ?: format("%s/gfx/particles/%s.png", getAppDirectory(), system.textureName)),
			inputPath, path, toString(path == inputPath)
		)
		--]]

		return true, path, (path == inputPath)
	}
	!if 1==0  !run {
		local Test :: struct {
			project: Project,
			expectedBaseDirectory: string,
			expectedParticlesPath: string,
			expectedTexturePaths:  []string,
		}

		local TESTS: []Test : {
			{
				project = {
					path                    = "C:/MyProject/particles/cool.hotparticles",
					exportBaseDirectory     = "..",
					exportParticlesPath     = "data/particles_?.lua",
					exportTexturesDirectory = "gfxOutput",
					systems                 = {{texturePath="../gfx/cool.png"},{textureName="star"}},
				},
				expectedBaseDirectory = "C:/MyProject",
				expectedParticlesPath = "C:/MyProject/data/particles_cool.lua",
				expectedTexturePaths  = {"C:/MyProject/gfx/cool.png","C:/MyProject/gfxOutput/star.png"},
			},
			{
				project = {
					path                    = "C:/TheFoo/my.hotparticles",
					exportBaseDirectory     = "",
					exportParticlesPath     = "",
					exportTexturesDirectory = "C:/TheFoo",
					systems                 = {{texturePath="gfx/cat.jpg"},{texturePath="D:/Dogs/Good boy.jpg"}},
				},
				expectedBaseDirectory = "C:/TheFoo",
				expectedParticlesPath = "C:/TheFoo/my.lua",
				expectedTexturePaths  = {"C:/TheFoo/gfx/cat.jpg","C:/TheFoo/Good boy.jpg"},
			},
			{
				project = {
					path                    = "C:/Place1/very.hotparticles",
					exportBaseDirectory     = "D:/Place2",
					exportParticlesPath     = "E:/Place3/?.lua",
					exportTexturesDirectory = "F:/Place4",
					systems                 = {{texturePath="G:/Place5/the.png"}},
				},
				expectedBaseDirectory = "D:/Place2",
				expectedParticlesPath = "E:/Place3/very.lua",
				expectedTexturePaths  = {"F:/Place4/the.png"},
			},
		}

		for test: TESTS {
			local project = test.project
			print()
			print(project.path)

			print("exportBaseDirectory")
			print("  HAS   ", project.exportBaseDirectory)
			print("  EXPECT", test.expectedBaseDirectory)
			local ok, dir = resolveBaseOuputPath(project)
			assert(ok, "not ok")
			print("  GOT   ", dir)
			assert(dir == test.expectedBaseDirectory, "no match")

			print("exportParticlesPath")
			print("  HAS   ", project.exportParticlesPath)
			print("  EXPECT", test.expectedParticlesPath)
			local ^ok, path = resolveParticlesOuputPath(project)
			assert(ok, "not ok")
			print("  GOT   ", path)
			assert(path == test.expectedParticlesPath, "no match")

			for system: project.systems {
				print("texturePath")
				print("  HAS   ", system.texturePath, "|", system.textureName..".png")
				print("  EXPECT", test.expectedTexturePaths[itIndex])
				ok, path = resolveTextureOuputPath(project, system)
				assert(ok, "not ok")
				print("  GOT   ", path)
				assert(path == test.expectedTexturePaths[itIndex], "no match")
			}
		}

		print("All tests passed!")
		!import"os".exit(2)
	}

	guiState.onRefresh.exportProject_baseDirectory = (input:gui.InputText) {
		local project = app.projects[app.currentProjectIndex]
		input.value   = project.exportBaseDirectory
	}
	guiState.onAction.exportProject_baseDirectory = (input:gui.InputText, _:int) {
		local project               = app.projects[app.currentProjectIndex]
		input.value                 = Path(trim(input.value)).toString!()
		project.exportBaseDirectory = input.value
		markEdited(project)
		gui.refreshRecursively(guiState, "exportProject_baseDirectoryResult")
		gui.refreshRecursively(guiState, "exportProject_baseDirectoryResultInfo")
		gui.refreshRecursively(guiState, "exportProject_particles_path")
		gui.refreshRecursively(guiState, "exportProject_particles_pathResult")
		gui.refreshRecursively(guiState, "exportProject_particles_pathResultInfo")
		gui.refreshRecursively(guiState, "exportProject_textures_directory")
		gui.refreshRecursively(guiState, "exportProject_textures_pathResults")
		gui.refreshRecursively(guiState, "exportProject_textures_pathResultsInfo")
	}
	guiState.onRefresh.exportProject_baseDirectoryResult = (textEl:gui.Text) {
		local project  = app.projects[app.currentProjectIndex]
		local ok, path = resolveBaseOuputPath(project)

		if not ok {
			textEl.text = "Missing/invalid path!"
			return
		}

		textEl.text = path
	}
	guiState.onRefresh.exportProject_baseDirectoryResultInfo = (buttons:gui.Buttons) {
		buttons.tooltip = gui.getElement(guiState, "exportProject_baseDirectoryResult", gui.Text).text
	}

	-- Particles file.
	guiState.onRefresh.exportProject_particles_writeFile = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.exportParticles
	}
	guiState.onAction.exportProject_particles_writeFile = (checkbox:gui.Checkbox, _:int) {
		local project           = app.projects[app.currentProjectIndex]
		project.exportParticles = checkbox.checked
		markEdited(project)
		gui.refreshRecursively(guiState, "exportProject_particles_pathResult")
		gui.refreshRecursively(guiState, "exportProject_particles_pathResultInfo")
	}

	guiState.onRefresh.exportProject_particles_overwrite = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.exportParticlesOverwrite
	}
	guiState.onAction.exportProject_particles_overwrite = (checkbox:gui.Checkbox, _:int) {
		local project                    = app.projects[app.currentProjectIndex]
		project.exportParticlesOverwrite = checkbox.checked
		markEdited(project)
	}

	guiState.onRefresh.exportProject_particles_path = (input:gui.InputText) {
		local project = app.projects[app.currentProjectIndex]
		input.value   = project.exportParticlesPath
	}
	guiState.onAction.exportProject_particles_path = (input:gui.InputText, _:int) {
		local project               = app.projects[app.currentProjectIndex]
		input.value                 = Path(trim(input.value)).toString!()
		project.exportParticlesPath = input.value
		markEdited(project)
		gui.refreshRecursively(guiState, "exportProject_particles_pathResult")
		gui.refreshRecursively(guiState, "exportProject_particles_pathResultInfo")
	}
	guiState.onRefresh.exportProject_particles_pathResult = (textEl:gui.Text) {
		local project = app.projects[app.currentProjectIndex]

		if not project.exportParticles {
			textEl.text = ""
			return
		}

		local ok, path = resolveParticlesOuputPath(project)

		if not ok {
			textEl.text = "Missing/invalid path!"
			return
		}

		textEl.text = path
	}
	guiState.onRefresh.exportProject_particles_pathResultInfo = (buttons:gui.Buttons) {
		buttons.tooltip = gui.getElement(guiState, "exportProject_particles_pathResult", gui.Text).text
	}

	guiState.onRefresh.exportProject_particles_template = (buttons:gui.Buttons) {
		local project            = app.projects[app.currentProjectIndex]
		buttons.buttons[1].label = project.exportParticlesTemplate
	}
	guiState.onAction.exportProject_particles_template = (buttons:gui.Buttons, buttonIndex:int) {
		showTemplateDropdownMenu(buttons, (templateName:string) {
			local project                   = app.projects[app.currentProjectIndex]
			project.exportParticlesTemplate = templateName
			markEdited(project)
			gui.refreshRecursively(guiState, "exportProject_particles_template")
		})
	}
	local showTemplateDropdownMenu :: (buttons:gui.Buttons, cb:(templateName:string)) {
		local templateNames: []string

		for LF.getDirectoryItems(EXPORT_TEMPLATES_DIRECTORY) {
			static info: LF.FileInfo

			if findPattern(it, "%.lua$") and LF.getInfo(EXPORT_TEMPLATES_DIRECTORY.."/"..it, info) ~= nil and info.type == LF.FileType.FILE {
				insert(templateNames, getSubstring(it, 1, -5))
			}
		}
		if not templateNames  return

		local x = buttons.layoutX
		local y = buttons.layoutY + buttons.layoutHeight + gui.getScrollOffset(buttons)

		gui.showContextMenu(guiState, x, y, templateNames, [templateNames,cb] (choice:int) {
			if choice > 0  cb(templateNames[choice])
		})
	}

	-- Texture files.
	guiState.onRefresh.exportProject_textures_copyFiles = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.exportTextures
	}
	guiState.onAction.exportProject_textures_copyFiles = (checkbox:gui.Checkbox, _:int) {
		local project          = app.projects[app.currentProjectIndex]
		project.exportTextures = checkbox.checked
		markEdited(project)
		gui.refreshRecursively(guiState, "exportProject_textures_pathResults")
		gui.refreshRecursively(guiState, "exportProject_textures_pathResultsInfo")
	}

	guiState.onRefresh.exportProject_textures_overwrite = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.exportTexturesOverwrite
	}
	guiState.onAction.exportProject_textures_overwrite = (checkbox:gui.Checkbox, _:int) {
		local project                   = app.projects[app.currentProjectIndex]
		project.exportTexturesOverwrite = checkbox.checked
		markEdited(project)
	}

	guiState.onRefresh.exportProject_textures_directory = (input:gui.InputText) {
		local project = app.projects[app.currentProjectIndex]
		input.value   = project.exportTexturesDirectory
	}
	guiState.onAction.exportProject_textures_directory = (input:gui.InputText, _:int) {
		local project                   = app.projects[app.currentProjectIndex]
		input.value                     = Path(trim(input.value)).toString!()
		project.exportTexturesDirectory = input.value
		markEdited(project)
		gui.refreshRecursively(guiState, "exportProject_textures_pathResults")
		gui.refreshRecursively(guiState, "exportProject_textures_pathResultsInfo")
	}

	guiState.onRefresh.exportProject_textures_pathResults = (textEl:gui.Text) {
		local project = app.projects[app.currentProjectIndex]

		if not project.exportTextures {
			textEl.text = ""
			return
		}

		local paths: []string
		local pathSet: struct { !key:string, !value:bool }

		for project.systems {
			local ok, path = resolveTextureOuputPath(project, it)

			if not ok {
				textEl.text = "Missing/invalid paths!"
				return
			}

			if not pathSet[path] {
				pathSet[path] = true
				insert(paths, path)
			}
		}

		textEl.text = concatinate(paths, ", ")
	}
	guiState.onRefresh.exportProject_textures_pathResultsInfo = (buttons:gui.Buttons) {
		buttons.tooltip = gui.getElement(guiState, "exportProject_textures_pathResults", gui.Text).text
	}
	guiState.onAction.exportProject_exportFiles = (buttons:gui.Buttons, buttonIndex:int) {
		local project = app.projects[app.currentProjectIndex]

		if not (project.exportParticles or project.exportTextures) {
			setErrorText("Nothing to export")
			return
		}

		-- Gather data.
		local particlesData = ""
		local particlesPath = ""

		if project.exportParticles {
			local ok, ^particlesData = generateDataToExportFromTemplate(project.exportParticlesTemplate)
			if not ok  return -- Error already reported.

			ok, particlesPath = resolveParticlesOuputPath(project)
			if not ok {
				setErrorText("No particle system output path")
				return
			}
		}

		local texturePaths: []string
		local texturePathSameAsInput: []bool

		if project.exportTextures  for project.systems {
			local ok, path, sameAsInput = resolveTextureOuputPath(project, it)

			if not ok {
				setErrorText("Missing texture output path(s)")
				return
			}

			texturePaths[itIndex]           = path
			texturePathSameAsInput[itIndex] = sameAsInput
		}

		-- Check existing files.
		static info: LF.FileInfo
		local filesToConfirmOverwrite: []string

		if project.exportParticles and not project.exportParticlesOverwrite {
			local _, dir, filename = Path(particlesPath).getDirectoryAndFilename!()

			if not connectToRemoteDirectory(dir) {
				setErrorText("Could not access folder '%s'", dir)
				return
			}
			defer disconnectFromRemoteDirectory()

			if LF.getInfo(filename, info) ~= NULL  insert(filesToConfirmOverwrite, particlesPath)
		}

		local texturePathSet: struct { !key:string, !value:bool }

		if project.exportTextures and not project.exportTexturesOverwrite  for project.systems {
			local path = texturePaths[itIndex]

			if texturePathSet[path]  continue
			texturePathSet[path] = true

			if texturePathSameAsInput[itIndex]  continue

			local _, dir, filename = Path(path).getDirectoryAndFilename!()

			if not connectToRemoteDirectory(dir) {
				setErrorText("Could not access folder '%s'", dir)
				return
			}
			defer disconnectFromRemoteDirectory()

			if LF.getInfo(filename, info) ~= NULL  insert(filesToConfirmOverwrite, path)
		}

		-- Write files.
		local writeExportFiles = [project, particlesData, particlesPath, texturePaths, texturePathSameAsInput] () {
			if project.exportParticles {
				local _, dir, filename = Path(particlesPath).getDirectoryAndFilename!()

				if not connectToRemoteDirectory(dir) {
					setErrorText("Could not access folder '%s'", dir)
					return
				}
				defer disconnectFromRemoteDirectory()

				local ok, err = LF.write(filename, particlesData)
				if not ok {
					setErrorText(err)
					return
				}
			}

			local texturePathSet: struct { !key:string, !value:bool }

			if project.exportTextures  for system: project.systems {
				local path = texturePaths[itIndex]

				if texturePathSet[path] continue
				texturePathSet[path] = true

				if texturePathSameAsInput[itIndex]  continue

				local _, dir, filename = Path(path).getDirectoryAndFilename!()

				if not connectToRemoteDirectory(dir) {
					setErrorText("Could not access folder '%s'", dir)
					return
				}
				defer disconnectFromRemoteDirectory()

				local ok, err = LF.write(filename, system.currentImageData.getString!())
				if not ok {
					setErrorText(err)
					return
				}
			}

			setMessageText("Exported files")
		}

		if filesToConfirmOverwrite {
			local BUTTONS: []gui.Button : {{label="Overwrite"},{label="Cancel"}}

			local text = (
				#filesToConfirmOverwrite == 1
				? "This file will be overwritten:"
				: format(
					"These %d files will be overwritten:",
					#filesToConfirmOverwrite
				)
			)

			local buttonList: []gui.Button
			for filesToConfirmOverwrite  insert(buttonList, cast(gui.Button){ label=it })

			local fileListEl = guiState.buttons!({ vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST, buttons=buttonList })

			pushTempChoiceDialog("Confirm export", text, BUTTONS, submitIndex=1, extraContent=fileListEl, [writeExportFiles] (choice:int) {
				if choice ~= 1  return

				writeExportFiles()
				popPanel()
			})

		} else {
			writeExportFiles()
			popPanel()
		}
	}

	local generateDataToExportFromTemplate :: (templateName:string) -> (success:bool, data:string) {
		local lua            :: !import "lua"
		local setEnvironment :: (f:(), env:table)              !foreign lua "setfenv"
		local pcall          :: (callback:any) -> bool, string !foreign lua "pcall"

		local path               = format("%s/%s.lua", EXPORT_TEMPLATES_DIRECTORY, templateName)
		local luaCode, sizeOrErr = LF.read(path)
		if luaCode == NULL {
			setErrorText("Could not load template: %s", cast(string)sizeOrErr)
			return false, ""
		}

		local ok, chunk, err = lua.loadString(cast(string)luaCode, (), "@"..path)
		if not ok {
			setErrorText("Could not load template: %s", err)
			return false, ""
		}

		-- Prepare data for template.
		local project = app.projects[app.currentProjectIndex]
		local publicParticleSystems: []table

		for system: project.systems {
			-- Note: We use values from the ParticleSystem instead of the System object
			-- whenever possible when exporting as those values are more representable
			-- of what the user expects.
			local ps = system.particles

			local publicParticleSystem: table
			insert(publicParticleSystems, publicParticleSystem)

			do {
				local ^ok, texturePath = resolveTextureOuputPath(project, system)

				if ok {
					local ^ok, basePath = resolveBaseOuputPath(project)
					if ok {
						local ^ok, texturePathObj = Path.getRelativeTo(texturePath, basePath)
						if ok  texturePath = texturePathObj.toString!()
					}
				} else {
					texturePath = ""
				}

				publicParticleSystem.texturePath = texturePath
			}

			publicParticleSystem.blendMode        = system.blendMode
			publicParticleSystem.bufferSize       = getOptimalBufferSize(system)
			publicParticleSystem.direction        = ps.getDirection!()
			publicParticleSystem.emissionRate     = ps.getEmissionRate!()
			publicParticleSystem.emitAtStart      = system.kickStartEmit
			publicParticleSystem.emitterLifetime  = ps.getEmitterLifetime!()
			publicParticleSystem.insertMode       = ps.getInsertMode!()
			publicParticleSystem.kickStartSteps   = system.kickStartSteps
			publicParticleSystem.kickStartDt      = getKickStartDt(system)
			publicParticleSystem.relativeRotation = ps.hasRelativeRotation!()
			publicParticleSystem.sizes            = cast([]float) { ps.getSizesAsVararg!() }
			publicParticleSystem.sizeVariation    = ps.getSizeVariation!()
			publicParticleSystem.spinVariation    = ps.getSpinVariation!()
			publicParticleSystem.spread           = ps.getSpread!()
			publicParticleSystem.texturePreset    = system.textureName
			publicParticleSystem.title            = system.title

			do { local min,max   = ps.getLinearDamping!()          ; publicParticleSystem.linearDamping          = cast(table) {min,max, min=min,max=max} }
			do { local min,max   = ps.getParticleLifetime!()       ; publicParticleSystem.particleLifetime       = cast(table) {min,max, min=min,max=max} }
			do { local min,max   = ps.getRadialAcceleration!()     ; publicParticleSystem.radialAcceleration     = cast(table) {min,max, min=min,max=max} }
			do { local min,max   = ps.getRotation!()               ; publicParticleSystem.rotation               = cast(table) {min,max, min=min,max=max} }
			do { local min,max   = ps.getSpeed!()                  ; publicParticleSystem.speed                  = cast(table) {min,max, min=min,max=max} }
			do { local min,max   = ps.getTangentialAcceleration!() ; publicParticleSystem.tangentialAcceleration = cast(table) {min,max, min=min,max=max} }
			do { local start,end = ps.getSpin!()                   ; publicParticleSystem.spin                   = cast(table) {start,end, atStart=start,atEnd=end} }
			do { local x,y       = ps.getOffset!()                 ; publicParticleSystem.offset                 = cast(table) {x,y, x=x,y=y} }

			do {
				local xmin, ymin, xmax, ymax = ps.getLinearAcceleration!()
				publicParticleSystem.linearAcceleration = cast(table) {
					xmin, ymin, xmax, ymax,
					xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax
				}
			}

			do {
				local distribution, dx, dy, angle, relative = ps.getEmissionArea!()
				publicParticleSystem.emissionArea = cast(table) {
					distribution, dx, dy, angle, relative,
					distribution=distribution, dx=dx, dy=dy, angle=angle, relative=relative,
				}
			}

			do {
				local publicColors: []float

				for {ps.getColorsAsVararg!()} {
					insert(publicColors, it[1])
					insert(publicColors, it[2])
					insert(publicColors, it[3])
					insert(publicColors, it[4])
				}

				publicParticleSystem.colors = publicColors
			}

			do {
				local iw, ih = system.currentImage.getDimensions!()
				local publicQuads: []table

				for system.frames {
					local publicQuad: table = {
						it.x, it.y, it.w, it.h, iw, ih,
						x=it.x, y=it.y, width=it.w, height=it.h,
					}
					insert(publicQuads, publicQuad)
				}

				publicParticleSystem.textureWidth  = iw
				publicParticleSystem.textureHeight = ih
				publicParticleSystem.quads         = publicQuads
			}
		}

		-- Run template.
		local writeLuaValue :: (buffer:[]string, level:int, v:any) {
			using lua.LuaType
			level += 1

			if !complete lua.getType(v) == {
				case BOOLEAN: !through
				case NIL:     !through
				case NUMBER:
					if     v == 0           insert(buffer, "0") -- Avoid writing "-0".
					elseif v == math.HUGE   insert(buffer, "math.huge")
					elseif v == -math.HUGE  insert(buffer, "(-math.huge)")
					elseif v ~= v           insert(buffer, "(0/0)")
					else                    insert(buffer, format("%s", cast(string)v)) -- The type we cast to doesn't matter here.

				case STRING:
					local s = replace(format("%q", cast(string)v), "\\\n", "\\n")
					insert(buffer, s)

				case TABLE: -- Assume it's an array.
					insert(buffer, "{")
					writeLuaCsv(buffer, level, cast([]any)v)
					insert(buffer, "}")

				case FUNCTION: !through
				case THREAD:   !through
				case USERDATA:
					errorf(level, "cannot serialize values of type '%s'", cast(string)lua.getType(v))

				case:
					errorf(level, "values of type '%s' are not supported", cast(string)lua.getType(v))
			}
		}

		local writeLuaCsv :: (buffer:[]string, level:int, arr:[]any) {
			level += 1
			for arr {
				if itIndex > 1  insert(buffer, ", ")
				writeLuaValue(buffer, level, it)
			}
		}

		local buffer: []string

		local templateEnv = prepareSandbox({
			Text = [buffer] (s:string) {
				if lua.getType(s) ~= lua.LuaType.STRING {
					errorf(2, "bad argument #1 to 'Text'. (string expected, got %s)", cast(string)lua.getType(s))
				}
				insert(buffer, s)
			},

			Lua = [buffer] (v:any) {
				writeLuaValue(buffer, 2, v)
			},

			LuaCsv = [buffer] (v:any) {
				if lua.getType(v) == lua.LuaType.TABLE
					writeLuaCsv(buffer, 2, cast([]any)v)
				else
					writeLuaValue(buffer, 2, v)
			},

			particleSystems  = publicParticleSystems,
			pixelateTextures = project.pixelateTextures,
		})

		setEnvironment(chunk, templateEnv)

		ok, err = pcall(chunk)
		if not ok {
			setErrorText("Error in template: %s", err)
			return false, ""
		}

		return true, concatinate(buffer)
	}

	-- Clipboard.
	guiState.onRefresh.exportProject_clipboard_template = (buttons:gui.Buttons) {
		local project            = app.projects[app.currentProjectIndex]
		buttons.buttons[1].label = project.exportClipboardTemplate
	}
	guiState.onAction.exportProject_clipboard_template = (buttons:gui.Buttons, buttonIndex:int) {
		showTemplateDropdownMenu(buttons, (templateName:string) {
			local project                   = app.projects[app.currentProjectIndex]
			project.exportClipboardTemplate = templateName
			markEdited(project)
			gui.refreshRecursively(guiState, "exportProject_clipboard_template")
		})
	}

	guiState.onAction.exportProject_clipboard_export = (buttons:gui.Buttons, buttonIndex:int) {
		local project  = app.projects[app.currentProjectIndex]
		local ok, data = generateDataToExportFromTemplate(project.exportClipboardTemplate)
		if not ok  return

		love.system.setClipboardText(data)
		setMessageText("Exported to clipboard")
	}

	--==============================================================
	--= Animation
	--==============================================================
	do {
		local PARAMS :: {
			"animation_sequence_areaPosition",
			"animation_sequence_areaSize",
			"animation_sequence_framePadding",
			"animation_sequence_frameSpacing",
			"animation_sequence_frameSize",
			"animation_sequence_rows",
			"animation_sequence_columns",
		}

		guiState.onActive.animation = (frame:gui.Frame) {
			local project, system = getCurrentProjectAndSystem()

			for PARAMS {
				local input     = gui.getElement(guiState, it, gui.InputText)
				local ok, value = getGuiValue(system, it)
				if ok  input.value = value
			}

			gui.refreshRecursively(guiState, "animation_frames")
		}

		guiState.onDraw.animation_preview = (canvasEl:gui.Canvas, cw,ch:int) {
			local PADDING :: 5
			local project, system = getCurrentProjectAndSystem()
			local image           = system.currentImage
			local iw, ih          = image.getDimensions!()

			local r, g, b = hsvToRgb(project.bgColor)
			LG.clear(r, g, b)

			if system.frames {
				local quads          = system.particles.getQuads!()
				local quad, progress = getQuadForAnimationPreview(system.particles, quads)
				local _, _, qw, qh   = quads[1].getViewport!()

				local w = math.round(qw)
				local h = math.round(qh)

				local scale = math.min((cw-2*PADDING)/w, (ch-2*PADDING)/h)

				local x = (cw - w*scale) // 2
				local y = (ch - h*scale) // 2

				LG.draw(image, quad, x, y, 0, scale)

				local progressW = math.round((cw-2)*progress)
				LG.setColor(1, 1, 1, .2)
				LG.rectangle(LG.DrawMode.FILL, 1, 1, progressW, 1)
				LG.rectangle(LG.DrawMode.FILL, 1+progressW-1, 1, 1, 1)

			} else {
				local scale = math.min((cw-2*PADDING)/iw, (ch-2*PADDING)/ih)

				local x = (cw - iw*scale) // 2
				local y = (ch - ih*scale) // 2

				LG.draw(image, x, y, 0, scale)
			}
		}

		guiState.onAction.animation_empty = (buttons:gui.Buttons, buttonIndex:int) {
			local project, system = getCurrentProjectAndSystem()
			if not system.frames  return

			system.frames = {}

			markEdited(project)
			gui.refreshRecursively(guiState, "animation_frames")
			updateParticleAnimation(system)
		}

		local parseTwoInts :: (s:string) -> bool, int, int {
			s = trim(s)

			local ok, xStr, yStr = matchPattern(s, "^(%-?%d+) +(%-?%d+)$")
			if not ok  return false, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)

			return true, x, y
		}

		local parseFourInts :: (s:string) -> bool, int, int, int, int {
			s = trim(s)

			local ok, xStr, yStr, zStr, wStr = matchPattern(s, "^(%-?%d+) +(%-?%d+) +(%-?%d+) +(%-?%d+)$")
			if not ok  return false, 0, 0, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)
			local _, z = stringToInt(cast(string) zStr)
			local _, w = stringToInt(cast(string) wStr)

			return true, x, y, z, w
		}

		local parseOneOrTwoInts :: (s:string) -> bool, int, int {
			s = trim(s)

			local        ok, xStr, yStr = matchPattern(s, "^(%-?%d+) +(%-?%d+)$")
			if not ok  { ok, xStr       = matchPattern(s, "^%-?%d+$") ; yStr = xStr }
			if not ok  return false, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)

			return true, x, y
		}

		guiState.onAction.animation_sequence_generateFromSize = (buttons:gui.Buttons, buttonIndex:int) {
			local project, system = getCurrentProjectAndSystem()
			local iw, ih          = system.currentImage.getDimensions!()

			local areaPosStr   = trim(gui.getElement(guiState, "animation_sequence_areaPosition", gui.InputText).value)
			local areaSizeStr  = trim(gui.getElement(guiState, "animation_sequence_areaSize",     gui.InputText).value)
			local paddingStr   = trim(gui.getElement(guiState, "animation_sequence_framePadding", gui.InputText).value)
			local spacingStr   = trim(gui.getElement(guiState, "animation_sequence_frameSpacing", gui.InputText).value)
			local frameSizeStr = trim(gui.getElement(guiState, "animation_sequence_frameSize",    gui.InputText).value)

			local ok, areaX, areaY = parseTwoInts(areaPosStr)
			if not ok { setErrorText("Invalid area position format") ; return }
			if areaX < 0  areaX += iw
			if areaY < 0  areaY += ih

			local ^ok, areaW, areaH = parseOneOrTwoInts(areaSizeStr)
			if not ok { setErrorText("Invalid area size format") ; return }
			if areaW <= 0  areaW += iw-areaX
			if areaH <= 0  areaH += ih-areaY

			local ^ok, padX, padY = parseOneOrTwoInts(paddingStr)
			if not ok { setErrorText("Invalid padding format") ; return }

			local ^ok, spacingX, spacingY = parseOneOrTwoInts(spacingStr)
			if not ok { setErrorText("Invalid spacing format") ; return }

			local ^ok, frameW, frameH = parseOneOrTwoInts(frameSizeStr)
			if not ok                          { setErrorText("Invalid frame size format") ; return }
			if not (frameW > 0 and frameH > 0) { setErrorText("Frame size must be positive") ; return }

			local paddedW = frameW + 2*padX
			local paddedH = frameH + 2*padY
			local cols    = (areaW + spacingX) // (paddedW + spacingX)
			local rows    = (areaH + spacingY) // (paddedH + spacingY)

			local frameCount = cols * rows
			if frameCount < 1 { setErrorText("Animation frame count results in zero") ; return }

			setMessageText("")
			system.frames = {}

			for row = 1, rows {
				for col = 1, cols {
					local x = areaX + (col-1) * (paddedW + spacingX) + padX
					local y = areaY + (row-1) * (paddedH + spacingY) + padY

					local animFrame: AnimationFrame = {x=x, y=y, w=frameW, h=frameH}
					insert(system.frames, animFrame)
				}
			}

			for PARAMS {
				local input = gui.getElement(guiState, it, gui.InputText)
				setGuiValue(system, it, input.value)
			}

			markEdited(project)
			updateParticleAnimation(system)
			gui.refreshRecursively(guiState, "animation_frames")
		}

		guiState.onAction.animation_sequence_generateFromDivision = (buttons:gui.Buttons, buttonIndex:int) {
			local project, system = getCurrentProjectAndSystem()
			local iw, ih          = system.currentImage.getDimensions!()

			local areaPosStr   = trim(gui.getElement(guiState, "animation_sequence_areaPosition", gui.InputText).value)
			local areaSizeStr  = trim(gui.getElement(guiState, "animation_sequence_areaSize",     gui.InputText).value)
			local paddingStr   = trim(gui.getElement(guiState, "animation_sequence_framePadding", gui.InputText).value)
			local spacingStr   = trim(gui.getElement(guiState, "animation_sequence_frameSpacing", gui.InputText).value)
			local rowsStr      = trim(gui.getElement(guiState, "animation_sequence_rows",         gui.InputText).value)
			local colsStr      = trim(gui.getElement(guiState, "animation_sequence_columns",      gui.InputText).value)

			local ok, areaX, areaY = parseTwoInts(areaPosStr)
			if not ok { setErrorText("Invalid area position format") ; return }
			if areaX < 0  areaX += iw
			if areaY < 0  areaY += ih

			local ^ok, areaW, areaH = parseOneOrTwoInts(areaSizeStr)
			if not ok { setErrorText("Invalid area size format") ; return }
			if areaW <= 0  areaW += iw-areaX
			if areaH <= 0  areaH += ih-areaY

			local ^ok, padX, padY = parseOneOrTwoInts(paddingStr)
			if not ok { setErrorText("Invalid padding format") ; return }

			local ^ok, spacingX, spacingY = parseOneOrTwoInts(spacingStr)
			if not ok { setErrorText("Invalid spacing format") ; return }

			local ^ok, rows = stringToInt(rowsStr)
			if not ok   { setErrorText("Invalid row count format") ; return }
			if rows < 1 { setErrorText("Row count must be positive") ; return }

			local ^ok, cols = stringToInt(colsStr)
			if not ok   { setErrorText("Invalid column count format") ; return }
			if cols < 1 { setErrorText("Column count must be positive") ; return }

			local unitW   = (areaW + spacingX) // cols
			local unitH   = (areaH + spacingY) // rows
			local paddedW = unitW - spacingX
			local paddedH = unitH - spacingY
			local frameW  = paddedW - 2*padX
			local frameH  = paddedH - 2*padY

			if frameW < 1 or frameH < 1 { setErrorText("Animation frame size results in zero") ; return }

			setMessageText("")
			system.frames = {}

			for row = 1, rows {
				for col = 1, cols {
					local x = areaX + (col-1) * (paddedW + spacingX) + padX
					local y = areaY + (row-1) * (paddedH + spacingY) + padY

					local animFrame: AnimationFrame = {x=x, y=y, w=frameW, h=frameH}
					insert(system.frames, animFrame)
				}
			}

			for PARAMS {
				local input = gui.getElement(guiState, it, gui.InputText)
				setGuiValue(system, it, input.value)
			}

			markEdited(project)
			updateParticleAnimation(system)
			gui.refreshRecursively(guiState, "animation_frames")
		}

		guiState.onRefresh.animation_frames = (vbox:gui.Vbox) {
			local project, system = getCurrentProjectAndSystem()

			for < vbox  gui.delete(guiState, it)

			for system.frames {
				local inputValue = format("%s %s %s %s", it.x, it.y, it.w, it.h)

				insert(vbox, guiState.hbox!({ name="animation_frame", data=itIndex, labelLeft=format("#%d", itIndex),
					guiState.buttons!({ buttons={
						{name="animation_delete", image="iconDelete", tooltip="Remove frame"},
						{name="animation_add",    image="iconAdd",    tooltip="Add/duplicate frame"},
						{name="animation_move",   image="iconMoveV",  tooltip="Move frame (drag)", draggable=true},
					} }),
					guiState.inputText!({ name="animation_xywh", weight=1, value=inputValue, tooltip="Format: [x y width height]" }),
					guiState.text!({ name=format("animation_message%d", itIndex), width=50 }),
				}))
			}
		}

		local getAnimationFrame :: (el:gui.Element) -> AnimationFrame, int {
			local project, system = getCurrentProjectAndSystem()
			local _, parent       = gui.findParent(guiState, el, "animation_frame")
			local i               = cast(int) parent.data

			return system.frames[i], i
		}
		guiState.onAction.animation_delete = (buttons:gui.Buttons, buttonIndex:int) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(buttons)

			remove(system.frames, i)

			markEdited(project)
			updateParticleAnimation(system)
			gui.refreshRecursively(guiState, "animation_frames")
		}
		guiState.onAction.animation_add = (buttons:gui.Buttons, buttonIndex:int) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(buttons)

			local animFrameNew: AnimationFrame = {
				x = animFrame.x,
				y = animFrame.y,
				w = animFrame.w,
				h = animFrame.h,
			}
			insert(system.frames, i+1, animFrameNew)

			markEdited(project)
			updateParticleAnimation(system)
			gui.refreshRecursively(guiState, "animation_frames")
		}
		guiState.onAction.animation_xywh = (input:gui.InputText, _:int) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(input)

			local ok, x, y, w, h = parseFourInts(input.value)
			if not ok {
				setErrorText("Invalid frame values format")
				gui.getElement(guiState, format("animation_message%d", i), gui.Text).text = "Error!"
				return
			}

			animFrame.x = x
			animFrame.y = y
			animFrame.w = w
			animFrame.h = h

			markEdited(project)
			updateParticleAnimation(system)
			gui.getElement(guiState, format("animation_message%d", i), gui.Text).text = ""
		}
		guiState.onDrag.animation_move = (buttons:gui.Buttons, buttonIndex:int, mx,my:int) {
			local project, system = getCurrentProjectAndSystem()
			local animFrame, i    = getAnimationFrame(buttons)

			local dragContainer = gui.getElement(guiState, "animation_frames", gui.Vbox)

			local frames      = system.frames
			local targetIndex = math.clamp(math.floor(1 + (my - (dragContainer.layoutY + gui.getScrollOffset(dragContainer))) / (dragContainer[1].layoutHeight + gui.SPACING)), 1, #frames)
			if targetIndex == i  return

			local dir = math.getSign(targetIndex-i)

			for j = i, targetIndex-dir, dir {
				frames[j], frames[j+dir] = frames[j+dir], frames[j]
			}

			markEdited(project)
			updateParticleAnimation(system)
			gui.refreshRecursively(guiState, dragContainer)

			guiState.activeId  = dragContainer[targetIndex][1].id -- Must happen after refreshRecursively() as all elements are replaced! @Volatile
			guiState.hoveredId = guiState.activeId
		}
	}

	--==============================================================
	--= Preferences
	--==============================================================

	guiState.onActive.preferences = (frame:gui.Frame) {
		gui.refreshRecursively(guiState, frame)
	}

	guiState.onRefresh.preferences_maxBufferSize = (input:gui.InputText, _:int) {
		input.value = format("%.0f", app.maxBufferSize)
	}
	guiState.onAction.preferences_maxBufferSize = (input:gui.InputText, _:int) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n                 = math.clamp(n, 1000, 2^52)
		app.maxBufferSize = n
		input.value       = format("%.0f", n)
		scheduleSaveWorkspace()

		for project: app.projects {
			for project.systems  updateBufferSize(it)
		}
	}

	guiState.onRefresh.preferences_maxRecentFiles = (input:gui.InputText, _:int) {
		input.value = format("%.0f", app.maxRecentFiles)
	}
	guiState.onAction.preferences_maxRecentFiles = (input:gui.InputText, _:int) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n                  = math.clamp(n, 0, 100)
		app.maxRecentFiles = n
		input.value        = format("%.0f", n)
		scheduleSaveWorkspace()
	}
	guiState.onRefresh.preferences_maxRecentFolders = (input:gui.InputText, _:int) {
		input.value = format("%.0f", app.maxRecentFolders)
	}
	guiState.onAction.preferences_maxRecentFolders = (input:gui.InputText, _:int) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n                    = math.clamp(n, 0, 20)
		app.maxRecentFolders = n
		input.value          = format("%.0f", n)
		scheduleSaveWorkspace()
	}

	guiState.onRefresh.preferences_maxChanges = (input:gui.InputText, _:int) {
		input.value = format("%.0f", app.maxChanges)
	}
	guiState.onAction.preferences_maxChanges = (input:gui.InputText, _:int) {
		local ok, n = stringToInt(input.value)
		if not ok {
			setErrorText("Bad value format: "..input.value)
			return
		}
		n              = math.clamp(n, 1, 2^52)
		app.maxChanges = n
		input.value    = format("%.0f", n)
		scheduleSaveWorkspace()
	}

	--==============================================================
	--= Utils
	--==============================================================

	guiState.onAction.util_pushPanel = (el:gui.Element, _:int) {
		pushPanel(cast(string) el.data)
	}
	guiState.onAction.util_popPanel = (el:gui.Element, _:int) {
		popPanel()
	}
}


